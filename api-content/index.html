{"posts":[{"title":"培训-ES语法","content":"一、概念 ECMAScript（ES）：是一个国际通用性的标准化脚本语言。 JavaScript（JS）：ECMAScript、DOM和BOM组成。 简单地理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。 2011 年，ECMAScript 5.1 版发布。也就是ES5('use strict', forEach, map,filter.some...[Array.prototype], JSON.parse, JSON.stringfiy, object.defineProperty)。 2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。 目前已经发展至ES12。 二、为什么要学习ES? 精简代码，且主流浏览器已支持ES6（如果需要适配IE9-，不建议使用）。 行业内较新的前端框架（vue、react、原生微信小程序、uniapp、taro）都已经使用ES6+语法。 便于阅读框架源码。 三、常用ES6语法 let、const 限制在块级作用域({})的变量定义方式。 let是新的var，但是声明的变量只能在当前块级作用域有效。 const声明常量，常量只能赋值一次，一旦声明就不能改变。 与var区别: 1）var声明的变量为全局变量，默认绑定到windows上，全局作用域有效；而let仅在当前声明的块级作用域内有效。 在同一个块级作用域里，变量只能被let声明一次；在不同的块级作用域里，变量可以被let声明多次。var可以在全局作用域内声明多次。 let严格遵守代码顺序，不存在变量提升。而var声明的变量，会忽略声明顺序，可以提升变量。 模板字符串 模板字符串为构造字符串提供了语法糖。符号 `` let person = 'xiaoming'; console.log(person + '是个好学生')； // 等价于 console.log(`${person}是个好学生`)； 扩展(延展)运算符、rest运算符 都是三个点 &quot;...&quot;。 扩展(延展)运算符：用于把数组或者类数组对象展开形成一系列用逗号隔开的值。 let getFunc = (x, y) =&gt; { console.log(x); console.log(y); } let arr = [1, 2]; // 普通做法 getFunc(arr[0], arr[1]); // 打印 1， 2 // 使用扩展运算符 getFunc(...arr)；// 打印1， 2 使用场景 1、给数组做深拷贝 let arr1 = [1, 2]; let arr2 = [...arr1]; console.log(arr1 === arr2); // false 2、合并数组，相当于ES5中的concat let arr1 = [1, 2]; let arr2 = [3, 4]; console.log(arr1.concat(arr2)); // 打印 [1, 2, 3, 4] console.log([...arr1, ...arr2]); // 打印 [1, 2, 3, 4] 3、字符串转数组 let str = 'hello'; console.log([...str]); // 打印 ['h', 'e', 'e', 'l', 'o'] rest运算符：把逗号隔开的值组合成一个数组 or 对象。 使用场景 1、不定参数传值 // 不定参数传值 - 数组 let getArrItem = ([...args]) =&gt; { console.log(args[0]); console.log(args[1]); console.log(args[2]); console.log(args[3]); } getArrItem([1, 2, 3]) // 不定参数传值 - 对象 let getObjItem = ({ ...args }) =&gt; { console.log(args.id); console.log(args.name); } getObjItem({ id: '1', name: 'xiaoming', address: '济南市' })； 2、与解构赋值关联使用，具体见解构赋值。 解构赋值 允许基于模式匹配的方式进行赋值，这种模式匹配能够支持 数组和对象。 对于数组： ​ 1、数组中的数据会自动解析到对应接受该值的变量中，数组的解构赋值要一一对应，否则就是undefined。 ​ 2、可以直接省略元素，使用','做占位符。 ​ 3、rest运算符 '...', 可以用于获取数组部分数据。 // 数组 let [ a, b, c, , d ] = [1, 2, 3, 4, 5] console.log('a:' + a) console.log('b:' +b) console.log('c:' +c) console.log(d) 对于对象： ​ 1、对象与数组不同，对象不要求一一对应，但是要求变量必须与属性同名(不使用别名的情况),这样才能获取到正确的值。 ​ 2、使用别名：let { local:address } = { local: '山东' } 可以访问address ​ 3、rest运算符 '...'，可以用于获取对象部分数据。 ​ 4、嵌套对象时与上述相同。 // 对象 let { id, name, address: local, ...otherinfo } = { id: 1 , name: 'xiaoming',address: '济南市', sex: '男', note: '' }; console.log(id) console.log(name) console.log(local) console.log(otherinfo) let obj = { id: 2, ...otherinfo } console.log(obj) // 嵌套对象 let { ids, otherinfos: { company } } = { ids: 2, otherinfos: { company: 'jxd' } }; console.log(company) 箭头函数 类似于匿名函数，将原函数的&quot;function&quot;关键字和函数名都去掉，并且用&quot;=&gt;&quot;连接参数列表和函数体。 function add(x, y) { return x + y } // 等价于 let add = (x, y) =&gt; { return x + y } // 等价于 let add = (x, y) =&gt; x + y console.log(add(1,2)); 注意点： 函数的参数只有一个时，可以省略 ()。 ​ 函数体内只有一条return语句,且返回非对象时，可以省略 return关键字和{}；当返回对象时，需要加()，避免和函数体的{...}有语法冲突。 // 返回非对象 let getNum = （x）=&gt; { return x }; // 等价于 let getNum = x =&gt; x; // 返回对象 let getObj = name =&gt; ({ name: name }); console.log(getObj('xiaoming')); 2）箭头函数的this指向就是上下文里对象this的指向，如果没有上下文对象，this就指向window。不受call、apply、bind等方法的影响。 // 关于this指向 let obj = { id: '1', age: this, // 指向window name: () =&gt; { console.log(this); // 指向window setTimeout(() =&gt; { console.log(this);// 指向window })}, getFunc: function() { console.log(this); // 指向obj setTimeout(() =&gt; { console.log(this); // 指向obj }) } } obj.age; obj.name(); obj.getFunc(); 类(class) ​ 类（class）是在基于原型的面向对象模式上简单包装的语法糖。拥有一个 单一且方便的声明形式将更易于使用，并且 鼓励混合使用。类（class）支持基于原型的继承、super 调用、 实例和静态方法以及构造函数。 等价于构造函数。 1、基本格式 ​ 1) class后面紧跟方法名，方法名需要大写。 ​ 2) 创建实例时，使用new Xxx()的格式。 ​ 3) 都存在constructor,即构造函数。 // 声明类 class Person { constructor(name) { this.name = name; } getPersonInfo() { console.log(this.name) } } // 创建实例 let person = new Person('xiaoming'); person.getPersonInfo(); 2、继承 ​ 1) 使用关键字 extends。 ​ 2) constructor中必须使用super(),用于继承父元素的属性和方法。 // 声明类 class BoyPerson extends Person { constructor(name, sex) { super(name); this.sex = sex; } getBoyPersonInfo() { console.log(`姓名: ${this.name}, 性别: ${this.sex}`); } } // 创建实例 let boy = new BoyPerson('xiaoli', '男') boy.getBoyPersonInfo(); 3、实例属性 ​ 1) 定义在constructor()方法中的属性都是对象的属性，可以用this获取。 ​ 2) 实例属性也可以定义在类顶层的，定义格式 _xxx， 通过this获取。 4、静态属性和方法 ​ 所有在类中定义的属性和方法，都会被实例继承。如果在属性和方法前面添加static，则该属性和方法不会被实例继承，而是直接通过类来调用，这就是静态方法。 ​ 1) 使用关键字 static。 ​ 2) 不能通过实例调用，只能通过类调用，即构造函数.方法名。 5、私有属性和方法 只能在类的内部访问的属性和方法，外部不能调用。 ​ 写法： 在属性或者方法前面加 #。 ​ 内部访问:需要 this.#属性名|方法名。 class BoyPerson extends Person { _local = '济南市'; #age = 10; constructor(name, sex) { super(name); this.sex = sex; } getBoyPersonInfo() { console.log(`姓名: ${this.name}, 性别: ${this.sex}, 地址: ${this._local}, 年龄${this.#age}`); } } let boy = new BoyPerson('xiaoli', '男') boy.getBoyPersonInfo(); console.log(boy._local); // 打印 济南市 console.log(boy.#age); // 报错 PS: ​ 1）类声明和函数声明一个重要的区别，类声明不会在作用域内导致变量提升。所以在使用类的时候先声明后创建实例。 ​ 2) constructor中定义的内容都会绑定到对象的属性上，类的所有方法会定义prototype上，例如constructor()、getBoyPersonInfo() 会绑定到构造函数的prototype上。 ​ 3) 添加方法确实可以通过 Person.prototype.add = () { return 1 } || person.proto.add = () =&gt; { return 1 }。但是不推荐，会影响其他实例。 class Person { static comeFrom = 'china' constructor(name) { this.name = name; } getPersonInfo() { console.log(this.name) } } let person = new Person('xiaoming'); let person2 = new Person('xiaoli'); person.__proto__.getName = () =&gt; { console.log(this.name) }; Promise ​ 构造函数，异步操作容器，里面存在一个异步操作。通过Promise可以获取该异步操作可能发生的结果，比如pending, fulfilled, rejected。 1、Promise对象特点 ​ 1）提供三种状态，pending(进行中)、fulfilled(已成功)、rejected(已失败)，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个操作。 ​ 2）状态变化有两种，从pending -&gt; fulfilled || pending -&gt; rejected。 2、作用 ​ 1) 异步操作以同步的写法表现出来,避免回调函数层层嵌套 .then().catch().finally()。 ​ 2) Promise对象提供了许多API，使异步函数处理更加容易。 3、基本用法 ​ 1) 创建promise实例。Promise构造函数接收一个函数作为参数，该函数中有两个参数，分别是resolve，reject。 ​ 2) 调用Promise提供方法。Promise对象生成后，可以用then() 指定resolve(必选)和reject(可选)状态的回调函数。 ​ 3) 如果resolve()带有参数，该参数会被传递给回调函数。如果reject() 带有参数，该参数一般是Error对象的实例，也会被传递给回调函数。 const promise = new Promise((resolve, reject) =&gt; { // todo 这里处理逻辑 if(success) { // 成功时执行 resolve(value) } else { // 失败时执行 reject(value) } }) promise.then(value =&gt; { }, err =&gt; { }) 4、Promise实例提供的方法 ​ 1) Promise.all(iterator),其中iterator必须是个可迭代的对象，比如Array 或者 String，返回一个Promise实例 ​ 传入参数中任意一个primise返回失败，则整体返回失败，返回的错误信息为第一个失败的promise结果。 ​ 2) Promise.race(iterator)。返回最先发生改变的实例。 ​ 3) Promise.resolve(value): 返回一个以给定的值解析后的Promise对象。 ​ 4) Promise.reject(reason): 返回一个含有reason的状态为rejected的Promise对象。 ​ 5) Promise.prototype.then(): 为Promise实例状态发生变化时添加回调函数，接受两个参数，fulfilled状态时的回调函数，rejected状态时的回到函数。并且该方法返回一个新的Promise对象。 ​ 6) Promise.prototype.finally(): 返回一个Promise, 在上一轮promise运行后，无论状态是fullfilled还是rejected，都会执行finally中指定的回调函数。 ​ 7) Promise.prototype.catch(): 返回一个Promise，并且处理拒绝情况，与then中的err相同。这里推荐使用catch方法，不要在then() 中定义rejected状态的回调函数，这是因为catch还可以捕捉在then()方法执行中存在的错误。 getPreApprovalList(params) { return new Promise((resolve, reject) =&gt; { OtherContractService.getPreApprovalList(params).then(data =&gt; { (data.list || []).forEach(i =&gt; this.$set(i, 'deleteLoading', false)) resolve(data) }).catch(e =&gt; { reject(e) }) }) } promise具有then(),返回一个新的promise实例，因此可以采用链式写法，即then方法后面再调用then。 5、关于Promise执行顺序 // 执行顺序 function timeOut(ms) { return new Promise((resolve, reject) =&gt; { console.log(4) return setTimeout(resolve, ms, '5' ) }) } timeOut(100).then(val =&gt; { console.log(val) }, err =&gt; { console.log('失败') }) let promise = new Promise((resolve, reject) =&gt; { resolve(2); // 这里比较下加return的情况 console.log(1); }) promise.then(val =&gt; { console.log(val) }) console.log(3) 解析： 1、创建Promise实例时，优先执行Promise实例中的console。 2、执行同步console。 3、从上往下执行不含延时的Promise的resolve or reject。 4、从上往下执行含有延时的Promise的resolve or reject。 timeOut是个含有返回Promise对象的方法，当执行timeOut(100)时，会生成Promise实例，这里面的4优先打印，then()暂缓； let promise = new Promise({...}),这时候Promise对象已经创建，所以接下来打印1，then()暂缓； 打印同步的3； 从上往下数，第二个promise没有延时，优先打印2。 最后打印5。 6、实现异步加载图片 let url = &quot;图片地址&quot;; function loadImageAsync(url) { return new Promise((resolve, reject) =&gt; { var image = new Image(); image.src = url; image.onload = function() { resolve(image); } image.onerror = function() { reject('加载失败') } }) } loadImageAsync(url).then(val =&gt; {}) 7、总结 ​ 1) 什么是Promise? ​ Promise() 其实是个构造函数，用户可以根据操作状态给与处理。Promise()的prototype提供了多个api，比如all()、race()、then()、catch()、finally()，给实例化的promise对象提供了操作、执行、异常捕捉、后续执行这些方法。 ​ 2）与普通回调函数的区别。 ​ 在执行多项异步操作时，普通的回调函数需要在回调中嵌套回调，代码比较臃肿，容易出现回调地狱。通过promise，可以在then()中resolve返回下一个异步操作，then()返回的是一个新的promise对象，原型对象上存在then(),可以链式调用。 数据结构 Set 构造函数，类似于数组，但是成员的值都是唯一的，可以用于去重（仅适用于普通数组，不适用于对象数组）。 数组去重方法：[ ...new Set(arr) ] 1）Set的属性及方法 ​ constructor: 构造函数，返回Set(); ​ size: 返回实例的成员总数 ​ add(val): 添加某个值，返回Set结构本身 ​ delete(val): 删除某个值，返回boolean; ​ has(val): 查找是否含有某个值，返回boolean; ​ clear(): 清除所有指，没有返回值。 2) Set遍历操作 ​ keys(): 返回键名的遍历器 ​ values(): 返回键值的遍历器 ​ entries(): 返回键值对的遍历器 ​ forEach((value, keys) =&gt; {}) 数据结构Map 构造函数，类似于Object，{ key: value }的形式，但是和Object有区别 Object:只能用字符串当key， &quot;字符串 -&gt; 值&quot; Map: 键的范围不限于字符串，各种类型的值（包括对象）都可以当做key，&quot;值 -&gt; 值&quot;； const map = new Map([['name', 'xiaoming'], ['title', 'author']]) 1）Map的属性和方法 ​ size: 返回Map结构的成员总数 ​ set(key, value): 设置键名为key的对应键值为value，然后返回整个Map。 ​ get(key): 读取键值为key的键值 ​ has(key): 判断某个键是否在当前的Map对象中，返回Boolean。 ​ delete(key): 删除某个值，返回boolean ​ clear(): 清空Map对象 四、ES7~ES12部分常用语法 async 、await 异步终极解决方案。以同步的写法完成异步操作流程，避免异步嵌套。 async: 表示函数里有异步操作。 await: 表示跟随在后面的表达式需要等待结果， await 后面跟着Promise对象 。 当函数执行时一旦遇到await就返回，等到触发的异步操作完成，再接着执行函数体后面的语句。 let timeOut = ms =&gt; { return new Promise((resolve, reject) =&gt; { return setTimeout(resolve, ms, 'timeOut') }) } // 打印顺序 timeOut, 1 let asyncMethod = async () =&gt; { try { let timeConsole = await timeOut(2000); console.log(timeConsole); console.log(1) } catch(e) { console.log(e) } } asyncMethod(); 注意点： await 后面的Promise对象，运行有可能返回reject，最好把await放在try...catch里,这样能够捕捉异常。 await只能用在async函数中，如果是普通函数就会报错。 可以使用 promise.all 方法发起多个请求。 async function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results); } // 或者使用下面的写法 ES9 异步迭代 await可以和for...of循环一起使用，以串行的方式运行异步操作 async function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = []; for (let promise of promises) { results.push(await promise); } console.log(results); } 当出现多个Promise ```javascript let timeOut1 = ms =&gt; { return new Promise((resolve, reject) =&gt; { return setTimeout(resolve, ms, 'timeOut1') }) } let timeOut2 = ms =&gt; { return new Promise((resolve, reject) =&gt; { return setTimeout(resolve, ms, 'timeOut2') }) } let timeOut3 = ms =&gt; { return new Promise((resolve, reject) =&gt; { return setTimeout(resolve, ms, 'timeOut3') }) } let funcArr = [ timeOut1(1000), timeOut2(2000), timeOut3(3000) ] async function promiseFunc() { console.time(); let result = await Promise.all(funcArr); console.log(result); console.timeEnd(); console.log('结束') } promiseFunc(); Array.prototype.includes 返回Boolean，表示某个数组是否包含指定值。 let arr = [1, 2, 3]; if(arr.includes(1)) { console.log('包含') } String.trimStart()和String.trimEnd() 去除字符串首尾空白字符。 空值处理 ?? 表达式在 ?? 的左侧 运算符求值为undefined或null，返回其右侧。 Optional chaining（可选链） ?.用户检测不确定的中间节点 let person = {}; // let childName = person.children.name; // 报错 Cannot read property 'name' of undefined let childName = person.children ?. name; // undefined console.log(childName); 五、参考 Babel官网中文文档：https://www.babeljs.cn/docs/learn Babel官网中文文档：https://www.liaoxuefeng.com/wiki/1022910821149312 阿西河ECMAScript 文档说明：https://www.axihe.com/api/js-es/api/api.html 六、补充 原型、原型链关系 ","link":"https://hviker.github.io/post/pei-xun-es-yu-fa/"},{"title":"培训-Git提交流程","content":"一、目的： ​ 1、增加项目负责人或组长对代码审核操作，对不规范代码及时打回指正。不规范代码指不符合该项目组原定编码规范、可复用功能代码多次编写、垃圾代码垃圾注释等，避免新人多次编写不规范代码。 ​ 2、统一编码规范，便于后期代码交接维护。 二、具体提交流程 1、项目基本设置 ​ 1.1 后期项目负责人在上传项目时，需要设置三个分支。master：主分支(默认存在)，release： 开发分支，test： 测试分支。其中三个分支在允许合并到以及允许推送到上都选择maintainers权限，只能由项目负责人完成三个分支上的操作权限，不允许其他成员通过merge或者push的方式推送项目代码。 ​ 人员设置： 2、个人推送代码方式 ​ 2.1 拉取代码后执行git branch（获取本地所有分支）命令后，显示只有master。对于已经存在的远程分支，需要使用git chekcout 【分支名称】来拉取到本地。这里以拉取已存在的release分支为例： ​ 2.2 执行git checkout -b chore-update-【姓名首字母缩写】创建并切换到属于自己的本地分支,该分支内容与本次切换过来的release分支内容相同。这里也可以由项目负责人提前建好每个人分支名称，这时候就可以跳过接下来的2.3、2.4操作，在个人分支开发完成后直接add、commit、push即可。 ​ Ps:此时只是在本地添加了分支，远程环境上并不存在该分支。 ​ 2.3 后期本人需要在该分支上修改，完成add、commit操作。 ​ 2.4 执行完commit后需要创建同名的远程分支，并做关联。执行命令 git push --set-upstream origin 【同名的远程分支名】，这里以chore-update-lly为例。 ​ 此时再去查看远程分支就多了一项不受保护的远程分支： chore-update-lly ​ **ps:这里如果没有配置SSH会提示没有匹配，所以在使用git时大家一定要关联好自己的SSH。**没有SSH时会报以下错误： ​ 2.5 确定提交到个人分支后，登录117git，选中项目后发起合并请求，确定修改分支和目标分支，并填写审核人员，发起合并申请。并通知审核人员及时审核。 点击比较分支后继续按钮，进入下面页面 下面是负责人相关界面： 这里点击Merge when piole success右侧下拉时会出现两个按钮。第一个是配置自动化部署jenkins并且流水线完成后才合并(这里只是审核代码，不需要合并)。第二个直接点击合并。合并前请项目负责人或者组长做好审查代码工作！！！ 选择第二个后会显示已合并状态，虽然流水线还在等待但是不影响合并功能。 此时查看release记录会增加修改的提交记录,查看release分支后已经存在合并内容。 2.6 合并完成后远程release分支相对于本地的release分支以及本地的chore-update-lly是有区别的，提前于本地分支。为了避免后期合并冲突增多，需要更新本地release以及chore-update-lly分支。 ​ (1) 对于release分支，直接切换到分支执行 git pull --rebase即可。 ​ (2) 对于chore-update-lly分支，需要切换到该分支，然后执行merge命令。经过上述命令可以知道release是最新的，切换到chore-update-lly分支后执行命令 git merge release，git push即可。 上面执行git merge release后，会把release的更新内容更新到本地的chore-update-lly上，但是chore-update-lly是存在没有保护状态远程分支的，这里需要提交下及时更新该远程分支。确保chore-update-lly分支内容与当前release分支最新内容保持一致。 3、常见问题 ​ 3.1 在其他分支修改后如何调整到源分支？例如下图，需要在chore-update-lly上修改，但是却发生在release分支。 ​ 这时候请保持在未add状态，执行git stash将内容暂存，切换到chore-update-lly后再执行git stash pop命令，将暂存内容转移至chore-update-lly分支。 3.2 如果2.6 操作不及时，可能会出现很多冲突。冲突的地方请联系代码提交者合并冲突后再提交。如果冲突过多建议重新创建本地分支及远程分支，将修改内容重新放置新分支上再执行上述操作。远程分支删除一定要跟项目负责人沟通,确认没问题后由项目负责人删除远程分支. ","link":"https://hviker.github.io/post/pei-xun-git-ti-jiao-liu-cheng/"},{"title":"如何封装全局组件并且被Vue.use(plugin) 使用","content":"1、首先我们要先了解下Vue.use(plugin)的用法。 参数： {Object | Function} plugin 用法： 安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。 该方法需要在调用 new Vue() 之前被调用。 当 install 方法被同一个插件多次调用，插件将只会被安装一次。 下面是vue2.0源码，使用vue.use(plugins)其实是将plugin放到vue构造器的_installedPlugins属性里，防止重复安装，并且以Vue.component的方式做全局组件。 Vue.use = function (plugin) { // 获取vue构造器当前已经use的组件，如果组件已经存在则返回当前vue对象，避免同一组件重复use var installedPlugins = (this._installedPlugins || (this._installedPlugins = [])); if (installedPlugins.indexOf(plugin) &gt; -1) { return this } // additional parameters // 将类数组对象转化成数组，满足apply(对象， 数组) var args = toArray(arguments, 1); args.unshift(this); if (typeof plugin.install === 'function') { plugin.install.apply(plugin, args); } else if (typeof plugin === 'function') { plugin.apply(null, args); } // 填充到vue的_installedPlugins中 installedPlugins.push(plugin); return this }; plugin必须是个对象或者方法，对象的话必须存在install(), 方法的话默认该方法就是install(); 2、如何封装自己的组件 ​ 这里分自写组件库使用和自己项目上使用。 自写组件库使用 参考element-ui，具体分层和代码如下 1) 按照包格式编写组件。 内容： 2）各文件内容 /dbutton/src/main.vue &lt;template&gt; &lt;button class=&quot;btn&quot;&gt;点击&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;Dbutton&quot;, // 这里名称建议为组件包名称，首字母大写 components: {}, data() { return {}; }, computed: {}, watch: {}, created() {}, mounted() {}, methods: {}, }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; //@import url(); 引入公共css类 .btn { padding: 12px 20px; font-size: 16px; background: blue; border-radius: 5px; color: #ffffff; &amp;:hover { background: red; } } &lt;/style&gt; /dbutton/src/index.js import Dbutton from './src/main'; // 给单独的组件添加install事件，便于按需注册 Dbutton.install = Vue =&gt;{ Vue.component(Dbutton.name, Dbutton); } export default Dbutton; /dbutton/src/install.js import Dbutton from './dbutton/index.js'; // 这里为组件数组，便于install方法循环 const commonComponnet = [ Dbutton ] // 注册全局install方法，这里的install会循环遍历component,给vue实例注册全局组件 const install = function (Vue, options = {}) { commonComponnet.forEach(component =&gt; { Vue.component(component.name, component) }) } // 导出对象，对象属性为各组件，以及install方法 export default { install, Dbutton } 3) main.js使用 全局引入。这里使用use不仅会调用全局的install(),也会调用各组件的install(),但是没有影响。vue.use()已经给我们做了处理，相同组件只允许注册一次。 import HavikerUI from './components/install'; Vue.use(HavikerUI); 局部引入。这样的话就只会调用Dbutton的install(). import HavikerUI from './components/install'; const { install, Dbutton } = HavikerUI; Vue.use(Dbutton); 项目使用 项目上所使用的组件分为两种，全局组件和局部组件。局部组件在对应页面import后使用即可，全局组件去掉/dbutton/src/index.js，修改/dbutton/src/install.js的引入，改为import Dbutton from './src/main'; 即可。 ","link":"https://hviker.github.io/post/ru-he-feng-zhuang-quan-ju-zu-jian-bing-qie-bei-vueuseplugin-shi-yong/"},{"title":"vue强制跳转","content":"url相同、参数不同。强制跳转刷新 跳转方法 wlb(){ this.$router.push({ path: '/zxxx/index', query: { index: '1' } }) }, wkc(){ this.$router.push({ path: '/zxxx/index', query: { index: '0'} }) }, 当在path为'/zxxx/index'页面，点击wlb()、wkc() 方法时是不走vue生命周期函数的。需要监听$route变化。 '$route'(to, from) { let { index } = to.query; this.activeName = index === '1' ? 'second' : 'first' this.handleClick({index: index}) } ","link":"https://hviker.github.io/post/vue-qiang-zhi-tiao-zhuan/"},{"title":"arguments使用","content":"以类数组对象的形式存储函数实参。 1、作用: 获取实参。 arguments.callee()方法返回当前方法，可以用于递归。 let organizeArr = [ { id: '01', name: 'xiaoming', children: [ { id: '0101', name: 'xiaoming1', children: [ { id: '010101', name: 'xiaoming2', children: [] } ] }, { id: '0102', name: 'xiaoming3', children: [ { id: '010201', name: 'xiaoming4', children: [] } ] } ] } ] function printName(arr) { console.log(arguements); arr.forEach(item =&gt; { console.log(item.name); if(item.children &amp;&amp; Array.isArray(item.children)) { // 这里递归 arguments.callee(item.children) } }); } printName(organizeArr); 2、转变成数组方法:toArray() /** * 取自vue2.0源码 将一个类数组对象转化成数组 * Convert an Array-like object to a real Array. */ function toArray (list, start) { start = start || 0; var i = list.length - start; var ret = new Array(i); while (i--) { ret[i] = list[i + start]; } return ret } ","link":"https://hviker.github.io/post/arguments-shi-yong/"},{"title":"el-table表格合并","content":"1、实现效果 2、代码实现 &lt;el-table :data=&quot;basePerformanceInfoTable&quot; border style=&quot;width: 100%&quot; :span-method=&quot;objectSpanMethod&quot; &gt; &lt;el-table-column prop=&quot;variety&quot; label=&quot;品种&quot; width=&quot;150&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;shape&quot; label=&quot;形状&quot; width=&quot;80&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;deliveryState&quot; label=&quot;交货状态&quot; width=&quot;150&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;specification&quot; label=&quot;规格&quot; width=&quot;100&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;详情&quot; class=&quot;remarkInfo&quot; &gt; &lt;template slot-scope=&quot;{row}&quot;&gt; &lt;ul class=&quot;remarkTableInfo clearfix&quot;&gt; &lt;li :title=&quot;row.performanceKey&quot;&gt;{{ row.performanceKey }}&lt;/li&gt; &lt;li :title=&quot;row.performanceValue&quot;&gt;{{ row.performanceValue }}&lt;/li&gt; &lt;li :title=&quot;row.remarkTitle&quot;&gt;{{ row.remarkTitle }}&lt;/li&gt; &lt;li :title=&quot;row.remark&quot;&gt;{{ row.remark }}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; // 材料搜索详情 export const MainInfo = { data() { return { previousItem: null, // 循环的上一个元素 spanArr: [], //用于存放每一行记录的合并数 pos: 0, // spanArr的索引 basePerformanceInfoTable: [ // 基本力学性能table数据 { variety: &quot;06Ni9DR-板(5~30)&quot;, shape: &quot;板&quot;, deliveryState: &quot;淬火+回火&quot;, specification: &quot;5~30&quot;, performanceKey: &quot;ReL(MPa)&quot;, performanceValue: &quot;≥560&quot;, remarkTitle: &quot;说明&quot;, remark: &quot;屈服不明显时，采用Rp0.2&quot;, }, { variety: &quot;06Ni9DR-板(5~30)&quot;, shape: &quot;板&quot;, deliveryState: &quot;淬火+回火&quot;, specification: &quot;5~30&quot;, performanceKey: &quot;Rm(MPa)&quot;, performanceValue: &quot;680~820&quot;, remarkTitle: &quot;说明&quot;, remark: &quot;&quot;, }, { variety: &quot;06Ni9DR-板(5~30)&quot;, shape: &quot;板&quot;, deliveryState: &quot;淬火+回火&quot;, specification: &quot;5~30&quot;, performanceKey: &quot;A(%)&quot;, performanceValue: &quot;≥18&quot;, remarkTitle: &quot;说明&quot;, remark: &quot;&quot;, }, { variety: &quot;06Ni9DR-板(&gt;30~50)&quot;, shape: &quot;板&quot;, deliveryState: &quot;淬火+回火&quot;, specification: &quot;&gt;30~50&quot;, performanceKey: &quot;ReL(MPa)&quot;, performanceValue: &quot;≥550&quot;, remarkTitle: &quot;说明&quot;, remark: &quot;屈服不明显时，采用Rp0.2&quot;, }, { variety: &quot;06Ni9DR-板(&gt;30~50)&quot;, shape: &quot;板&quot;, deliveryState: &quot;淬火+回火&quot;, specification: &quot;5~30&quot;, performanceKey: &quot;Rm(MPa)&quot;, performanceValue: &quot;680~820&quot;, remarkTitle: &quot;说明&quot;, remark: &quot;&quot;, }, ], }; }, methods: { // 合并数组 getSpanArr(data) { data.forEach((item, index) =&gt; { if (index === 0) { this.spanArr.push(1); this.pos = 0; } else { // 判断当前元素是否与上一个元素相同,根据合并字段匹配 if (item.variety == this.previousItem.variety) { this.spanArr[this.pos] += 1; this.spanArr.push(0); } else { this.spanArr.push(1); this.pos = index; } } this.previousItem = item; }); }, // 表格合并方法 objectSpanMethod({ row, column, rowIndex, columnIndex }) { if (columnIndex !== 4) { let _row = this.spanArr[rowIndex]; let _col = _row &gt; 0 ? 1 : 0; return { rowspan: _row, colspan: _col, }; } }, }, created() { this.getSpanArr(this.basePerformanceInfoTable); } } ","link":"https://hviker.github.io/post/el-table-biao-ge-he-bing/"},{"title":"高级搜索实现","content":"1、实现效果 页面初始化效果 单选选中效果 全部选择效果 取消选中(点击各查询条件或者已选条件的叉号) 2、代码实现 主页面方法 &lt;template&gt; &lt;div class=&quot;pageContainer&quot;&gt; &lt;div class=&quot;superSearchArea&quot; v-show=&quot;!searchMoreFlag&quot;&gt; &lt;div class=&quot;clearfix&quot; v-for=&quot;renderItem in renderEntity&quot; :key=&quot;renderItem.entityType&quot; &gt; &lt;div :class=&quot;renderItem.isSelectTypeNameClass ? 'selectTitle selectTitleSpace fl': 'selectTitle fl'&quot;&gt;{{ renderItem.selectTypeName }}&lt;/div&gt; &lt;div class=&quot;selectType&quot;&gt; &lt;div :class=&quot;submitReadySelectObj[renderItem.entityType].length === renderItem.entityList.length ? 'selectAll fl selectAllActive': 'selectAll fl '&quot; @click=&quot;handleAllSelect(renderItem.entityType)&quot; &gt; {{ renderItem.allSelectName }} &lt;/div&gt; &lt;div v-for=&quot;item in renderItem.entityList&quot; :key=&quot;item.key&quot; @click=&quot;handleSelectType(item.type, item.key, item.value, item.id, renderItem.entityType)&quot; :class=&quot;item.isSelect ? 'selectItem selectActive' : 'selectItem'&quot; &gt; {{ item.value }} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 已选条件 --&gt; &lt;div class=&quot;clearfix&quot;&gt; &lt;div class=&quot;selectTitle fl&quot;&gt;已选条件&lt;/div&gt; &lt;ul class=&quot;readySelectType fl clearfix&quot;&gt; &lt;li v-for=&quot;item in allReadySelectArr&quot; :key=&quot;item.key&quot; &gt; &lt;span class=&quot;fl&quot;&gt;{{ item.text }}&lt;/span&gt;&lt;label class=&quot;fr&quot; @click=&quot;delReadySelectItem(item.key, item.list, item.id)&quot; &gt;X&lt;/label&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 化学成分,力学性能,关键字搜素 --&gt; &lt;select-component :keyWords=&quot;keyWords&quot; :materialArr=&quot;materialArr&quot; :dynamicsArr=&quot;dynamicsArr&quot; @changeKeyWords=&quot;changeKeyWords&quot; ref=&quot;selectComponent&quot; &gt;&lt;/select-component&gt; &lt;!-- 搜素及清空条件 --&gt; &lt;div class=&quot;searchBtnArea&quot;&gt; &lt;div class=&quot;clearInfo fr&quot; @click=&quot;clearSelectInfo&quot; &gt; &lt;img src=&quot;@/assets/mainPage/clearinfo.png&quot; alt=&quot;clearinfo&quot; /&gt; 清空条件 &lt;/div&gt; &lt;div class=&quot;searchBtn&quot;&gt; &lt;el-button type=&quot;danger&quot; @click=&quot;searchInfo&quot; &gt;搜索&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 底部表格 --&gt; &lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot; &gt; &lt;el-table-column label=&quot;牌号&quot;&gt; &lt;template slot-scope=&quot;{row}&quot;&gt; &lt;span @click=&quot;handleGoInfo('gcss', row.steelNum)&quot; class=&quot;handGoInfo&quot; &gt; {{ row.steelNum }} &lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;applyStandard&quot; label=&quot;适用标准&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;system&quot; label=&quot;体系&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;steelNum&quot; label=&quot;牌号&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;dataSource&quot; label=&quot;数据来源&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;materialType&quot; label=&quot;材料类别&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;配送信息&quot;&gt; &lt;el-table-column prop=&quot;C&quot; label=&quot;C&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;Si&quot; label=&quot;Si&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;Mn&quot; label=&quot;Mn&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;P&quot; label=&quot;P&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;S&quot; label=&quot;S&quot; &gt; &lt;/el-table-column&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;力学性能&quot;&gt; &lt;el-table-column prop=&quot;YS&quot; label=&quot;YS&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;Rm&quot; label=&quot;Rm&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;Akv&quot; label=&quot;Akv&quot; &gt; &lt;/el-table-column&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 分页插件 --&gt; &lt;pagination v-show=&quot;total &gt; 0&quot; :total=&quot;total&quot; :page.sync=&quot;listQuery.page&quot; :limit.sync=&quot;listQuery.limit&quot; @pagination=&quot;getList&quot; /&gt; &lt;/div&gt; &lt;/template&gt;value &lt;script&gt; import { SelectType } from &quot;@/mixins/shycss/selectType&quot;; export default { name: &quot;Gcss&quot;, components: {}, mixins: [SelectType], props: { searchMoreFlag: { type: Boolean, default: false, }, }, data() { return { matchRelation: { // list 与 type对应关系， 主要是用于type对应 steelTypeList: &quot;SteelTypeList&quot;, shapeTypeList: &quot;ShapeTypeList&quot;, productCategoryTypeList: &quot;ProductCategoryTypeList&quot;, deliveryStateTypeList: &quot;DeliveryStateTypeList&quot;, standardTypeList: &quot;StandardTypeList&quot;, }, submitReadySelectObj: { // 查询条件提交数组，放在对象中方便提交 steelTypeList: [], // 钢类 shapeTypeList: [], // 形状 productCategoryTypeList: [], // 产品类别 deliveryStateTypeList: [], // 交货状态 standardTypeList: [], // 标准体系 }, steelTypeList: [ // 钢类数组，type: 类别， id: 后台返回唯一键， value: 显示名称 key: 前端唯一键(这里使用v-for循环，且存在多个查询条件，为避免前端v-for在指定key时报错重复，这里组合前端唯一键，使用type_id的形式，如果确定id唯一可删除，isSelect: 选中状态) { type: &quot;SteelTypeList&quot;, id: &quot;g01&quot;, value: &quot;碳素结构钢&quot;, key: &quot;SteelTypeList_g01&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g02&quot;, value: &quot;低合金高强度钢&quot;, key: &quot;SteelTypeList_g02&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g03&quot;, value: &quot;合金结构钢&quot;, key: &quot;SteelTypeList_g03&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g04&quot;, value: &quot;不锈钢&quot;, key: &quot;SteelTypeList_g04&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g05&quot;, value: &quot;易切削钢&quot;, key: &quot;SteelTypeList_g05&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g06&quot;, value: &quot;弹簧钢&quot;, key: &quot;SteelTypeList_g06&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g07&quot;, value: &quot;耐热钢&quot;, key: &quot;SteelTypeList_g07&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g08&quot;, value: &quot;工模具钢&quot;, key: &quot;SteelTypeList_g08&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g09&quot;, value: &quot;轴承钢&quot;, key: &quot;SteelTypeList_g09&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g10&quot;, value: &quot;弹簧钢&quot;, key: &quot;SteelTypeList_g10&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g11&quot;, value: &quot;铸钢铸铁&quot;, key: &quot;SteelTypeList_g11&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g12&quot;, value: &quot;耐候钢&quot;, key: &quot;SteelTypeList_g12&quot;, isSelect: false, }, ], shapeTypeList: [ // 形状数组 { type: &quot;ShapeTypeList&quot;, id: &quot;xz01&quot;, value: &quot;板&quot;, key: &quot;ShapeTypeList_xz01&quot;, isSelect: false, }, { type: &quot;ShapeTypeList&quot;, id: &quot;xz02&quot;, value: &quot;带&quot;, key: &quot;ShapeTypeList_xz02&quot;, isSelect: false, }, { type: &quot;ShapeTypeList&quot;, id: &quot;xz03&quot;, value: &quot;薄带&quot;, key: &quot;ShapeTypeList_xz03&quot;, isSelect: false, }, { type: &quot;ShapeTypeList&quot;, id: &quot;xz04&quot;, value: &quot;棒&quot;, key: &quot;ShapeTypeList_xz04&quot;, isSelect: false, }, { type: &quot;ShapeTypeList&quot;, id: &quot;xz05&quot;, value: &quot;线&quot;, key: &quot;ShapeTypeList_xz05&quot;, isSelect: false, }, ], productCategoryTypeList: [ // 产品类别 { type: &quot;ProductCategoryTypeList&quot;, id: &quot;cplb01&quot;, value: &quot;热轧钢&quot;, key: &quot;ProductCategoryTypeList_cplb01&quot;, isSelect: false, }, { type: &quot;ProductCategoryTypeList&quot;, id: &quot;cplb02&quot;, value: &quot;冷轧钢&quot;, key: &quot;ProductCategoryTypeList_cplb02&quot;, isSelect: false, }, { type: &quot;ProductCategoryTypeList&quot;, id: &quot;cplb03&quot;, value: &quot;无缝管&quot;, key: &quot;ProductCategoryTypeList_cplb03&quot;, isSelect: false, }, { type: &quot;ProductCategoryTypeList&quot;, id: &quot;cplb04&quot;, value: &quot;焊管&quot;, key: &quot;ProductCategoryTypeList_cplb04&quot;, isSelect: false, }, { type: &quot;ProductCategoryTypeList&quot;, id: &quot;cplb05&quot;, value: &quot;铸造管&quot;, key: &quot;ProductCategoryTypeList_cplb05&quot;, isSelect: false, }, ], deliveryStateTypeList: [ // 交货状态 { type: &quot;DeliveryStateTypeList&quot;, id: &quot;jhzt01&quot;, value: &quot;热轧&quot;, key: &quot;DeliveryStateTypeList_jhzt01&quot;, isSelect: false, }, { type: &quot;DeliveryStateTypeList&quot;, id: &quot;jhzt02&quot;, value: &quot;冷轧&quot;, key: &quot;DeliveryStateTypeList_jhzt02&quot;, isSelect: false, }, { type: &quot;DeliveryStateTypeList&quot;, id: &quot;jhzt03&quot;, value: &quot;热加工&quot;, key: &quot;DeliveryStateTypeList_jhzt03&quot;, isSelect: false, }, { type: &quot;DeliveryStateTypeList&quot;, id: &quot;jhzt04&quot;, value: &quot;冷加工&quot;, key: &quot;DeliveryStateTypeList_jhzt04&quot;, isSelect: false, }, ], standardTypeList: [ // 标准体系 { type: &quot;StandardTypeList&quot;, id: &quot;bztx01&quot;, value: &quot;所有企业标准&quot;, key: &quot;StandardTypeList_bztx01&quot;, isSelect: false, }, { type: &quot;StandardTypeList&quot;, id: &quot;bztx02&quot;, value: &quot;中国(GB)&quot;, key: &quot;StandardTypeList_bztx02&quot;, isSelect: false, }, { type: &quot;StandardTypeList&quot;, id: &quot;bztx03&quot;, value: &quot;日本(JIS)&quot;, key: &quot;StandardTypeList_bztx03&quot;, isSelect: false, }, { type: &quot;StandardTypeList&quot;, id: &quot;bztx04&quot;, value: &quot;美国(ASTM)&quot;, key: &quot;StandardTypeList_bztx04&quot;, isSelect: false, }, ], allReadySelectArr: [], // 所有选中数组，显示使用 tableData: [ { steelNum: &quot;06Ni1DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni2DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni3DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni4DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni5DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni6DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni7DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni8DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, ], materialArr: [ // 化学性能 { key: &quot;C&quot;, value: &quot;C&quot; }, { key: &quot;Si&quot;, value: &quot;Si&quot; }, { key: &quot;Mr&quot;, value: &quot;Mr&quot; }, { key: &quot;P&quot;, value: &quot;P&quot; }, { key: &quot;S&quot;, value: &quot;S&quot; }, ], dynamicsArr: [ // 力学性能 { key: &quot;qfqd&quot;, value: &quot;屈服强度YS(MPa)&quot; }, { key: &quot;cjg&quot;, value: &quot;冲击功Akv(J)&quot; }, { key: &quot;cjwd&quot;, value: &quot;冲击温度(℃)&quot; }, { key: &quot;klqd&quot;, value: &quot;抗拉强度TS(MPa)&quot; }, { key: &quot;ysl&quot;, value: &quot;延伸率A(%)&quot; }, ], }; }, watch: { // searchMoreFlag(newVal) { // console.log(&quot;flag&quot; + newVal); // }, }, computed: {}, methods: { // 清空搜素条件 clearSelectInfo() { // submitReadySelectObj数据清空 this.submitReadySelectObj = { // 查询条件提交数组 steelTypeList: [], // 钢类 shapeTypeList: [], // 形状 productCategoryTypeList: [], // 产品类别 deliveryStateTypeList: [], // 交货状态 standardTypeList: [], // 标准体系 }; // 将数据中的isSelect置为false this.steelTypeList = [...this.resetIsSelect(this.steelTypeList)]; this.shapeTypeList = [...this.resetIsSelect(this.shapeTypeList)]; this.productCategoryTypeList = [ ...this.resetIsSelect(this.productCategoryTypeList), ]; this.deliveryStateTypeList = [ ...this.resetIsSelect(this.deliveryStateTypeList), ]; this.standardTypeList = [...this.resetIsSelect(this.standardTypeList)]; // allReadySelectArr清空 this.allReadySelectArr = []; // selectComponent数据清空 this.$refs.selectComponent.clearSelectInfo(); }, // 搜索 searchInfo() { // 获取selectComponent中的查询内容 let selectComponentInfo = this.$refs.selectComponent.getSelectInfo(); // todo 这里需要组合其他查询条件进行请求数据 this.searchData(); }, // 查询数据 searchData() {}, }, created() {}, mounted() { // 修改数据格式，渲染实体 this.renderEntity = [ { selectTypeName: &quot;钢类&quot;, allSelectName: &quot;全部&quot;, isSelectTypeNameClass: true, entityType: &quot;steelTypeList&quot;, entityList: this.steelTypeList, }, { selectTypeName: &quot;形状&quot;, allSelectName: &quot;全部&quot;, isSelectTypeNameClass: false, entityType: &quot;shapeTypeList&quot;, entityList: this.shapeTypeList, }, { selectTypeName: &quot;产品类别&quot;, allSelectName: &quot;全部&quot;, isSelectTypeNameClass: false, entityType: &quot;productCategoryTypeList&quot;, entityList: this.productCategoryTypeList, }, { selectTypeName: &quot;交货状态&quot;, allSelectName: &quot;全部&quot;, isSelectTypeNameClass: false, entityType: &quot;deliveryStateTypeList&quot;, entityList: this.deliveryStateTypeList, }, { selectTypeName: &quot;标准体系&quot;, allSelectName: &quot;所有国际及行业标准&quot;, isSelectTypeNameClass: false, entityType: &quot;standardTypeList&quot;, entityList: this.standardTypeList, }, ]; }, }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; &lt;/style&gt; 复用方法 import SelectComponent from '@/views/shycss/component/selectComponent_index'; import Pagination from &quot;@/components/Pagination/Pagination_index&quot;; export const SelectType = { components: { SelectComponent, Pagination }, props: { searchMoreFlag: { type: Boolean, }, keyWords: { type: String } }, data() { return { allReadySelectArr: [], // 所有选中数组，显示使用 renderEntity: [], // 渲染实体 total: 8, // 数据总条数 listQuery: { page: 1, // 当前页 limit: 20, // 每页条数 } } }, methods: { // 分页查询方法 getList(obj) { this.listQuery.page = obj.page; this.listQuery.limit = obj.limit; this.searchData(); }, // 修改关键字 changeKeyWords(val) { this.$emit(&quot;changeKeyWords&quot;, val) }, // 将数组中的isSelect置为false resetIsSelect(arr) { arr.forEach(item =&gt; { item.isSelect = false; }) return arr; }, // 查询条件 handleSelectType(type, key, text, id, list) { this[list].some((item) =&gt; { if (item.key == key) { this.changeSelectItemState(item.isSelect, key, type, id, list, text); item.isSelect = !item.isSelect; return true; } }); }, // 根据查询条件当前选中状态动态新增/删除显示选中数组和提交显示数组中的数据 // 如果原来是选中状态，则点击后为非选中状态，需要在所有选中数组中删除 // 如果原来是非选中状态，则点击后为选中状态，需要在所有选中数组中添加 changeSelectItemState(isSelect, key, type, id, list, text) { if (isSelect) { // 删除已选数组中的数组 this.delFromAllReadyArr(key); // 删除提交数组中的数据 this.delFromSubmitReadySelectArr(list, id); } else { // 新增已选显示数组中的数据 this.addToAllReadyArr(key, text, list, id); // 新增提交数组中的数据 this.addToSubmitReadySelectArr(type, id, text, list); } }, // 添加到显示选中数组 addToAllReadyArr(key, text, list, id) { this.allReadySelectArr.push({ key: key, text: text, list: list, id: id }); }, // 添加到提交选中数组中 addToSubmitReadySelectArr(type, id, text, list) { let obj = { key: id, value: text, type: type }; this.submitReadySelectObj[list].push(obj); }, // 从显示选中数组中删除 delFromAllReadyArr(key) { let flag = false; let index = 0; this.allReadySelectArr.some((item) =&gt; { if (item.key == key) { flag = true; return true; } index++; }); flag &amp;&amp; this.allReadySelectArr.splice(index, 1); }, // 删除提交数组中的数据 delFromSubmitReadySelectArr(list, id) { let flag = false, index = 0; this.submitReadySelectObj[list].some((item) =&gt; { if (item.key == id) { flag = true; return true; } index++; }); flag &amp;&amp; this.submitReadySelectObj[list].splice(index, 1); }, // 删除所选选项 delReadySelectItem(key, list, id) { // 删除显示选中数组中的对应数据 this.delFromAllReadyArr(key); // 删除提交选中数组中的对应数据 this.delFromSubmitReadySelectArr(list, id); // 取消查询条件的选中样式 this.cancelIsSelect(this[list], key); // 查询数据 this.searchData(); }, // 取消查询条件选中状态 cancelIsSelect(arr, key) { arr.some((item) =&gt; { if (item.key == key) { item.isSelect = false; return true; } }); }, // 点击全部按钮 handleAllSelect(list) { // 判断提交选中数组中的个数是否等于list数组的个数 // 如果是则删除显示数组中所有该类型数据，提交数组置空,然后将所有该类型数据select置为false // 如果否则说明存在所有或部分数据未被选中，这时候删除显示数组中所有该类型数据，并新增数据；提交选中数组中将该类型所有数据填充，然后将所有该类型数据select置为true if (!this.submitReadySelectObj[list] || !this.matchRelation[list]) return; // 循环删除显示数组中所有该类型数据 this.delSpecTypeFromAllReadySelelctArr(list); if (this.submitReadySelectObj[list].length === this[list].length) { // 提交数组置空 this.submitReadySelectObj[list] = []; this[list].forEach((item) =&gt; { // 将所有选项改为非选中状态 item.isSelect = false; }); } else { // 提交数组置空 this.submitReadySelectObj[list] = []; this[list].forEach((item) =&gt; { // push到显示选中数组的对象 let obj1 = { key: item.key, text: item.value, list: list, id: item.id, }; // push到提交选中数组的对象 let obj2 = { key: item.id, value: item.value, type: this.matchRelation[list], }; this.allReadySelectArr.push(obj1); this.submitReadySelectObj[list].push(obj2); // 将所有选项改为选中状态 item.isSelect = true; }); } this.searchData(); }, // 循环删除显示数组中所有该类型数据 delSpecTypeFromAllReadySelelctArr(list) { for (let i = this.allReadySelectArr.length - 1; i &gt;= 0; i--) { if (this.allReadySelectArr[i].list == list) { this.allReadySelectArr.splice(i, 1); } } }, // 跳转详情 handleGoInfo(type, steelName) { switch(type) { case &quot;gcss&quot;: this.$router.push({ path: '/shycss/gcssMainInfo', query: { name: steelName } }) break; case &quot;yshjsu&quot;: this.$router.push({ path: '/shycss/yshjssMainInfo', query: { name: steelName } }) break; case &quot;hcss&quot;: this.$router.push({ path: '/shycss/hcssMainInfo', query: { name: steelName } }) break; } } } } ","link":"https://hviker.github.io/post/gao-ji-sou-suo-shi-xian/"},{"title":"防抖-监听浏览器窗口变化","content":"addListenerResize: function() { var self = this; window.addEventListener('resize', self.resizeDebounce(self.testFunc, 1000), false) }, resizeDebounce: function(func, wait) { let timeout = null; return function() { if(timeout) clearInterval(timeout); timeout = setTimeout(function(){ func.apply(this, arguments); }, wait) } }, testFunc:function(){ console.log(1) } echarts示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;财务与资产管理&lt;/title&gt; &lt;style&gt; html, body { width: 100%; height: 400px; } .container { width: 100%; height: 400px; } .echartsView { width: 15%; height: 400px; float: left; } p { margin: 0; padding: 0; } .tootTipCircle { display: inline-block; width: 10px; height: 10px; border-radius: 5px; } .tootTipInsideText { margin-left: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;app1&quot; class=&quot;echartsView&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app2&quot; class=&quot;echartsView&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app3&quot; class=&quot;echartsView&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app4&quot; class=&quot;echartsView&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app5&quot; class=&quot;echartsView&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app6&quot; class=&quot;echartsView&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;../lib/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/echart/echarts.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../js/echartsColor.js&quot;&gt;&lt;/script&gt; &lt;script&gt; (function () { $(document).ready(function () { echartsEntity.init(); echartsEntity.addListenerResize(); }) var echarts1 = echarts.init(document.getElementById(&quot;app1&quot;)) var echarts2 = echarts.init(document.getElementById(&quot;app2&quot;)) var echarts3 = echarts.init(document.getElementById(&quot;app3&quot;)) var echarts4 = echarts.init(document.getElementById(&quot;app4&quot;)) var echarts5 = echarts.init(document.getElementById(&quot;app5&quot;)) var echarts6 = echarts.init(document.getElementById(&quot;app6&quot;)) var echartsEntity = { init: function () { var self = this; var echarts1Data = { category: ['1月', '2月', '3月', '4月', '5月'], barData: [260, 280, 300, 180, 400] } this.drawEcharts(echarts1, echarts1Data, true, true); this.drawEcharts(echarts2, echarts1Data, false, false); this.drawEcharts(echarts3, echarts1Data, false, true); this.drawEcharts(echarts4, echarts1Data, false, false); this.drawEcharts(echarts5, echarts1Data, false, true); this.drawEcharts(echarts6, echarts1Data, false, true); echarts.connect([echarts1, echarts2, echarts3, echarts4, echarts5, echarts6]); }, // 绘制柱状图, echarts实例, echarts数据, 是否显示纵坐标(true显示， false不显示), 颜色配置(true绿色渐变, false蓝色渐变) drawEcharts: function (echartsDom, echartsData, yAxisViewflag, colorViewFlag) { var self = this; var category = echartsData.category; // 横轴 var barData = echartsData.barData; // 柱状图数据 var yAxisLabel = yAxisViewflag ? { formatter: '{value} ', color: echartsColor.yAxis.axisLabel.color } : { show: false }; var linearGradientColor = colorViewFlag ? [{ offset: 0, color: '#44D3D2' }, { offset: 1, color: '#0A315F' }] : [{ offset: 0, color: '#00B7F6' }, { offset: 1, color: '#022D63' }] var options = { backgroundColor: echartsColor.backgroundColor, legend: { show: false, }, tooltip: { trigger: 'axis', backgroundColor: echartsColor.tooltip.backgroundColor, borderWidth: 1, borderColor: echartsColor.tooltip.borderColor, textStyle: { color: echartsColor.tooltip.textStyle.color, fontSize: 12, lineHeight: 14 }, padding: [5, 10], axisPointer: { type: 'shadow', label: { show: true, backgroundColor: echartsColor.tooltip.axisPointer.label.backgroundColor } }, formatter: function (params) { var str = &quot;&quot;; params.forEach(function (item, index) { if (item.seriesType == 'bar') { str += '&lt;p class=&quot;tootTipText&quot;&gt;&lt;label class=&quot;tootTipCircle&quot; style=&quot;background-color: ' + item.color.colorStops[0].color + '&quot;&gt;&lt;/label&gt;' + ' ' + item.seriesName + ':' + item.value + '&lt;/p&gt;'; } }) return str; } }, grid: { left: '15%', right: '5%' }, xAxis: { show: false, type: 'value' }, yAxis: { type: 'category', inverse: true, axisLabel: yAxisLabel, splitLine: { show: false }, axisTick: { show: false }, axisLine: { show: false }, data: category }, series: [ { name: '', type: 'bar', barWidth: 10, label: { show: false }, itemStyle: { normal: { barBorderRadius: 5, color: new echarts.graphic.LinearGradient( 1, 1, 0, 0, linearGradientColor ) } }, data: barData }, { // 分隔 type: &quot;pictorialBar&quot;, itemStyle: { normal: { color: &quot;#124970&quot; } }, symbolRepeat: &quot;fixed&quot;, symbolMargin: -1, symbolRotate: 45, symbol: &quot;rect&quot;, symbolClip: true, symbolSize: [13, 1], symbolPosition: &quot;start&quot;, data: barData, z: 10, animationEasing: &quot;elasticOut&quot; }, ] }; echartsDom.setOption(options, true) }, addListenerResize: function () { var self = this; window.addEventListener('resize', self.resizeDebounce(self.ecahrtsResizeFunc, 500), false) }, resizeDebounce: function (func, wait) { let timeout = null; return function () { if (timeout) clearInterval(timeout); timeout = setTimeout(function () { func.apply(this, arguments); }, wait) } }, ecahrtsResizeFunc: function () { echarts1.resize(); echarts2.resize(); echarts3.resize(); echarts4.resize(); echarts5.resize(); echarts6.resize(); } } })(); &lt;/script&gt; &lt;/html&gt; ","link":"https://hviker.github.io/post/fang-dou-jian-ting-liu-lan-qi-chuang-kou-bian-hua/"},{"title":"使用vuex监听Layout的滚动，实现子组件指定页面的懒加载","content":"1、描述 整个.main-container分为三部分, 面包屑、内容显示区域、底部。现在 中部分页面需要监听滚动条的高度，当触及底部时需要像后台发起请求。这里采用监听vuex变量的方式，当 的滚动条触及底部时，变量+1，指定页面监听到变量发生变化就发起请求。考虑到下拉时存在多次请求的情况，这里做了防抖处理，只有myTestDataAntiShake为true时可以请求。刚触及底部时myTestDataAntiShake设置为false，只有请求响应后才设置为true。 2、使用 页面 &lt;!-- 右侧内容区域 --&gt; &lt;div :class=&quot;{hasTagsView:needTagsView}&quot; class=&quot;main-container&quot; @click=&quot;closeSiderBar&quot; ref=&quot;mainContainer&quot;&gt; &lt;div :class=&quot;{'fixed-header':fixedHeader}&quot;&gt; &lt;!-- --&gt; &lt;navbar /&gt; &lt;tags-view v-if=&quot;needTagsView&quot; /&gt; &lt;/div&gt; &lt;app-main /&gt; &lt;div class=&quot;mbFooter&quot; v-if=&quot;innerFooterFiewFlag &amp;&amp; device != 'mobile'&quot;&gt;&lt;main-footer /&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; js // 监听滚动条变化 addEventListerByMainContainer() { // 如果不是手机端，直接退出 if(this.$store.getters.device != 'mobile') return; let self = this; const myTestDataTop = 50； // 顶部面包屑 let dom = this.$refs.mainContainer; dom.addEventListener('scroll', () =&gt; { let routerPath = this.$route.path; if(self.fixdRouterPath.indexOf(routerPath) === -1) return; let scrollHeight = dom.scrollHeight, // 滚动页面高度 scrollTop = dom.scrollTop, // 滚动条距离顶部位置 clientHeight = dom.clientHeight; // 显示区域大小 if(scrollTop &gt; myTestDataTop) { switch (routerPath) { case &quot;/testDetectionMobile/myTestData/myTestDataTable&quot;: // 试验检测列表，用于固定头部显示区域 self.$store.dispatch(&quot;mobilescroll/setIsFixMytestData&quot;, true); break; case &quot;/dataUpdate/myUploadDataMobile&quot;: // 试验结果列表，用于固定头部显示区域 self.$store.dispatch(&quot;mobilescroll/setIsFixMyUploadData&quot;, true); break; } } else { switch (routerPath) { case &quot;/testDetectionMobile/myTestData/myTestDataTable&quot;: // 试验检测列表 self.$store.dispatch(&quot;mobilescroll/setIsFixMytestData&quot;, false); break; case &quot;/dataUpdate/myUploadDataMobile&quot;: // 试验结果 self.$store.dispatch(&quot;mobilescroll/setIsFixMyUploadData&quot;, false); break; } } // 当滑倒底部时， if(scrollTop + clientHeight - scrollHeight &gt;= 0) { switch (routerPath) { case &quot;/testDetectionMobile/myTestData/myTestDataTable&quot;: // 试验检测列表 if(!self.myTestDataAntiShake) return; // 这里做下防抖，上次数据请求回来后才能再次触发 self.$store.dispatch(&quot;mobilescroll/setMyTestDataAntiShake&quot;, false); let myTestDataRefresh = self.$store.getters.myTestDataRefresh; // 页面会监听myTestDataRefresh的变化，发生变化时发起请求 self.$store.dispatch(&quot;mobilescroll/setMyTestDataRefresh&quot;, myTestDataRefresh + 1); break; case &quot;/dataUpdate/myUploadDataMobile&quot;: // 试验结果 if(!self.myUploadDataAntiShake) return; self.$store.dispatch(&quot;mobilescroll/setMyUploadDataAntiShake&quot;, false); let myUploadDataRefresh = self.$store.getters.myUploadDataRefresh; self.$store.dispatch(&quot;mobilescroll/setMyUploadDataRefresh&quot;, myUploadDataRefresh + 1); break; } } }) } ","link":"https://hviker.github.io/post/shi-yong-vuex-jian-ting-layout-de-gun-dong-shi-xian-zi-zu-jian-zhi-ding-ye-mian-de-lan-jia-zai/"},{"title":"解决vue-element-admin三级菜单显示","content":"二级component修改：component: { render(c) { return c('router-view') } }, { path: '/testDetectionMobile', component: Layout, redirect: '/testDetectionDashboard/index', // 用于面包屑跳转 // alwaysShow: true, // will always show the root menu name: 'testDetectionMobile', meta: { title: 'testDetection', icon: 'reportFirst' }, children: [ { path: 'sampleId', component: () =&gt; import('@/views/testDetectionMobile/sampleId/sampleId_index'), name: 'sampleIdMobile', meta: { title: 'sampleId', icon: 'report', affix: true } }, { path: 'myTestData/myTestDataTable', component: () =&gt; import('@/views/testDetectionMobile/myTestData/myTestData_index'), name: 'myTestDataTableMobile', meta: { title: 'myTestData', icon: 'report', affix: true }, }, { path: 'myTestData/dataSource', component: () =&gt; import('@/views/testDetectionMobile/myTestData/dataSource_index'), name: 'dataSourceMobile', meta: { title: 'dataSource', icon: 'report', affix: true }, hidden: true }, { path: 'myTestData/myTestDataModify', component: () =&gt; import('@/views/testDetectionMobile/myTestData/myTestDataModify_index'), name: 'myTestDataModify', meta: { title: 'myTestDataModify', icon: 'report', affix: true }, hidden: true }, { path: 'steelNky', component: () =&gt; import('@/views/testDetection/steelNky/steelNky_index'), name: 'steelNkyMobile', meta: { title: 'steelNky', icon: 'report', affix: true } }, { path: '/dataUpdate', component: { render(c) { return c('router-view') } }, redirect: '/dataUpdate/offlineDataUpload', // 用于面包屑跳转 // alwaysShow: true, // will always show the root menu name: 'dataUpdate', meta: { title: 'dataUpdate', icon: 'report', roles: ['DataUpload', 'SystemAdmin'] }, children: [ { path: 'offlineDataUpload', component: () =&gt; import('@/views/dataUpdate/offlineDataUpload/offlineDataUpload_index'), name: 'offlineDataUpload', meta: { title: 'offlineDataUpload', icon: 'rightarrow', affix: true, roles: ['DataUpload', 'SystemAdmin'] } }, { path: 'myUploadDataMobile', component: () =&gt; import('@/views/dataUpdate/myUploadData/myUploadDataMobile_index'), name: 'myUploadDataMobile', meta: { title: 'myUploadData', icon: 'rightarrow', affix: true, roles: ['DataUpload', 'SystemAdmin'] } } ] }, ] }, ","link":"https://hviker.github.io/post/jie-jue-vue-element-admin-san-ji-cai-dan-xian-shi/"},{"title":"检测移动端软键盘回车进行查询","content":"兼容安卓和ios,type需要改为search,需要form嵌套，这样可以保证ios的回车显示搜索。 &lt;form @submit.prevent=&quot;formSubmit&quot; action=&quot;javascript:return true&quot;&gt; &lt;input class=&quot;mbSearchInput submitInput&quot; placeholder=&quot;请输入任务ID号或任务名称&quot; @keydown=&quot;testDataSearchKeyDown&quot; type=&quot;search&quot; v-model=&quot;TaskName&quot; /&gt; &lt;/form&gt; formSubmit() { return false; }, testDataSearchKeyDown(e){ console.log(e.keyCode) if(e.keyCode == '13') { this.testDataSearchClick(); } }, ","link":"https://hviker.github.io/post/jian-ce-yi-dong-duan-ruan-jian-pan-hui-che-jin-xing-cha-xun/"},{"title":"检测屏幕宽度","content":"const { body } = document； let bodyWidth = body.getBoundingClientRect(); 获取当前屏幕临界点 const { body } = document const WIDTH = 992 // refer to Bootstrap's responsive design function getIsMobile() { const rect = body.getBoundingClientRect() return rect.width - 1 &lt; WIDTH } ","link":"https://hviker.github.io/post/jian-ce-ping-mu-kuan-du/"},{"title":"JS封装组件模板(借助JQuery)","content":"(function (factory) { if(typeof module === 'object' &amp;&amp; typeof module.exports === 'object') { factory(require('jquery'), window, document); } else { factory(jQuery, window, document); } })(function ($, window, document) { var OrganizePart = function(ele, opts) { this.$ele = $(ele); this.opts = opts; this.defaultConfig = {} }; OrganizePart.prototype = { init: function() { var _this = this; _this.$options = $.extend({}, _this.defaultConfig, _this.opts); } }; $.fn.OrganizePart = function(opts) { return new OrganizePart(this, opts).init(); } }) 使用 $(function() { $(&quot;#pageContainer&quot;).OrganizePart({ // &quot;data&quot;: dataSource, }) }) ","link":"https://hviker.github.io/post/js-feng-zhuang-zu-jian-mo-ban-jie-zhu-jquery/"},{"title":"vue视频播放-vue-video-player","content":"1、描述 Vue版本: Vue2.0 Vue-cli版本：Vue-cli4.0 2、使用 下载 npm install vue-video-player -S 引入 ​ 全局引入 main.js引入 import VideoPlayer from 'vue-video-player' import 'vue-video-player/src/custom-theme.css' import 'video.js/dist/video-js.css' ​ 页面引入 在单页面引入 import { VideoPlayer } from 'vue-video-player' import 'vue-video-player/src/custom-theme.css' import 'video.js/dist/video-js.css' 组件使用（播放一般视频格式只需要修改type和src） &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;div class=&quot;demo&quot;&gt; &lt;video-player class=&quot;video-player vjs-custom-skin&quot; ref=&quot;videoPlayer&quot; :playsinline=&quot;true&quot; :options=&quot;playerOptions&quot;&gt; &lt;/video-player&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Home', components: { }, data() { return { playerOptions: { playbackRates: [0.5, 1.0, 1.5, 2.0], // 可选的播放速度 autoplay: false, // 如果为true,浏览器准备好时开始回放。 muted: false, // 默认情况下将会消除任何音频。 loop: false, // 是否视频一结束就重新开始。 preload: 'auto', // 建议浏览器在&lt;video&gt;加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持） language: 'zh-CN', aspectRatio: '16:9', // 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如&quot;16:9&quot;或&quot;4:3&quot;） fluid: true, // 当true时，Video.js player将拥有流体大小。换句话说，它将按比例缩放以适应其容器。 sources: [{ type: &quot;video/mp4&quot;, // 类型, src: &quot;&quot;, // 视频地址 // src: 'https://cdn.letv-cdn.com/2018/12/05/JOCeEEUuoteFrjCg/playlist.m3u8' // url地址 // src: 'http://192.168.2.59:8088/vod/tky/org/20201228/091707_829/091707_829.mp4.m3u8' // src: '/vod/tky/org/20201228/091707_829/091707_829.mp4.m3u8' }], poster: '', // 封面地址 notSupportedMessage: '此视频暂无法播放，请稍后再试', // 允许覆盖Video.js无法播放媒体源时显示的默认信息。 controlBar: { timeDivider: true, // 当前时间和持续时间的分隔符 durationDisplay: true, // 显示持续时间 remainingTimeDisplay: false, // 是否显示剩余时间功能 fullscreenToggle: true // 是否显示全屏按钮 } } } } } &lt;/script&gt; &lt;style lang=&quot;scss&quot; scope&gt; .demo { width: 500px; height: 400px; } &lt;/style&gt; 3、播放m3u8视频流 安装videojs-contrib-hls npm install videojs-contrib-hls -S 使用 import引入后type改为 application/x-mpegURL &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;div class=&quot;demo&quot;&gt; &lt;video-player class=&quot;video-player vjs-custom-skin&quot; ref=&quot;videoPlayer&quot; :playsinline=&quot;true&quot; :options=&quot;playerOptions&quot;&gt; &lt;/video-player&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import 'videojs-contrib-hls' export default { name: 'Home', components: { HelloWorld }, data() { return { playerOptions: { playbackRates: [0.5, 1.0, 1.5, 2.0], // 可选的播放速度 autoplay: false, // 如果为true,浏览器准备好时开始回放。 muted: false, // 默认情况下将会消除任何音频。 loop: false, // 是否视频一结束就重新开始。 preload: 'auto', // 建议浏览器在&lt;video&gt;加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持） language: 'zh-CN', aspectRatio: '16:9', // 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如&quot;16:9&quot;或&quot;4:3&quot;） fluid: true, // 当true时，Video.js player将拥有流体大小。换句话说，它将按比例缩放以适应其容器。 sources: [{ type: &quot;application/x-mpegURL&quot;, // 类型 // src: 'https://cdn.letv-cdn.com/2018/12/05/JOCeEEUuoteFrjCg/playlist.m3u8' // url地址 // src: 'http://192.168.2.59:8088/vod/tky/org/20201228/091707_829/091707_829.mp4.m3u8' src: '/vod/tky/org/20201228/091707_829/091707_829.mp4.m3u8' }], poster: '', // 封面地址 notSupportedMessage: '此视频暂无法播放，请稍后再试', // 允许覆盖Video.js无法播放媒体源时显示的默认信息。 controlBar: { timeDivider: true, // 当前时间和持续时间的分隔符 durationDisplay: true, // 显示持续时间 remainingTimeDisplay: false, // 是否显示剩余时间功能 fullscreenToggle: true // 是否显示全屏按钮 } } } } } &lt;/script&gt; &lt;style lang=&quot;scss&quot; scope&gt; .demo { width: 500px; height: 400px; } &lt;/style&gt; 开发环境出现跨域的情况，需要在vue.config.js做处理 proxy: { '/vod': { target: 'http://192.168.2.59:8088/', ws: false, changeOrigin: true, pathRewrite: { ['^' + '/vod']: '/vod' } } } ","link":"https://hviker.github.io/post/vue-shi-pin-bo-fang-vue-video-player/"},{"title":"echarts部分用法","content":"1、下载图片 (1) 使用组件下载 toolbox: { feature: { saveAsImage: {} } }, (2) 外部按钮下载 echarts的canvas版本，会将图表绘制成canvas。这时候可以调用外部方法下载指定区域的canvas图片。 js // 下载echarts图片 export function downloadEchartsImg(id) { let mycanvas = $(&quot;#&quot; + id).find(&quot;canvas&quot;)[0]; let image = mycanvas.toDataURL(&quot;image/png&quot;); let $a = document.createElement(&quot;a&quot;); $a.setAttribute(&quot;href&quot;, image); $a.setAttribute(&quot;download&quot;, &quot;&quot;); $a.click(); } 2、标题文字垂直显示 下载插件 echarts-better 相关代码 title: { text: echartsObj.nameStr, textStyle: { fontSize: 14, fontWeight: &quot;normal&quot;, fontFamily: &quot;SongTi&quot;, }, textAlign: &quot;left&quot;, top: &quot;60%&quot;, rotate: 90, }, 3、设置外部边框 grid: { show: true, borderColor: &quot;#000&quot;, borderWidth: 2, width: &quot;80%&quot;, left: &quot;7%&quot;, }, 4、内部网格线显示、隐藏 xAxis: { splitLine: { show: true | false, }, } 5、轴文本、轴刻度标在图内测、外侧显示 xAxis: { axisLabel: { inside: false, }, axisTick: { inside: true, } } 6、dataZoom dataZoom: [ { type: &quot;slider&quot;, xAxisIndex: 0, filterMode: &quot;empty&quot;, }, { type: &quot;slider&quot;, yAxisIndex: 0, filterMode: &quot;empty&quot;, }, { type: &quot;inside&quot;, xAxisIndex: 0, filterMode: &quot;empty&quot;, }, { type: &quot;inside&quot;, yAxisIndex: 0, filterMode: &quot;empty&quot;, }, ], 7、联动 可保证axisPointer、dataZoom等联动 var dom1 = echarts.init(document.getElementById(&quot;container3&quot;)); var options1 = this.getChartsOptions(); dom1.setOption(options1, true); var dom2 = echarts.init(document.getElementById(&quot;charts1&quot;)); var options2 = this.getChartsOptions(); dom2.setOption(options2, true); var dom3 = echarts.init(document.getElementById(&quot;charts2&quot;)); var options3 = this.getChartsOptions(); dom3.setOption(options3, true); // 联动 echarts.connect([dom1, dom2, dom3]) ###8、多图在单个canvas绘制时的联动情况 var arr = new Array(waveData.length + 2).fill(1).map(function (item, index) { return index; }); dataZoom: [ { type: 'inside', disabled: true, start: 0, end: 100 }, { show: false, xAxisIndex: arr, type: 'slider', top: 0, start: 0, end: 100 } ], axisPointer: { link: { xAxisIndex: arr }, show: true, type: 'line', axis: 'x', snap: true, label: { show: false } } ","link":"https://hviker.github.io/post/echarts-bu-fen-yong-fa/"},{"title":"培训-布局(H5、CSS)","content":"1、标签初始化 (1) 很多标签自带margin、padding。在使用前设置为0。不建议设置* (2) a 下划线去除 (3) li 去除左侧点 (4) i 去除斜体 (4) 添加清除浮动伪类 clearfix html,body,div,ul,li,h1,h2,h3,h4,h5,table,p,span,img,a,label,i { margin:0; padding:0; } a { text-decoration: none; } li { list-style: none; } i { font-style:normal } clearfix:after{ visibility: hidden; display: block; font-size: 0; content: &quot; &quot;; clear: both; height: 0; } 2、行、块元素 行元素: a，span, i, label, img, input... 块元素: div、table、h1-h6、p、ul、li... 表现形式: (1) 行元素不独占一行，不能设置宽高 (2) 块元素独占一行，能设置宽高 (3) 行内块元素不独占一行，但是可以设置宽高 行、块转换:display 变行: display:inline; 变块: display:block; 变行内块: display:inline-block; 3、居中 行标签: ​ 水平：text-align:center; ​ 垂直：line-height: 父元素高度； 块元素： ​ 水平：margin: 0px auto; ​ 垂直：(1) 定位position。已知块的宽和高，使用绝对定位 ​ (2) display:flex。 父元素添加display:flex; 子元素添加margin:auto。 4、定位 绝对定位：position:absolute。 绝对定位元素的未知相对于最近的已定位的父元素。如果元素没有已经定位的父元素，那么它的相对位置相对于 常用案例：块元素居中 { position:absolute; width:300px; height:300px; left:50%; top:50%; margin-left:-150px; margin-top: -150px; } 相对定位：position:relative。 正常文档流。相对于正常位置。 固定定位：position:fixed。 相对于浏览器窗口。浏览器中存在滚动条且发生滚动时，它不会移动。 常用案例：头部定位导航条、左下角留言板。 5、浮动 意义：脱离正常的文档流,摆脱了块级元素和行内元素的限制。 使用：float -&gt;left;/right; 影响：高度塌陷 当有浮动的子元素存在高度时，如果父元素没有设置浮动，此时子元素不会撑起父元素，父元素的高度消失。如果不清楚浮动，往后的dom元素也会存在高度上的影响。在这种情况下需要清除浮动。 清除：(1) 伪类(推荐) clearfix:after{ visibility: hidden; display: block; font-size: 0; content: &quot; &quot;; clear: both; height: 0; } (2) overflow:hidden; (3) 兼容IE6 zoom:1 6、浏览器页面前端自适应方案 (1) 常见概念： px：像素，屏幕上显示数据的最基本的点。width:100px； 屏幕分辨率: 1920*1080 -》宽度上1920个像素点，高度上1080个像素点。 rem：相对于根元素font-size的长度单位。 font-size:0.9rem; em：相对于父元素font-size的长度单位。font-size:0.9em; 几乎不用。 vw:视窗宽度，移动端。1wm = 视窗宽度的1%; vh：视窗高度，移动端。 1vh = 视窗高度的1%； (2) 方案 纯css - 百分比方案+媒体查询方案+rem(常用) 大布局用百分比，小调整用媒体查询,字体控制用rem。 对于较大的定位区域，比如整个页面、左侧菜单区域、右侧内容区域。 calc()在声明css属性时执行一些计算，用于计算不确定值。一般用calc() 去解决像素溢出问题。 html: &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;header&quot;&gt;头部&lt;/div&gt; &lt;div class=&quot;mainbody clearfix&quot;&gt; &lt;div class=&quot;sider&quot;&gt;左侧菜单区域&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;右侧内容区域&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; css: .container { width:100%; height:100% } .header { width:100%; height：60px; } .mainbody { width:100%; height:calc(100% - 60px) } .clearfix:after{ visibility: hidden; display: block; font-size: 0; content: &quot; &quot;; clear: both; height: 0; } .sider { float:left; width:200px; height:100%; } .content { float:right; width:calc(100% - 200px); height:100%; } 局部调整用媒体查询@media @media screen and (min-width:1600px) and (max-width:1920px){ } @media screen and (min-width:1367px) and (max-width:1599px){ } @media screen and (min-width:1091px) and (max-width:1366px){ } @media screen and (min-width:768px) and (max-width:1090px){ } 字体控制用rem 当页面调整时只需根据当前显示区域大小修改html的font-size。 借助js - rem方案(不推荐) js 动态修改html文字大小，在页面缩放时重新调整rem的大小。 对于页面的放大缩小实际是改变了可是区域的大小，也可以用@media去调整。 动态获取浏览器缩放比例的方法 function detectZoom() { var ratio = 0, screen = window.screen, ua = navigator.userAgent.toLowerCase(); if (window.devicePixelRatio !== undefined) { ratio = window.devicePixelRatio; } else if (~ua.indexOf('msie')) { if (screen.deviceXDPI &amp;&amp; screen.logicalXDPI) { ratio = screen.deviceXDPI / screen.logicalXDPI; } } else if (window.outerWidth !== undefined &amp;&amp; window.innerWidth !== undefined) { ratio = window.outerWidth / window.innerWidth; } if (ratio) { ratio = Math.round(ratio * 100); } return ratio; } 备注：设置宽度/高度百分比一定要保证父元素的宽度/高度有确定值(可以是百分比，可以是px等)。否则设置的百分比无效。 7、css优先级 (1) css具有继承性 应用在标签上的css会影响其子标签，但是子标签的直接样式优先级高于父标签样式。 (2) 样式优先级：内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器 属性选择器 input[type = &quot;text&quot;] { width:200px; height:30px; } 伪类选择器 input:first-child{ width:200px; height:30px; } 伪元素选择器 :before :after (3) css可覆盖，同级别、同路径下样式，后者覆盖前者。 主要用于样式覆盖。 (4) css样式嵌套层级越深，优先级越高。 .A .B .C &gt; .A .C 可用于换肤，菜单样式切换。 8、其他常用css (1) 单行文本溢出添加省略号 { overflow: hidden; text-overflow:ellipsis; white-space: nowrap; } (2) 多行文本溢出添加省略号 chrome实现方法：不兼容IE及其他浏览器 { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; } IE及其他浏览器实现方法： 使用插件clamps .js 插件下载地址：https://github.com/josephschmitt/Clamp.js 使用： // 引入 &lt;script src=&quot;js/Clamp.js-master/clamp.js&quot;&gt;&lt;/script&gt; // 样式 &lt;style&gt; .divarea { width: 300px; height: 84px; } p { width: 100%; } &lt;/style&gt; // html &lt;div class=&quot;divarea&quot;&gt; &lt;p&gt;这两个选择元素的API,ualCrew小组耗时两年翻译，保持与D3 V3最后一版（3.5.17）一致.D3 V4最新版API请参考d3.v4-API翻译&lt;/p&gt; &lt;/div&gt; // js &lt;script&gt; $(document).ready(function () { $clamp($(&quot;.divarea p&quot;)[0], { clamp: '3' }) }) &lt;/script&gt; (3) 三角形绘制 { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red; } ","link":"https://hviker.github.io/post/pei-xun-bu-ju-h5css/"},{"title":"echarts属性设置(完整版)","content":"全图默认背景 ** // backgroundColor: ‘rgba(0,0,0,0)’, ** 默认色板 color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed', '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0', '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700', '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'], 图表标题 title: { x: 'left', // 水平安放位置，默认为左对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ {number}（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ {number}（y坐标，单位px） //textAlign: null // 水平对齐方式，默认根据x设置自动调整 backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 标题边框颜色 borderWidth: 0, // 标题边框线宽，单位px，默认为0（无边框） padding: 5, // 标题内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 主副标题纵向间隔，单位px，默认为10， textStyle: { fontSize: 18, fontWeight: 'bolder', color: '#333' // 主标题文字颜色 }, subtextStyle: { color: '#aaa' // 副标题文字颜色 } }, 图例 legend: { orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' x: 'center', // 水平安放位置，默认为全图居中，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ {number}（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ {number}（y坐标，单位px） backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 图例边框颜色 borderWidth: 0, // 图例边框线宽，单位px，默认为0（无边框） padding: 5, // 图例内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 图例图形宽度 itemHeight: 14, // 图例图形高度 textStyle: { color: '#333' // 图例文字颜色 } }, 值域 dataRange: { orient: 'vertical', // 布局方式，默认为垂直布局，可选为： // 'horizontal' ¦ 'vertical' x: 'left', // 水平安放位置，默认为全图左对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ {number}（x坐标，单位px） y: 'bottom', // 垂直安放位置，默认为全图底部，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ {number}（y坐标，单位px） backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 值域边框颜色 borderWidth: 0, // 值域边框线宽，单位px，默认为0（无边框） padding: 5, // 值域内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 值域图形宽度，线性渐变水平布局宽度为该值 * 10 itemHeight: 14, // 值域图形高度，线性渐变垂直布局高度为该值 * 10 splitNumber: 5, // 分割段数，默认为5，为0时为线性渐变 color:['#1e90ff','#f0ffff'],//颜色 //text:['高','低'], // 文本，默认为数值文本 textStyle: { color: '#333' // 值域文字颜色 } }, toolbox: { orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' x: 'right', // 水平安放位置，默认为全图右对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ {number}（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ {number}（y坐标，单位px） color : ['#1e90ff','#22bb22','#4b0082','#d2691e'], backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色 borderColor: '#ccc', // 工具箱边框颜色 borderWidth: 0, // 工具箱边框线宽，单位px，默认为0（无边框） padding: 5, // 工具箱内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemSize: 16, // 工具箱图形宽度 featureImageIcon : {}, // 自定义图片icon featureTitle : { mark : '辅助线开关', markUndo : '删除辅助线', markClear : '清空辅助线', dataZoom : '区域缩放', dataZoomReset : '区域缩放后退', dataView : '数据视图', lineChart : '折线图切换', barChart : '柱形图切换', restore : '还原', saveAsImage : '保存为图片' } }, 提示框 tooltip: { trigger: 'item', // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis' showDelay: 20, // 显示延迟，添加显示延迟可以避免频繁切换，单位ms hideDelay: 100, // 隐藏延迟，单位ms transitionDuration : 0.4, // 动画变换时间，单位s backgroundColor: 'rgba(0,0,0,0.7)', // 提示背景颜色，默认为透明度为0.7的黑色 borderColor: '#333', // 提示边框颜色 borderRadius: 4, // 提示边框圆角，单位px，默认为4 borderWidth: 0, // 提示边框线宽，单位px，默认为0（无边框） padding: 5, // 提示内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : 'line', // 默认为直线，可选为：'line' | 'shadow' lineStyle : { // 直线指示器样式设置 color: '#48b', width: 2, type: 'solid' }, shadowStyle : { // 阴影指示器样式设置 width: 'auto', // 阴影大小 color: 'rgba(150,150,150,0.3)' // 阴影颜色 } }, textStyle: { color: '#fff' } }, ** 区域缩放控制器** dataZoom: { orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' // x: {number}, // 水平安放位置，默认为根据grid参数适配，可选为： // {number}（x坐标，单位px） // y: {number}, // 垂直安放位置，默认为根据grid参数适配，可选为： // {number}（y坐标，单位px） // width: {number}, // 指定宽度，横向布局时默认为根据grid参数适配 // height: {number}, // 指定高度，纵向布局时默认为根据grid参数适配 backgroundColor: 'rgba(0,0,0,0)', // 背景颜色 dataBackgroundColor: '#eee', // 数据背景颜色 fillerColor: 'rgba(144,197,237,0.2)', // 填充颜色 handleColor: 'rgba(70,130,180,0.8)' // 手柄颜色 }, ** 网格** grid: { x: 80, y: 60, x2: 80, y2: 60, // width: {totalWidth} - x - x2, // height: {totalHeight} - y - y2, backgroundColor: 'rgba(0,0,0,0)', borderWidth: 1, borderColor: '#ccc' }, 类目轴 categoryAxis: { position: 'bottom', // 位置 nameLocation: 'end', // 坐标轴名字位置，支持'start' | 'end' boundaryGap: true, // 类目起始和结束两端空白策略 axisLine: { // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle控制线条样式 color: '#48b', width: 2, type: 'solid' } }, axisTick: { // 坐标轴小标记 show: true, // 属性show控制显示与否，默认不显示 interval: 'auto', // onGap: null, inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: { // 属性lineStyle控制线条样式 color: '#333', width: 1 } }, axisLabel: { // 坐标轴文本标签，详见axis.axisLabel show: true, interval: 'auto', rotate: 0, margin: 8, // formatter: null, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, splitLine: { // 分隔线 show: true, // 默认显示，属性show控制显示与否 // onGap: null, lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式 color: ['#ccc'], width: 1, type: 'solid' } }, splitArea: { // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 // onGap: null, areaStyle: { // 属性areaStyle（详见areaStyle）控制区域样式 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] } } }, ** 数值型坐标轴默认参数** valueAxis: { position: 'left', // 位置 nameLocation: 'end', // 坐标轴名字位置，支持'start' | 'end' nameTextStyle: {}, // 坐标轴文字样式，默认取全局样式 boundaryGap: [0, 0], // 数值起始和结束两端空白策略 splitNumber: 5, // 分割段数，默认为5 axisLine: { // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle控制线条样式 color: '#48b', width: 2, type: 'solid' } }, axisTick: { // 坐标轴小标记 show: false, // 属性show控制显示与否，默认不显示 inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: { // 属性lineStyle控制线条样式 color: '#333', width: 1 } }, axisLabel: { // 坐标轴文本标签，详见axis.axisLabel show: true, rotate: 0, margin: 8, // formatter: null, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, splitLine: { // 分隔线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式 color: ['#ccc'], width: 1, type: 'solid' } }, splitArea: { // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 areaStyle: { // 属性areaStyle（详见areaStyle）控制区域样式 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] } } }, polar : { center : ['50%', '50%'], // 默认全局居中 radius : '75%', startAngle : 90, splitNumber : 5, name : { show: true, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, axisLine: { // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle控制线条样式 color: '#ccc', width: 1, type: 'solid' } }, axisLabel: { // 坐标轴文本标签，详见axis.axisLabel show: false, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, splitArea : { show : true, areaStyle : { color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] } }, splitLine : { show : true, lineStyle : { width : 1, color : '#ccc' } } }, ** 柱形图默认参数** bar: { barMinHeight: 0, // 最小高度改为0 // barWidth: null, // 默认自适应 barGap: '30%', // 柱间距离，默认为柱形宽度的30%，可设固定值 barCategoryGap : '20%', // 类目间柱形距离，默认为类目间距的20%，可设固定值 itemStyle: { normal: { // color: '各异', barBorderColor: '#fff', // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } }, emphasis: { // color: '各异', barBorderColor: 'rgba(0,0,0,0)', // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } } }, 折线图默认参数 line: { itemStyle: { normal: { // color: 各异, label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, lineStyle: { width: 2, type: 'solid', shadowColor : 'rgba(0,0,0,0)', //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 } }, emphasis: { // color: 各异, label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } }, //smooth : false, //symbol: null, // 拐点图形类型 symbolSize: 2, // 拐点图形大小 //symbolRotate : null, // 拐点图形旋转控制 showAllSymbol: false // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略） }, K线图默认参数 k: { // barWidth : null // 默认自适应 // barMaxWidth : null // 默认自适应 itemStyle: { normal: { color: '#fff', // 阳线填充颜色 color0: '#00aa11', // 阴线填充颜色 lineStyle: { width: 1, color: '#ff3200', // 阳线边框颜色 color0: '#00aa11' // 阴线边框颜色 } }, emphasis: { // color: 各异, // color0: 各异 } } }, 散点图默认参数 scatter: { //symbol: null, // 图形类型 symbolSize: 4, // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 图形旋转控制 large: false, // 大规模散点图 largeThreshold: 2000, // 大规模阀值，large为true且数据量&gt;largeThreshold才启用大规模模式 itemStyle: { normal: { // color: 各异, label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } }, emphasis: { // color: '各异' label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } } }, 雷达图默认参数 radar : { itemStyle: { normal: { // color: 各异, label: { show: false }, lineStyle: { width: 2, type: 'solid' } }, emphasis: { // color: 各异, label: { show: false } } }, //symbol: null, // 拐点图形类型 symbolSize: 2 // 可计算特性参数，空数据拖拽提示图形大小 //symbolRotate : null, // 图形旋转控制 }, 饼图默认参数 pie: { center : ['50%', '50%'], // 默认全局居中 radius : [0, '75%'], clockWise : false, // 默认逆时针 startAngle: 90, minAngle: 0, // 最小角度改为0 selectedOffset: 10, // 选中是扇区偏移量 itemStyle: { normal: { // color: 各异, borderColor: '#fff', borderWidth: 1, label: { show: true, position: 'outer' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, labelLine: { show: true, length: 20, lineStyle: { // color: 各异, width: 1, type: 'solid' } } }, emphasis: { // color: 各异, borderColor: 'rgba(0,0,0,0)', borderWidth: 1, label: { show: false // position: 'outer' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, labelLine: { show: false, length: 20, lineStyle: { // color: 各异, width: 1, type: 'solid' } } } } }, map: { mapType: 'china', // 各省的mapType暂时都用中文 mapLocation: { x : 'center', y : 'center' // width // 自适应 // height // 自适应 }, showLegendSymbol : true, // 显示图例颜色标识（系列标识的小圆点），存在legend时生效 itemStyle: { normal: { // color: 各异, borderColor: '#fff', borderWidth: 1, areaStyle: { color: '#ccc' //rgba(135,206,250,0.8) }, label: { show: false, textStyle: { color: 'rgba(139,69,19,1)' } } }, emphasis: { // 也是选中样式 // color: 各异, borderColor: 'rgba(0,0,0,0)', borderWidth: 1, areaStyle: { color: 'rgba(255,215,0,0.8)' }, label: { show: false, textStyle: { color: 'rgba(139,69,19,1)' } } } } }, force : { // 数据map到圆的半径的最小值和最大值 minRadius : 10, maxRadius : 20, density : 1.0, attractiveness : 1.0, // 初始化的随机大小位置 initSize : 300, // 向心力因子，越大向心力越大 centripetal : 1, // 冷却因子 coolDown : 0.99, // 分类里如果有样式会覆盖节点默认样式 itemStyle: { normal: { // color: 各异, label: { show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, nodeStyle : { brushType : 'both', color : '#f08c2e', strokeColor : '#5182ab' }, linkStyle : { strokeColor : '#5182ab' } }, emphasis: { // color: 各异, label: { show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, nodeStyle : {}, linkStyle : {} } } }, chord : { radius : ['65%', '75%'], center : ['50%', '50%'], padding : 2, sort : 'none', // can be 'none', 'ascending', 'descending' sortSub : 'none', // can be 'none', 'ascending', 'descending' startAngle : 90, clockWise : false, showScale : false, showScaleText : false, itemStyle : { normal : { label : { show : true // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, lineStyle : { width : 0, color : '#000' }, chordStyle : { lineStyle : { width : 1, color : '#666' } } }, emphasis : { lineStyle : { width : 0, color : '#000' }, chordStyle : { lineStyle : { width : 2, color : '#333' } } } } }, island: { r: 15, calculateStep: 0.1 // 滚轮可计算步长 0.1 = 10% }, markPoint : { symbol: 'pin', // 标注类型 symbolSize: 10, // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 标注旋转控制 itemStyle: { normal: { // color: 各异， // borderColor: 各异, // 标注边线颜色，优先于color borderWidth: 2, // 标注边线线宽，单位px，默认为1 label: { show: true, position: 'inside' // 可选为'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } }, emphasis: { // color: 各异 label: { show: true // position: 'inside' // 'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } } }, markLine : { // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string symbol: ['circle', 'arrow'], // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 symbolSize: [2, 4], // 标线起始和结束的symbol旋转控制 //symbolRotate : null, itemStyle: { normal: { // color: 各异, // 标线主色，线色，symbol主色 // borderColor: 随color, // 标线symbol边框颜色，优先于color borderWidth: 2, // 标线symbol边框线宽，单位px，默认为2 label: { show: false, // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom' position: 'inside', textStyle: { // 默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, lineStyle: { // color: 随borderColor, // 主色，线色，优先级高于borderColor和color // width: 随borderWidth, // 优先于borderWidth type: 'solid', shadowColor : 'rgba(0,0,0,0)', //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 } }, emphasis: { // color: 各异 label: { show: false // position: 'inside' // 'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, lineStyle : {} } } }, textStyle: { decoration: 'none', fontFamily: 'Arial, Verdana, sans-serif', fontFamily2: '微软雅黑', // IE8- 字体模糊并且不支持不同字体混排，额外指定一份 fontSize: 12, fontStyle: 'normal', fontWeight: 'normal' }, // 默认标志图形类型列表 symbolList : [ 'circle', 'rectangle', 'triangle', 'diamond', 'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond' ], loadingText : 'Loading...', // 可计算特性配置，孤岛，提示颜色 calculable: false, // 默认关闭可计算特性 calculableColor: 'rgba(255,165,0,0.6)', // 拖拽提示边框颜色 calculableHolderColor: '#ccc', // 可计算占位提示颜色 nameConnector: ' &amp; ', valueConnector: ' : ', animation: true, animationThreshold: 2500, // 动画元素阀值，产生的图形原素超过2500不出动画 addDataAnimation: true, // 动态数据接口是否开启动画效果 animationDuration: 2000, animationEasing: 'ExponentialOut' //BounceOut ","link":"https://hviker.github.io/post/echarts-shu-xing-she-zhi-wan-zheng-ban/"},{"title":"echarts二维数组绘制空点折线","content":"###1、需求描述 需要绘制多条折线，但是多条折线在某个或者某几个X点不存在Y值。 ###2、代码 initChart() { let chart = echarts.init(document.getElementById(&quot;echarts&quot;)) let option = { title: { text: &quot;Step Line&quot; }, tooltip: { trigger: &quot;axis&quot; }, legend: { data: [&quot;Step Start&quot;, &quot;Step Middle&quot;, &quot;Step End&quot;] }, grid: { left: &quot;3%&quot;, right: &quot;4%&quot;, bottom: &quot;3%&quot;, containLabel: true }, toolbox: { feature: { saveAsImage: {} } }, xAxis: { type: &quot;category&quot;, data: [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;] }, yAxis: { type: &quot;value&quot; }, series: [ { name: &quot;Step Start&quot;, type: &quot;line&quot;, step: &quot;start&quot;, // data: [120, 132, 101, 134, 90, 230, 210] data: [[&quot;Mon&quot;, 120], [&quot;Tue&quot;, 132], [&quot;Wed&quot;, 101], [&quot;Thu&quot;, 134], [&quot;Fri&quot;, 90], [&quot;Sat&quot;, 230], [&quot;Sun&quot;, 210]] }, { name: &quot;Step Middle&quot;, type: &quot;line&quot;, step: &quot;middle&quot;, data: [ [&quot;Wed&quot;, 134], [&quot;Fri&quot;, 90], [&quot;Sat&quot;, 230], [&quot;Sun&quot;, 210]] }, { name: &quot;Step End&quot;, type: &quot;line&quot;, step: &quot;end&quot;, data: [[&quot;Mon&quot;, 120], [&quot;Tue&quot;, 132], [&quot;Wed&quot;, 101], [&quot;Thu&quot;, 134], [&quot;Fri&quot;, 90], [&quot;Sun&quot;, 20]] } ] }; chart.setOption(option) } ","link":"https://hviker.github.io/post/echarts-er-wei-shu-zu-hui-zhi-kong-dian-zhe-xian/"},{"title":"echarts第二次绘制显示空白的解决方案","content":"1、描述 这是一个动态绘制echarts的弹窗子页面。 父页面有很多功能属性，在点击每个功能属性时进行弹窗，然后根据配置动态绘制各功能属性的echarts类型及数据展示。 第一次打开弹窗echarts正常显示，但是关闭后重新打开就显示空白。 echarts绘制的页面dom代码如下 &lt;div class=&quot;contentBody fl&quot;&gt; &lt;div class=&quot;echartsBody&quot; id=&quot;echartsBody&quot;&gt;&lt;/div&gt; &lt;/div&gt; 2、解决方案 首先，可以确定的是每次打开该弹窗代码能走通，从echarts数据传递到获取echarts绘制指定dom再到echarts.setOption(option, true);都没问题。 尝试过网上很多方法，有把setOption第二个参数设置成true的，有把div中_echarts_instance_属性删除的，但是都没有用。这边的做法是动态删除dom然后创建dom,dom渲染完成后再进行其他操作。 $(&quot;.contentBody&quot;) .find(&quot;.echartsBody&quot;) .remove() .end() .append( &quot;&lt;div class='echartsBody' id='echartsBody' style='height:440px'&gt;&lt;/div&gt;&quot; ); this.$nextTick(() =&gt; { ... }） ","link":"https://hviker.github.io/post/echarts-di-er-ci-hui-zhi-xian-shi-kong-bai-de-jie-jue-fang-an/"},{"title":"v-model动态绑定实例","content":"1、需求 页面样式 前后端传递的数据格式 2、描述 页面需要在该区域显示当前所有的化学成分，同时前后端传递的数据格式要求是object。 很无脑费力的一种方法是有N种化学元素，页面绘制N个元素、N*2个input框，然年后data中对应变量的Composition属性中定义N个max、N个min。有这种做法的人可以考虑把脑子扔掉了。且不说绘制及绑定有多麻烦，后期拓展也是问题。 第二种，循环遍历化学元素表，动态生成页面。在v-mode绑定属性值时进行动态拼接。例如下面的addMarkInfoForm.Composition[item.type + 'min']。这就提供给我们一个新思路，v-model的值是可以动态绑定的。 &lt;ul class=&quot;compositionList clearfix&quot;&gt; &lt;li v-for=&quot;item in tempChemicalElementList&quot; :key=&quot;item.key&quot; class=&quot;addmaterialInput&quot;&gt; &lt;span&gt;{{ item.value }}:&lt;/span&gt; &lt;el-input type=&quot;number&quot; v-model=&quot;addMarkInfoForm.Composition[item.type + 'min']&quot; placeholder=&quot;min&quot; /&gt;~ &lt;el-input type=&quot;number&quot; v-model=&quot;addMarkInfoForm.Composition[item.type + 'max']&quot; placeholder=&quot;max&quot; /&gt; &lt;/li&gt; &lt;/ul&gt; 同样，在可编辑动态表格(动态表头，可编辑)中，也可以使用v-model绑定动态列的prop &lt;el-table :data=&quot;tableData&quot; fit style=&quot;width: 100%;&quot;&gt; &lt;el-table-column label=&quot;序号&quot; align=&quot;center&quot; width=&quot;60&quot;&gt; &lt;template slot-scope=&quot;{ $index }&quot;&gt; {{ $index + 1 }} &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column v-for=&quot;item in tableLabel&quot; :key=&quot;item.prop&quot; :label=&quot;item.label&quot; align=&quot;center&quot; &gt; &lt;template slot-scope=&quot;{ row }&quot;&gt; &lt;el-input v-model=&quot;row[item.prop]&quot; placeholder=&quot;请输入&quot; clearable&gt;&lt;/el-input&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;检测结果&quot; width=&quot;90&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;{ row, $index}&quot;&gt; &lt;el-button size=&quot;mini&quot; type=&quot;danger&quot; @click=&quot;handleDelete(row,$index)&quot; icon=&quot;el-icon-delete&quot; title=&quot;删除&quot; &gt; &lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; ","link":"https://hviker.github.io/post/v-model-dong-tai-bang-ding-shi-li/"},{"title":"vue文件上传","content":"1、业务需求 可以控制文件上传数量、格式，支持图片、pdf的预览、下载、删除，支持其他文件格式的下载删除。 2、效果截图 3、组件代码 &lt;!-- --&gt; &lt;template&gt; &lt;div class=&quot;mainContainer&quot;&gt; &lt;el-form @submit.native.prevent&gt; &lt;el-upload class=&quot;upload-demo&quot; :action=&quot;apiPath&quot; :accept=&quot;acceptType&quot; :limit=&quot;fileLimit&quot; :file-list=&quot;fileList&quot; :http-request=&quot;handleUploadFile&quot; &gt; &lt;img src=&quot;@/assets/mainPage/uploadFile.png&quot; alt=&quot;uploadFile&quot; v-if=&quot;isChangeFiles&quot; /&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot; v-if=&quot;isChangeFiles&quot;&gt; 支持 {{ acceptType }} 格式，最多{{ fileLimit }}个 &lt;/div&gt; &lt;/el-upload&gt; &lt;ul class=&quot;uploadView clearfix&quot;&gt; &lt;li v-for=&quot;item in fileList&quot; :key=&quot;item.id&quot;&gt; &lt;div class=&quot;fileView&quot; :title=&quot;item.name&quot;&gt; &lt;img :src=&quot;getFileIconByName(item.name)&quot; /&gt; {{ item.name }} &lt;/div&gt; &lt;div class=&quot;uploadBtn&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;handleRemove(item.id)&quot; v-if=&quot;isChangeFiles&quot; &gt;删除&lt;/a &gt; &lt;a href=&quot;javascript:void(0)&quot; v-if=&quot;isHasViewFunc(item.name)&quot; @click=&quot;handleView(item.url)&quot; &gt;查看&lt;/a &gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;handleDownload(item.name, item.url)&quot; &gt;下载&lt;/a &gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- &lt;el-upload class=&quot;upload-demo&quot; :action=&quot;apiPath&quot; :on-preview=&quot;handlePreview&quot; :before-remove=&quot;beforeRemove&quot; :headers=&quot;headers&quot; :on-remove=&quot;handleRemove&quot; :accept=&quot;acceptType&quot; :before-upload=&quot;beforeUpload&quot; :limit=&quot;fileLimit&quot; :on-exceed=&quot;handleExceed&quot; :file-list=&quot;fileList&quot; :on-success=&quot;handleFileAdd&quot;&gt; &lt;img src=&quot;@/assets/mainPage/uploadFile.png&quot; alt=&quot;uploadFile&quot; /&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;支持 {{ acceptType }} 格式，最多{{ fileLimit }}个&lt;/div&gt; &lt;/el-upload&gt; --&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import axios from &quot;axios&quot;; import { downloadIamge, downFile } from &quot;@/utils&quot;; export default { components: {}, props: { isChangeFiles: { type: Boolean, default: true, }, fileLimit: { type: Number, }, bizType: { type: Number, }, offlineflag: { type: String, }, fileList: { type: Array, default: [], }, fileBelongId: { type: Number, }, acceptType: { type: String, default: &quot;.xlsx,.xls,.png,.jpeg,.jpg,.gif,.ppt,pptx,.doc,.docx,.zip,.rar,.txt,.bmp,.tif,.pdf,.avi,.mp4,.mov&quot;, // 默认文件类型 }, }, data() { return { // apiPath: &quot;/api/Attachment/UploadFile?bizType=&quot; + this.bizType, apiPath: &quot;&quot;, // headers: { &quot;AuthorizationToken&quot;: localStorage.getItem(&quot;token&quot;) }, httpRequestUrl: &quot;/api/Attachment/UploadFile?bizType=&quot; + this.bizType, }; }, computed: {}, watch: {}, methods: { // 上传文件 handleUploadFile(params) { let files = params.file; // 文件上传前处理 this.beforeUploadFunc(files); this.uploadFlieFunc(files); }, // 文件上传方法 uploadFlieFunc(files) { let self = this, formData = new FormData(); formData.append(&quot;file&quot;, files); try { axios .post(self.httpRequestUrl, formData, { headers: { AuthorizationToken: localStorage.getItem(&quot;token&quot;), &quot;Content-Type&quot;: &quot;multipart/form-data&quot;, }, }) .then((res) =&gt; { if (res.data &amp;&amp; res.data.returnData) { let response = res.data.returnData; let obj = { name: files.name, url: response.AttachmentPath, id: response.AttachmentID, }; if (!self.fileBelongId) { // 当文件存储位置不是数组对象时 self.$emit(&quot;AddAttachment&quot;, response.AttachmentID, obj); } else { // 当文件存储位置为数组对象时 self.$emit( &quot;AddAttachment&quot;, response.AttachmentID, obj, self.fileBelongId ); } } else { self.$message.error(&quot;文件保存失败&quot;); } }); } catch (e) { self.$message.error(&quot;文件保存失败&quot;); } }, // 文件上传成功时 // handleFileAdd(response, file, fileList) { // let self = this; // let obj = { name: file.name, url: response.returnData.AttachmentPath, id: response.returnData.AttachmentID } // if(!this.fileBelongId) { // // 当文件存储位置不是数组对象时 // self.$emit('AddAttachment', response.returnData.AttachmentID, obj); // } else { // // 当文件存储位置为数组对象时 // self.$emit(&quot;AddAttachment&quot;, response.returnData.AttachmentID, obj, this.fileBelongId); // } // }, // 文件删除 handleRemove(id) { this.$confirm(&quot;文件删除后无法恢复，确定要删除文件?&quot;, &quot;提示&quot;, { confirmButtonText: &quot;确定&quot;, cancelButtonText: &quot;取消&quot;, type: &quot;warning&quot;, }).then(() =&gt; { let file = { id: id }; if (!this.fileBelongId) { this.$emit(&quot;removeFile&quot;, file); } else { this.$emit(&quot;removeFile&quot;, file, this.fileBelongId); } }); }, // 文件上传前处理 beforeUploadFunc(files) { // 判断是否超过最大上传数量 if (this.fileList.length + 1 &gt; this.fileLimit) { this.$message.warning(&quot;已超过最大上传数量限制&quot;); return; } let fileName = files.name; // 获取文件类型 let typeArr = fileName.split(&quot;.&quot;); let type = typeArr[typeArr.length - 1]; if (this.acceptType != &quot;任意数据&quot;) { let standFileTypeArr = this.acceptType.split(&quot;,&quot;); // 判断是否符合上传文件类型 let arr = standFileTypeArr.filter((item) =&gt; item.substr(1) == type); if (arr.length == 0) { this.$message.error(`仅支持上传${this.acceptType}格式!`); return false; } } // let size = files.size; // if(size / 1024 / 1024 &gt; 10) { // this.$message.error('单个文件大小上限10M'); // return false; // } // 如果是图片，这里要对图片进行压缩 // if(type == &quot;png&quot; || type == &quot;jpeg&quot; || type == &quot;jpg&quot; ) { // this.compressPic(files) // } if (this.offlineflag == &quot;1&quot;) { this.$confirm(&quot;离线上传过程中不能关闭当前页面&quot;, &quot;提示&quot;, { confirmButtonText: &quot;确定&quot;, cancelButtonText: &quot;取消&quot;, type: &quot;warning&quot;, }).then(() =&gt; { let newpage = this.$router.resolve({ name: &quot;offlineDataUpload&quot;, }); window.open(newpage.href, &quot;_blank&quot;); }); } }, // 压缩图片 compressPic(file) {}, // 根据文件名称显示图标 getFileIconByName(fileName) { let iconType = fileName.split(&quot;.&quot;)[1]; let iconPic; switch (iconType) { case &quot;xlsx&quot;: case &quot;xls&quot;: iconPic = require(&quot;@/assets/mainPage/ico-xlsx.png&quot;); break; case &quot;png&quot;: case &quot;jpeg&quot;: case &quot;jpg&quot;: case &quot;gif&quot;: case &quot;tif&quot;: iconPic = require(&quot;@/assets/mainPage/ico-png.png&quot;); break; case &quot;ppt&quot;: case &quot;pptx&quot;: iconPic = require(&quot;@/assets/mainPage/ico-ppt.png&quot;); break; case &quot;doc&quot;: case &quot;docx&quot;: iconPic = require(&quot;@/assets/mainPage/ico-docx.png&quot;); break; case &quot;rar&quot;: case &quot;zip&quot;: iconPic = require(&quot;@/assets/mainPage/ico-zip.png&quot;); break; case &quot;txt&quot;: case &quot;bmp&quot;: iconPic = require(&quot;@/assets/mainPage/ico-txt.png&quot;); break; } return iconPic; }, // 是否显示查看按钮，仅当文件是图片或者ppt时可以查看 isHasViewFunc(fileName) { let flag = false; let iconType = fileName.split(&quot;.&quot;)[1]; if ( iconType == &quot;png&quot; || iconType == &quot;jpeg&quot; || iconType == &quot;jpg&quot; || iconType == &quot;gif&quot; || iconType == &quot;ppt&quot; || iconType == &quot;pptx&quot; ) { flag = true; } return flag; }, // 查看图片 handleView(url) { let baseUrl = process.env.VUE_APP_DOWNLOAD_IP + url; window.open(baseUrl, &quot;_blank&quot;); }, // 文件下载 handleDownload(name, url) { let iconType = name.split(&quot;.&quot;)[1]; let baseUrl = process.env.VUE_APP_DOWNLOAD_IP + url; if (iconType == &quot;png&quot; || iconType == &quot;jpeg&quot; || iconType == &quot;jpg&quot;) { downloadIamge(baseUrl, name); } else { downFile(baseUrl, name); } }, }, created() {}, mounted() {}, }; &lt;/script&gt; &lt;style lang='scss'&gt; .el-upload-list { display: none; } .uploadView { width: 100%; height: auto; li { width: 100%; float: left; padding: 0px 50px 0px 0px; div { float: left; } .fileView { width: calc(100% - 150px); height: 30px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .uploadBtn { padding-left: 15px; float: right; a { color: #5b6cea; text-decoration: underline; padding-left: 10px; } } } } .upload-demo { margin-bottom: 20px; } &lt;/style&gt; // 图片下载，只能在非跨域情况下使用 export function downloadIamge(imgsrc, name) {//下载图片地址和图片名 let image = new Image(); // 解决跨域 Canvas 污染问题 image.setAttribute(&quot;crossOrigin&quot;, &quot;anonymous&quot;); image.onload = function () { let canvas = document.createElement(&quot;canvas&quot;); canvas.width = image.width; canvas.height = image.height; let context = canvas.getContext(&quot;2d&quot;); context.drawImage(image, 0, 0, image.width, image.height); let url = canvas.toDataURL(&quot;image/png&quot;); //得到图片的base64编码数据 let a = document.createElement(&quot;a&quot;); // 生成一个a元素 let event = new MouseEvent(&quot;click&quot;); // 创建一个单击事件 a.download = name || &quot;photo&quot;; // 设置图片名称 a.href = url; // 将生成的URL设置为a.href属性 a.dispatchEvent(event); // 触发a的单击事件 }; image.src = imgsrc; } // 普通文件下载 export function downFile(imgsrc, name) { var a = document.createElement(&quot;a&quot;); a.download = name; a.href = imgsrc; a.target=&quot;_blank&quot;; document.body.appendChild(a); a.click(); document.body.removeChild(a); } 4、组件使用 &lt;upload-multiple :bizType=&quot;bizType&quot; :fileLimit=&quot;fileLimit&quot; ref=&quot;addProjectUpload&quot; :fileList=&quot;addProjectForm.FileList&quot; :isChangeFiles=&quot;isChangeFiles&quot; @AddAttachment=&quot;AddAttachment&quot; @removeFile=&quot;removeFile&quot; &gt;&lt;/upload-multiple&gt; import { deleteFile } from &quot;@/api/commonDoc&quot; import UploadMultiple from '@/components/UploadFileMultiple' // 多附件上传 export default { components: { UploadMultiple }, data() { return { bizType: 0, //区分文件上传模块 fileLimit： 20， // 文件上传最大上限 addProjectForm: { FileList: [] ,// 展示数组 FileAttachmentList: [], // 参数上传数组 }， isChangeFiles: true , // 是否需要新增、修改文件，控制内部按钮显示。true是 false否 } }, methods: { // 保存文件 AddAttachment(attachmentId, obj) { this.addProjectForm.FileAttachmentList.push({ AttachmentID: attachmentId }); // 这里根据后台要求拼装数据格式 this.addProjectForm.FileList.push(obj); this.addProjectForm = JSON.parse(JSON.stringify(this.addProjectForm)); // 做一次深拷贝，防止对象数据监听不到变化 }, // 文件删除 removeFile(file) { let id = file.id; let obj = { id: id }; deleteFile(obj).then(res =&gt; { if (res.returnData) { let index1 = 0; this.addProjectForm.FileAttachmentList.some(res =&gt; { if (res.AttachmentID == id) { this.addProjectForm.FileAttachmentList.splice(index1, 1) return true; } index1++; }) let index2 = 0 this.addProjectForm.FileList.some(res =&gt; { if (res.id == id) { this.addProjectForm.FileList.splice(index2, 1); return true; } index2++; }) this.$message({ type: &quot;success&quot;, message: &quot;删除成功&quot; }) return; } else { this.$message({ type: &quot;error&quot;, message: &quot;删除失败&quot; }) return; } }) } } } // 文件删除方法 export function deleteFile(id) { return request({ url: &quot;/Attachment/DeleteFile&quot;, method: 'get', params: id }) } 5、备注 图标: ","link":"https://hviker.github.io/post/element-ui-zu-jian-zheng-li/"},{"title":"vue仿tab实现","content":"1、应用场景 单页面存在多个tab，其中多个tab中都存在大量的数据请求。普通的tab在首页面展示时会对所有tab的数据进行请求，浪费资源，引起页面卡顿。使用该tab可以有效解决单页面数据请求与数据渲染问题，利用 在tab切换时只需要根据id动态修改currentTabComponent的值,也可以往组件中传值。 2、效果截图 3、代码实现 &lt;!-- 首页 --&gt; &lt;template&gt; &lt;div class=&quot;mainContainer&quot;&gt; &lt;div class=&quot;tabArea&quot;&gt; &lt;div class=&quot;overFlowTabArea&quot;&gt; &lt;el-button v-for=&quot;item in tabType&quot; :key=&quot;item.id&quot; @click=&quot;handleTab(item.id)&quot; :class=&quot;{ isActive: item.id == activeTab }&quot; &gt;{{ item.name }}&lt;/el-button &gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mainTabInfo&quot;&gt; &lt;component :is=&quot;currentTabComponent&quot; :tabArr=&quot;tabArr&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import AllDynamicRoute from &quot;@/views/steelResearchCompute/cloudCompute/dynamicRoute/AllDynamicRoute_index&quot;; // 全部菜单 import FirstPrinciples from &quot;@/views/steelResearchCompute/cloudCompute/dynamicRoute/FirstPrinciples_index&quot;; // xxx import CALPHAD from &quot;@/views/steelResearchCompute/cloudCompute/dynamicRoute/CALPHAD_index&quot;; //xxx import Spread from &quot;@/views/steelResearchCompute/cloudCompute/dynamicRoute/Spread_index&quot;; // xxx import Multiphase from &quot;@/views/steelResearchCompute/cloudCompute/dynamicRoute/Multiphase_index&quot;; // xxx export default { components: { AllDynamicRoute, FirstPrinciples, CALPHAD, Spread, Precipitation, Multiphase, Limited, Fluid, Coupling, Other, }, data() { return { computeMenuData: [], // 云计算菜单数据 tabType: [ // 仿Tab 按钮资源 ], activeTab: &quot;FirstPrinciples&quot;, // 激活状态下的tab currentTabComponent: FirstPrinciples, // 激活状态下tab对应的数据信息 tabArr: [ // 当前tab显示数据 ], allDynamicRouteArr: [ // 所有的三级菜单 ], }; }, computed: {}, watch: {}, methods: { // 点击按钮切换菜单 handleTab(id) { this.activeTab = id; switch (id) { case &quot;AllDynamicRoute&quot;: this.currentTabComponent = AllDynamicRoute; break; case &quot;FirstPrinciples&quot;: this.currentTabComponent = FirstPrinciples; break; case &quot;CALPHAD&quot;: this.currentTabComponent = CALPHAD; break; case &quot;Multiphase&quot;: this.currentTabComponent = Multiphase; break; case &quot;Spread&quot;: this.currentTabComponent = Spread; break; case &quot;MyComputeTask&quot;: this.$router.push(&quot;/steelResearchCompute/myComputeTask&quot;); return; break; } this.getTabArr(id); }, // 获取当前tab的二级菜单 getTabArr(id) { if (id == &quot;AllDynamicRoute&quot;) { this.tabArr = JSON.parse(JSON.stringify(this.allDynamicRouteArr)); } else { let arr = []; this.computeMenuData.some((item) =&gt; { if (item.category == id) { let categoryList = item.categoryList; // tab对应的二级菜单 categoryList.forEach((item1) =&gt; { // InstructionMode : 1 指令模式，2 图形模式 let routerPath = item1.InstructionMode == &quot;2&quot; ? &quot;/steelResearchCompute/cloudCompute&quot; : &quot;/steelResearchCompute/instructionModeCompute&quot;; arr.push({ id: item1.ID, name: item1.ChineseName, secondName: item1.ChineseName, picLocal: process.env.VUE_APP_DOWNLOAD_IP + item1.SoftAlgorithmCoverIcon, routerPath: routerPath, }); }); return true; } }); this.tabArr = arr; } }, // 初始化 init() { // 钢研云计算所有动态的二级菜单 let computeMenuData = this.$store.getters.computeMenuData; this.computeMenuData = computeMenuData; this.tabType = [{ id: &quot;AllDynamicRoute&quot;, name: &quot;全部&quot; }]; if (computeMenuData.length &gt; 0) { computeMenuData.forEach((item) =&gt; { this.tabType.push({ id: item.category, name: item.categoryText }); // 获取所有的三级菜单 item.categoryList.forEach((item1) =&gt; { let routerPath = item1.InstructionMode == &quot;2&quot; ? &quot;/steelResearchCompute/cloudCompute&quot; : &quot;/steelResearchCompute/instructionModeCompute&quot;; this.allDynamicRouteArr.push({ id: item1.ID, name: item1.ChineseName, secondName: item1.ChineseName, picLocal: process.env.VUE_APP_DOWNLOAD_IP + item1.SoftAlgorithmCoverIcon, routerPath: routerPath, }); }); }); // 添加我的计算任务tab this.tabType.push({ id: &quot;MyComputeTask&quot;, name: &quot;我的计算任务&quot; }) this.handleTab(&quot;AllDynamicRoute&quot;); } }, }, created() { this.init(); }, mounted() {}, }; &lt;/script&gt; &lt;style lang='scss'&gt; // 仿Tab 按钮样式 .mainContainer { padding: 0px; .overFlowTabArea { width: auto; height: 100%; } .tabArea .overFlowTabArea &gt; .el-button--medium { padding: 10px; border-radius: 2px; margin-left: 2px; } } &lt;/style&gt; ","link":"https://hviker.github.io/post/vue-fang-tab-shi-xian/"},{"title":"vue二级树(只能选择一级节点下的一项或者多项)","content":"1、业务要求 树结构有两级，由大类和小类组成。 当大类中不存在大类时，只能选择大类；当大类中存在小类时，只能选择大类中的小类。 当切换大类或者非选中大类中的小类时，清空原有选择数据。 2、效果展示 3、组件代码 &lt;!-- 树形结构 --&gt; &lt;template&gt; &lt;el-dialog :visible.sync=&quot;testTypeTreeViewFlag&quot; width=&quot;55%&quot; :append-to-body=&quot;true&quot; class=&quot;mainContainer&quot; &gt; &lt;div class=&quot;projectTitle&quot;&gt;请选择检测项目&lt;/div&gt; &lt;el-input placeholder=&quot;输入关键字进行过滤&quot; v-model=&quot;filterText&quot; clearable&gt;&lt;/el-input&gt; &lt;el-tree :data=&quot;treeData&quot; :props=&quot;treeProp&quot; show-checkbox node-key=&quot;id&quot; ref=&quot;testTypetree&quot; highlight-current class=&quot;testTypeTree&quot; :filter-node-method=&quot;filterNode&quot; :check-on-click-node=true :accordion=true @check=&quot;getCheckData&quot; &gt;&lt;/el-tree&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;confirmTestTypeSelect&quot;&gt;确认选择&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;closeTestTypeTreeView&quot;&gt;关闭&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;TestTypeTree&quot;, components: {}, props: { testTypeTreeViewFlag: { type: Boolean, required: true, }, treeData: { type: Array, default: [], }, }, data() { return { itemIndex: 0, // 数组中的第几项 filterText: &quot;&quot;, // 关键字过滤 checkedNodeArr: [], // 选中的检测项目数组 treeProp: { // 树形结构解析树形 children: &quot;children&quot;, label: &quot;label&quot;, }, accordion: true, // 是否一级一级展开 }; }, computed: {}, watch: { // 实时监听过滤关键字 filterText(val) { this.$refs.testTypetree.filter(val); }, }, methods: { // 关闭检测信息弹窗 closeTestTypeTreeView() { this.$emit(&quot;closeTestTypeTreeView&quot;); }, // 关键字过滤 filterNode(value, data) { if (!value) return true; return data.label.indexOf(value) !== -1; }, // 确认选择 confirmTestTypeSelect() { if (this.checkedNodeArr.length === 0) { this.$message({ type: &quot;warning&quot;, message: &quot;请选择检测项目&quot;, }); return; } // 当只存在二级菜单时，this.checkedNodeArr中缺少所对应的一级菜单 // 由于显示数据需要拼接，当数据中只存在二级菜单需要查找一级菜单一并返回 // 判断是否存在一级菜单，不存在则flag为false，存在则flag为true let flag = false; this.checkedNodeArr.some((item) =&gt; { if (item.parentId == &quot;#&quot;) { flag = true; return true; } }); if (!flag) { // 当不存在时，获取对应的一级菜单数据,组合后一并发给主页面 let arr = []; let firstItemId = this.checkedNodeArr[0].parentId; this.treeData.some((item) =&gt; { if (item.id == firstItemId) { arr.push(item); return true; } }); arr = [...arr, ...this.checkedNodeArr]; this.$emit(&quot;confirmTestTypeSelect&quot;, arr, this.itemIndex, flag); } else { this.$emit( &quot;confirmTestTypeSelect&quot;, this.checkedNodeArr, this.itemIndex, flag ); } }, // getCheckData(data, node) { // console.log(this.$refs.testTypetree.store) // 选中节点自动展开 // 判断点击的是一级节点还是二级节点 let firstItemId = data.parentId == &quot;#&quot; ? data.id : data.parentId; // 判断当前是选中还是取消选中 let checkedNodes = node.checkedNodes; let arr = []; checkedNodes.forEach((item) =&gt; { if (item.id == firstItemId || item.parentId == firstItemId) { arr.push(item); } }); this.checkedNodeArr = arr; if (arr.length &gt; 0) { this.$refs.testTypetree.setCheckedNodes(arr); } }, // 获取treeData 数据 getTreeData(index, selectTreeId) { this.itemIndex = index; if (selectTreeId) { this.$refs.testTypetree.setCheckedKeys(selectTreeId); } }, }, created() {}, mounted() {}, }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; .projectTitle { width: 100%; height: 40px; line-height: 40px; background-color: #7ee697; font-size: 1rem; padding-left: 20px; padding-right: 20px; font-weight: bolder; margin-bottom: 25px; color: #000000; } .testTypeTree { max-height: 500px; overflow: auto; margin-top: 15px; } &lt;/style&gt; 4、组件使用 &lt;!-- 检测信息树形弹窗 --&gt; &lt;test-type-tree :testTypeTreeViewFlag=&quot;testTypeTreeViewFlag&quot; :treeData=&quot;treeData&quot; @closeTestTypeTreeView=&quot;closeTestTypeTreeView&quot; @confirmTestTypeSelect=&quot;confirmTestTypeSelect&quot; ref=&quot;testTypeTree&quot; &gt;&lt;/test-type-tree&gt; import TestTypeTree from &quot;@/components/TestTypTree&quot;; // 检测信息树形弹窗 export default { components: { TestTypeTree }, data() { return { testTypeTreeViewFlag: false, treeData: [], // 树形数据 departmentUserList: [], // 部门人员树结构 } }, methods: { closeTestTypeTreeView() { this.testTypeTreeViewFlag = false; }, confirmTestTypeSelect() { this.testTypeTreeViewFlag = false; let arrFrist = [], // 一级菜单数组 arrSecond = [], // 二级菜单数组 arrSecondId = [], // 二级菜单id selectTreeId = []; // 选中数据，用于数据回显 arr.forEach((item) =&gt; { if (item.parentId == &quot;#&quot;) { if (flag) { selectTreeId.push(item.id); } arrFrist.push(item); } else { arrSecond.push(item); selectTreeId.push(item.id); let obj = { ExamineID: item.id }; arrSecondId.push(obj); } }); let str = arrFrist[0].label; if (arrSecond.length &gt; 0) { str += &quot;(&quot;; arrSecond.forEach((item, index) =&gt; { str += item.label; if (index != arrSecond.length - 1) { str += &quot;,&quot;; } }); str += &quot;)&quot;; } this.sampleMainruleForm.DetectionTaskItemsList[itemIndex].selectFirstMenuName = arrFrist[0].label; this.sampleMainruleForm.DetectionTaskItemsList[itemIndex].selectTreeName = str; this.sampleMainruleForm.DetectionTaskItemsList[itemIndex].selectTreeId = selectTreeId; this.sampleMainruleForm.DetectionTaskItemsList[itemIndex].ExamineTypeID =arrFrist[0].id; this.sampleMainruleForm.DetectionTaskItemsList[itemIndex].Children = arrSecondId; } } } 5、备注 树结构数据： ","link":"https://hviker.github.io/post/vue-er-ji-shu-zhi-neng-xuan-ze-yi-ji-jie-dian-xia-de-yi-xiang-huo-zhe-duo-xiang/"},{"title":"vue二级树结构(二级单选)","content":"1、业务需求 树结构由部门和人员组成，其中部门为树一级节点，人员为树二级节点，要求点选时只能选择一个人。 2、效果展示 3、组件代码 借助于element-ui el-tree &lt;!-- 人员结构树 --&gt; &lt;template&gt; &lt;el-dialog :visible.sync=&quot;personTreeViewFlag&quot; width=&quot;55%&quot; :append-to-body=&quot;true&quot; class=&quot;mainContainer personTree&quot; &gt; &lt;div class=&quot;projectTitle&quot;&gt; {{ titleText }}&lt;/div&gt; &lt;el-input placeholder=&quot;输入关键字进行过滤&quot; v-model=&quot;filterText&quot; clearable=&quot;&quot;&gt;&lt;/el-input&gt; &lt;el-tree :data=&quot;treeData&quot; :props=&quot;treeProp&quot; show-checkbox node-key=&quot;department_userId&quot; ref=&quot;personSelect&quot; highlight-current class=&quot;personSelect&quot; :filter-node-method=&quot;filterNode&quot; :accordion=&quot;isMultiple == '1'&quot; :check-on-click-node=true @check-change=&quot;getCheckData&quot; &gt;&lt;/el-tree&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;confirmPersonSelect&quot;&gt;确认选择&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;cancelPersonSelect&quot;&gt;取消选择&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;closePersonTreeView&quot;&gt;关闭&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/template&gt; &lt;script&gt; export default { props: { personTreeViewFlag:{ // 树弹窗显示标识 type: Boolean, required: true }, titleText: { // 标题名称 type: String, default: &quot;人员信息&quot; }, isMultiple: { // 是否为单选 1是0否 type: String, required: true }, treeData: { // 树形结构 type: Array, default: [] }, isRequire: { // 是否必填，1是0否 type: String, // default: false } }, components: {}, data() { return { filterText: &quot;&quot;, // 关键字过滤 treeProp: { // 树形结构解析树形 children: 'children', label: 'label', // id: 'department_userId' }, checkedNodeArr: [], // 选中的人员数组 }; }, computed: {}, watch: { // 实时监听过滤关键字 filterText(val) { this.$refs.personSelect.filter(val); } }, methods: { // 关键字过滤 filterNode(value, data) { if (!value) return true; return data.label.indexOf(value) !== -1; }, // 确认 confirmPersonSelect() { let personSelect = this.$refs.personSelect.getCheckedNodes(); if(this.isRequire == &quot;1&quot; &amp;&amp; personSelect.length === 0) { this.$message({ type: &quot;warning&quot;, message: &quot;请选择人员&quot; }) return; } let arr = []; // 人员数组 personSelect.forEach(item =&gt; { if(item.parentId != &quot;#&quot;) { arr.push(item) } }) this.$emit(&quot;confirmPersonSelect&quot;, arr) }, // 关闭 closePersonTreeView() { this.$emit(&quot;closePersonTreeView&quot;) }, // 选择人员 getCheckData(data, checked) { if(this.isMultiple == &quot;1&quot;) { let personSelect = this.$refs.personSelect.getCheckedNodes(); let idArr = []; if(checked) { // 判断是否是选中部门 if(data.parentId == &quot;#&quot;) { // 判断部门下人员数量 if(data.children.length === 0) { this.$message({ type: &quot;warning&quot;, message: &quot;该部门下不存在人员，请重新选择&quot; }) this.$refs.personSelect.setCheckedNodes([]) }else if(data.children.length &gt; 1) { // this.$message({ // type: &quot;warning&quot;, // message: &quot;该部门下存在多个人员，请选择一个&quot; // }) // return; idArr = [ data.children[0].department_userId ] this.$refs.personSelect.setCheckedNodes(idArr); return; } else { this.$refs.personSelect.setCheckedKeys([]) idArr.push(data.children[0][&quot;department_userId&quot;]); this.$refs.personSelect.setCheckedKeys(idArr) } } else { this.$refs.personSelect.setCheckedKeys([]) idArr.push(data[&quot;department_userId&quot;]); this.$refs.personSelect.setCheckedKeys(idArr) } } } }, // 取消选择 cancelPersonSelect() { this.$refs.personSelect.setCheckedKeys([]) }, // 获取树最新展示 getTreeSelect(selectNode){ let node = selectNode ? selectNode: []; this.$refs.personSelect.setCheckedKeys(node) } }, created() {}, mounted() {}, }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; .projectTitle { width: 100%; height: 40px; line-height: 40px; background-color: #7ee697; font-size: 1rem; padding-left: 20px; padding-right: 20px; font-weight: bolder; margin-bottom: 25px; color: #000000; } .personSelect { max-height: 500px; overflow: auto; margin-top: 15px; } &lt;/style&gt; &lt;style lang=&quot;scss&quot;&gt; .personTree { .el-dialog { margin-top: 3vh !important; } } &lt;/style&gt; 4、组件使用 &lt;!-- 样品关联人树形结构 --&gt; &lt;person-tree :personTreeViewFlag=&quot;sampleRelationTreeViewFlag&quot; ref=&quot;sampleRelationTree&quot; titleText=&quot;请选择样品关联人&quot; isMultiple=&quot;1&quot; :treeData=&quot;departmentUserList&quot; isRequire=&quot;0&quot; @closePersonTreeView=&quot;closeSampleRelationTree&quot; @confirmPersonSelect=&quot;confirmSampleRelationTree&quot; &gt; &lt;/person-tree&gt; import PersonTree from &quot;@/components/PersonTree/personTree_index&quot;; // 部门用户树状结构 export default { components: { PersonTree }, data() { return { sampleRelationTreeViewFlag: false, departmentUserList: [], // 部门人员树结构 } }, methods: { // 确认 confirmSampleRelationTree（） { // 以下代码根据业务要求实现 let arr1 = []; // 人员数组id let str = &quot;&quot;; arr.forEach((item, index) =&gt; { arr1.push(item.department_userId) str += item.label if(index != arr.length - 1) { str += &quot;,&quot; } }) this.sampleMainruleForm.RelatedUserIDs = arr1; this.sampleMainruleForm.RelatedUserID = arr1[0].split(&quot;_&quot;)[1]; this.sampleMainruleForm.RelationUserName = str; this.closeSampleRelationTree(); }， // 关闭样品关联人树形弹窗 closeSampleRelationTree() { this.sampleRelationTreeViewFlag = false; }, } } 5、备注 树结构数据： ","link":"https://hviker.github.io/post/vue-er-ji-shu-jie-gou-er-ji-dan-xuan/"},{"title":"vue多层对象form验证","content":"1、需求 验证数据格式如下，需要验证sampleMainruleForm.DetectionTaskItemsList的selectTreeName数据必填，并且DetectionTaskItemsList为动态添加数组，每个都需要验证 sampleMainruleForm: { ID: &quot;&quot;, // 样品主页面表单数据对象 TaskName: &quot;&quot;, ProjectID: &quot;&quot;, SubmitDate: this.$moment(), RelatedUserIDs: [], RelatedUserID: &quot;&quot;, RelationUserName: &quot;&quot;, Remark: &quot;&quot;, MainType: &quot;&quot;, SampleMaterialID: &quot;&quot;, SampleMaterialName: &quot;&quot;, SteelMaterialID: &quot;&quot;, SteelMaterialName: &quot;&quot;, IsRange: 1, CompositionsList: [ { ElementName: &quot;C&quot;, MinValue: &quot;&quot;, MaxValue: &quot;&quot;, Feature: &quot;&quot; }, { ElementName: &quot;Si&quot;, MinValue: &quot;&quot;, MaxValue: &quot;&quot;, Feature: &quot;&quot; }, { ElementName: &quot;Mn&quot;, MinValue: &quot;&quot;, MaxValue: &quot;&quot;, Feature: &quot;&quot; } ], DetectionTaskItemsList: [], sampleSign: &quot;&quot;, SampleNum: null, DetectionTaskItemsList: [ { id: &quot;1&quot;, selectTreeName: &quot;&quot;, selectTreeId: [], selectFirstMenuName: &quot;&quot;, ExamineTypeID: &quot;&quot;, Children: [], TestStandard: &quot;&quot;, Remark: &quot;&quot;, fileList: [], FileAttachmentList: [], }, ], 2、效果截图 3、实现代码 &lt;!-- 检测信息开始 --&gt; &lt;div class=&quot;detectinfo&quot;&gt; &lt;div class=&quot;sampleTitleArea&quot;&gt; &lt;img src=&quot;@/assets/testDetection/detectinfo.png&quot; /&gt;检测信息 &lt;/div&gt; &lt;div v-for=&quot;(item, index) in sampleMainruleForm.DetectionTaskItemsList&quot; :key=&quot;item.id&quot;&gt; &lt;el-row&gt; &lt;el-col :span=&quot;20&quot;&gt; &lt;el-row&gt; &lt;el-col :span=&quot;24&quot;&gt; &lt;!-- &lt;el-form-item label=&quot;检测项目&quot; :prop=&quot;`DetectionTaskItemsList[${index}].TestType`&quot; :rules=&quot;{ required: true, message: '请选择所属项目', trigger: 'change' }&quot;&gt; &lt;el-select v-model=&quot;item.TestType&quot; placeholder=&quot;检测项目&quot; filterable clearable :popper-append-to-body=&quot;false&quot;&gt; &lt;el-option v-for=&quot;item in detectProjectArr&quot; :key=&quot;item.key&quot; :label=&quot;item.value&quot; :value=&quot;item.key&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt;--&gt; &lt;el-form-item label=&quot;检测项目&quot; :prop=&quot;`DetectionTaskItemsList[${index}].selectTreeName`&quot; :rules=&quot;{ required: true, message: '请选择检测项目'}&quot; &gt; &lt;el-input v-model=&quot;item.selectTreeName&quot; placeholder=&quot;请选择检测项目&quot; :title=&quot;item.selectTreeName&quot; @focus=&quot;testTypeTreeView(item.id)&quot; readonly clearable &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=&quot;24&quot;&gt; &lt;el-form-item label=&quot;检测标准&quot;&gt; &lt;el-input v-model=&quot;item.TestStandard&quot; placeholder=&quot;请输入检测号&quot; clearable&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=&quot;24&quot; class=&quot;testProcess&quot;&gt; &lt;el-form-item label=&quot;试验工艺&quot;&gt; &lt;el-input v-model=&quot;item.Remark&quot; placeholder=&quot;请输入热模拟试验工艺活相分析热处理工艺等&quot; clearable&gt;&lt;/el-input&gt; &lt;upload-file :fileLimit=&quot;1&quot; :fileList=&quot;item.fileList&quot; :id=&quot;item.id&quot; @handleFileRemove=&quot;handleFileRemove&quot; @handleFileAdd=&quot;handleFileAdd&quot; &gt;&lt;/upload-file&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;4&quot; class=&quot;addDetect&quot; &gt; &lt;img src=&quot;@/assets/testDetection/deleteDetect1.png&quot; v-if=&quot;sampleMainruleForm.DetectionTaskItemsList.length != 1&quot; @click=&quot;delDetectInfo(item.id)&quot; /&gt; &amp;nbsp;&amp;nbsp; &lt;img src=&quot;@/assets/testDetection/addDetect1.png&quot; v-if=&quot;index == sampleMainruleForm.DetectionTaskItemsList.length - 1&quot; @click=&quot;addDetectInfo&quot; /&gt; &lt;/el-col&gt; &lt;!-- &lt;el-col :span=&quot;4&quot; class=&quot;delDetect&quot; v-if=&quot;index !== 0&quot; &gt; &lt;img src=&quot;@/assets/testDetection/deleteDetect1.png&quot; @click=&quot;delDetectInfo(item.id)&quot; /&gt; &lt;/el-col&gt; --&gt; &lt;/el-row&gt; &lt;div class=&quot;cutLine&quot; v-if=&quot;index !== sampleMainruleForm.DetectionTaskItemsList.length - 1&quot; &gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ","link":"https://hviker.github.io/post/vue-duo-ceng-dui-xiang-form-yan-zheng/"},{"title":"vue 分页","content":"借助于element-ui el-pagination 效果展示 组件代码 &lt;template&gt; &lt;div :class=&quot;{'hidden':hidden}&quot; class=&quot;pagination-container&quot;&gt; &lt;el-pagination :background=&quot;background&quot; :current-page.sync=&quot;currentPage&quot; :page-size.sync=&quot;pageSize&quot; :layout=&quot;layout&quot; :page-sizes=&quot;pageSizes&quot; :total=&quot;total&quot; v-bind=&quot;$attrs&quot; @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { scrollTo } from '@/utils/scroll-to' export default { name: 'Pagination', props: { total: { // 总条数 required: true, type: Number }, page: { // 当前页 type: Number, default: 1 }, limit: { // 每页条数 type: Number, default: 20 }, pageSizes: { // 每页条数设置 type: Array, default() { return [10, 20, 30] } }, layout: { // 按钮设置 type: String, default: 'total, sizes, prev, pager, next, jumper' }, background: { type: Boolean, default: true }, autoScroll: { type: Boolean, default: true }, hidden: { type: Boolean, default: false } }, computed: { currentPage: { get() { return this.page }, set(val) { this.$emit('update:page', val) } }, pageSize: { get() { return this.limit }, set(val) { this.$emit('update:limit', val) } } }, methods: { handleSizeChange(val) { this.$emit('pagination', { page: this.currentPage, limit: val }); // 分页点击时将滚动条放置到顶部 document.getElementsByClassName('main-container')[0].scrollTop = 0 // if (this.autoScroll) { // scrollTo(0, 800) // } }, handleCurrentChange(val) { this.$emit('pagination', { page: val, limit: this.pageSize }); // 分页点击时将滚动条放置到顶部 document.getElementsByClassName('main-container')[0].scrollTop = 0 // if (this.autoScroll) { // scrollTo(0, 800) // } } } } &lt;/script&gt; &lt;style scoped&gt; .pagination-container { background: #fff; padding: 32px 16px; text-align: right; } .pagination-container.hidden { display: none; } &lt;/style&gt; 组件使用 &lt;pagination v-show=&quot;total &gt; 0&quot; :total=&quot;total&quot; :page.sync=&quot;listQuery.page&quot; :limit.sync=&quot;listQuery.limit&quot; @pagination=&quot;getList&quot; /&gt; import Pagination from &quot;@/components/Pagination&quot;; // 分页组件 export default { components: { Pagination }, data() { return { total: 0, // 数据总条数 listQuery: { page: 1, // 当前页 limit: 20, // 每页条数 }, }; }, methods: { getList(obj) { this.listQuery.page = obj.page; this.listQuery.limit = obj.limit; // 调用页面的查询方法 this.testDataSearch(); }, } } ","link":"https://hviker.github.io/post/vue-fen-ye/"},{"title":"vue打印实现","content":"// 打印类属性、方法定义 /* eslint-disable */ const Print = function (dom, options) { if (!(this instanceof Print)) return new Print(dom, options); this.options = this.extend({ 'noPrint': '.no-print' }, options); if ((typeof dom) === &quot;string&quot;) { this.dom = document.querySelector(dom); } else { this.isDOM(dom) this.dom = this.isDOM(dom) ? dom : dom.$el; } this.init(); }; Print.prototype = { init: function () { var content = this.getStyle() + this.getHtml(); this.writeIframe(content); }, extend: function (obj, obj2) { for (var k in obj2) { obj[k] = obj2[k]; } return obj; }, getStyle: function () { var str = &quot;&quot;, styles = document.querySelectorAll('style,link'); for (var i = 0; i &lt; styles.length; i++) { str += styles[i].outerHTML; } str += &quot;&lt;style&gt;&quot; + (this.options.noPrint ? this.options.noPrint : '.no-print') + &quot;{display:none;}&lt;/style&gt;&quot;; return str; }, getHtml: function () { var inputs = document.querySelectorAll('input'); var textareas = document.querySelectorAll('textarea'); var selects = document.querySelectorAll('select'); for (var k = 0; k &lt; inputs.length; k++) { if (inputs[k].type == &quot;checkbox&quot; || inputs[k].type == &quot;radio&quot;) { if (inputs[k].checked == true) { inputs[k].setAttribute('checked', &quot;checked&quot;) } else { inputs[k].removeAttribute('checked') } } else if (inputs[k].type == &quot;text&quot;) { inputs[k].setAttribute('value', inputs[k].value) } else { inputs[k].setAttribute('value', inputs[k].value) } } for (var k2 = 0; k2 &lt; textareas.length; k2++) { if (textareas[k2].type == 'textarea') { textareas[k2].innerHTML = textareas[k2].value } } for (var k3 = 0; k3 &lt; selects.length; k3++) { if (selects[k3].type == 'select-one') { var child = selects[k3].children; for (var i in child) { if (child[i].tagName == 'OPTION') { if (child[i].selected == true) { child[i].setAttribute('selected', &quot;selected&quot;) } else { child[i].removeAttribute('selected') } } } } } // 包裹要打印的元素 // fix: https://github.com/xyl66/vuePlugs_printjs/issues/36 return this.wrapperRefDom(this.dom).outerHTML; }, // 向父级元素循环，包裹当前需要打印的元素 // 防止根级别开头的 css 选择器不生效 wrapperRefDom: function (refDom) { let prevDom = null let currDom = refDom while (currDom &amp;&amp; currDom.tagName.toLowerCase() !== 'body') { if (prevDom) { let element = currDom.cloneNode(false) element.appendChild(prevDom) prevDom = element } else { prevDom = currDom.cloneNode(true) } currDom = currDom.parentElement } return currDom.tagName.toLowerCase() === 'body' ? currDom : prevDom }, writeIframe: function (content) { var w, doc, iframe = document.createElement('iframe'), f = document.body.appendChild(iframe); iframe.id = &quot;myIframe&quot;; //iframe.style = &quot;position:absolute;width:0;height:0;top:-10px;left:-10px;&quot;; iframe.setAttribute('style', 'position:absolute;width:0;height:0;top:-10px;left:-10px;'); w = f.contentWindow || f.contentDocument; doc = f.contentDocument || f.contentWindow.document; doc.open(); doc.write(content); doc.close(); var _this = this iframe.onload = function(){ _this.toPrint(w); setTimeout(function () { document.body.removeChild(iframe) }, 100) } }, toPrint: function (frameWindow) { try { setTimeout(function () { frameWindow.focus(); try { if (!frameWindow.document.execCommand('print', false, null)) { frameWindow.print(); } } catch (e) { frameWindow.print(); } frameWindow.close(); }, 10); } catch (err) { console.log('err', err); } }, isDOM: (typeof HTMLElement === 'object') ? function (obj) { return obj instanceof HTMLElement; } : function (obj) { return obj &amp;&amp; typeof obj === 'object' &amp;&amp; obj.nodeType === 1 &amp;&amp; typeof obj.nodeName === 'string'; } }; const MyPlugin = {} MyPlugin.install = function (Vue, options) { // 4. 添加实例方法 Vue.prototype.$print = Print } export default MyPlugin 2、main.js中进行引入 import Print from &quot;@/utils/print.js&quot; // 打印 Vue.use(Print) 3、使用 &lt;div class=&quot;printContainer clearfix&quot; ref=&quot;samplePdf&quot;&gt; &lt;div class=&quot;prinfLeft fl&quot;&gt; &lt;img :src=&quot;qrcode&quot; alt=&quot;codePic&quot; /&gt; &lt;p&gt;扫码查询样品信息&lt;/p&gt; &lt;/div&gt; &lt;ul class=&quot;printRight fr&quot;&gt; &lt;li&gt;&lt;label&gt;样品&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ID:&lt;/label&gt;&lt;span&gt;{{ TaskNum }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;任务名称:&lt;/label&gt;&lt;span&gt;{{ TaskName }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;检测项目:&lt;/label&gt;&lt;span&gt;{{ DetectionTaskItems }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;委托人:&lt;/label&gt;&lt;span&gt;{{ SamplePerson }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;所属部门:&lt;/label&gt;&lt;span&gt;{{ CreatedDepartmentName }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;样品所有人:&lt;/label&gt;&lt;span&gt;{{ RelationUserName }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;平行样品:&lt;/label&gt;&lt;span&gt;{{ SampleNum }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;样品原号:&lt;/label&gt;&lt;span&gt;{{ repsampleSign }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;送样日期:&lt;/label&gt;&lt;span&gt;{{ createTime }}&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer no-print&quot;&gt; &lt;el-button type=&quot;info&quot; @click=&quot;closeSamplePdf&quot;&gt;返回&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;samplePrint&quot;&gt;保存PDF&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;samplePrint&quot;&gt;打印&lt;/el-button&gt; &lt;/span&gt; methods: { // 打印 samplePrint() { this.$print(this.$refs.samplePdf) }, } 4、备注 对于不想打印的内容添加 .no-print 类 ","link":"https://hviker.github.io/post/vue-da-yin-shi-xian/"},{"title":"Axios请求图片流","content":"// 设置请求头为application/x-www-form-urlencoded， 设置返回数据格式为arraybuffer axios.post(process.env.VUE_APP_BASE_IP + '/tky/tky/vuelogin/captcha.html', {headers: {'Content-Type': 'application/x-www-form-urlencoded'}}, {responseType:&quot;arraybuffer&quot;}).then(res =&gt; { // 这里将得到的图片流转换成blob类型 const blob = new Blob([res.data], { type: 'application/png;charset=utf-8', }); const url = window.URL.createObjectURL(blob); this.verifyPic = url; }) ","link":"https://hviker.github.io/post/axios-qing-qiu-tu-pian-liu/"},{"title":"VUE中引入较大SVG成品图方法","content":"1、项目需求 项目中写好车站及图元的绘制方法，按照要求动态生成车站成品图。车站成品图涉及图元较多，如果每次打开页面动态绘制会占用较长时间，影响加载效率和用户体验。 2、解决方案 决定采用动态引入成品SVG图的方法。首先，使用绘制方法，生成车站svg代码，然后将浏览器中的svg代码复制粘贴出来，作为静态svg文件引入。 3、具体实现步骤 (1) vue中引入svg-sprite-loader，在vue.config.js中配置svg读取路径。 chainWebpack(config) { config.module .rule('icons') .test(/\\.svg$/) .include.add([resolve('src/icons'), resolve('src/assets/jgsvg')]) .end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options({ symbolId: 'icon-[name]' }) .end() } (2) 将成品车站图从浏览器控制台中复制出来，在网站中进行格式化，并查看格式化后的svg图形是否可以正常展示。 这里推荐两个网站: 在线代码格式化 svg在线制作编辑预览工具 将车站成品图代码放到src/assets/jgsvg目录下。 具体格式化后代码见下图。 (3) 引入方法，使用import引入svg文件 html: &lt;div class=&quot;editContainer_SVG&quot;&gt;&lt;/div&gt; js： import zhanchang from &quot;@/assets/jgsvg/chang.svg&quot; // 引入站场图 importStation() { // 引入svg let zhanchangSvg = zhanchang.content.replace(new RegExp(&quot;symbol&quot;, &quot;gm&quot;), &quot;svg&quot;); let str = &quot;width='100%' height='100%' &quot;; // 添加svg属性 let svgText = insertStr(zhanchangSvg, 5, str); $(&quot;.editContainer_SVG&quot;).append(svgText); this.$nextTick(() =&gt; { // 添加属性 let self = this; // 这里必须指定已存在的元素 .editContainer_SVG const pageSvg = d3.select(&quot;.editContainer_SVG #icon-TSRSzhanchang&quot;); this.pageSvg = pageSvg; let g =d3.select(&quot;.editContainer_SVG #icon-TSRSzhanchang &gt;g&quot;); this.pageG = g; // 设置滚动及缩放限制 this.svgZoom = d3.zoom() .scaleExtent(this.svgScaleExtent) // 添加放大限制 .on(&quot;zoom&quot;, zoomed); this.pageSvg.call(this.svgZoom) .on(&quot;wheel&quot;, function () { d3.event.preventDefault(); // 放大倍数达到上下限时svg图形不随鼠标滚动上下移动 }) .on(&quot;dblclick.zoom&quot;, null) // 获取全体包，刷新全体包状态 let allPakcData = this.$store.getters.packData; this.renderDom(allPakcData); // zoom 滚动及缩放方法 function zoomed() { let transforms = d3.event.transform; self.svgZoomTransform = transforms; // // // $(&quot;.rectTipView&quot;).empty(); self.rectTipFlag = false; self.pageG.attr(&quot;transform&quot;, transforms); } }) } /** * 在指定位置插入字符串 * @param {*} soure * @param {*} start * @param {*} newStr */ export function insertStr(soure, start, newStr) { return soure.slice(0, start) + newStr + soure.slice(start) } .editContainer_SVG所在的div为svg的容器。 使用import引入svg静态文件后，会改变svg原有的代码， (1) 由symbol 标签包裹，需要替换symbol为svg; (2) width，height属性消失，需要动态拼接width、height属性 (3) id会有所调整，编程icon_文件名，这里的需要对接下来代码中的指定元素进行修改。 (4) d3.select(&quot;.editContainer_SVG #icon-TSRSzhanchang&quot;) 这里一定要加原dom中已存在的元素 .editContainer_SVG，否则接下来设置的svg拖动、缩放无效。 ","link":"https://hviker.github.io/post/vue-zhong-yin-ru-jiao-da-svg-cheng-pin-tu-fang-fa/"},{"title":"js  数组对象根据某几个key更新合并方法","content":"// 闭塞分区与区段对应关系,格式 {key: &quot;车站ID_Section_区段id&quot;} // let sectionRelationObj = getSectionRelationObj(datas.sectionInfo); // store.dispatch(&quot;initConfigStore/sectionRelationObj&quot;, sectionRelationObj); // 线路号与区段对应关系，格式 {key: &quot;车站ID_Section_区段id&quot;} // let lineReationObj = getLineRelationObj(datas.sectionInfo); // store.dispatch(&quot;initConfigStore/lineReationObj&quot;, lineReationObj) function getSectionRelationObj(arr) { let obj = {}; let sectionRelationObj = {}; arr.reduce((item, next) =&gt; { if(obj[next.blockSectionID]) { item.some(arrItem =&gt; { let key = Object.keys(arrItem)[0] if(key == next.blockSectionID) { sectionRelationObj[key].push(next.tccDeviceId + &quot;Section&quot; + next.id); return true; } }) } else { obj[next.blockSectionID] = true; let nextObj = {}; nextObj[next.blockSectionID] = []; nextObj[next.blockSectionID].push(next.tccDeviceId + &quot;Section&quot; + next.id); sectionRelationObj = Object.assign(sectionRelationObj, nextObj) item.push(nextObj) } return item; }, []) return sectionRelationObj; } function getLineRelationObj(arr) { let obj = {}; let lineRelationObj = {}; arr.reduce((item, next) =&gt; { if(obj[next.lineID]) { item.some(arrItem =&gt; { let key = Object.keys(arrItem)[0] if(key == next.lineID) { lineRelationObj[key].push(next.tccDeviceId + &quot;Section&quot; + next.id); return true; } }) } else { obj[next.lineID] = true; let nextObj = {}; nextObj[next.lineID] = []; nextObj[next.lineID].push(next.tccDeviceId + &quot;Section&quot; + next.id); lineRelationObj = Object.assign(lineRelationObj, nextObj) item.push(nextObj) } return item; }, []) return lineRelationObj; } ","link":"https://hviker.github.io/post/js-shu-zu-dui-xiang-gen-ju-mou-ji-ge-key-geng-xin-he-bing-fang-fa/"},{"title":"Vue  防止按钮在短时间内被多次点击的方法","content":"1、创建intervalclick.js import Vue from 'vue' (function(){ let openDelay=false; Vue.directive('intervalclick', function(el,binding){ el.onclick=function(e){ if(openDelay)return; openDelay=!openDelay; if (!binding.value) { alert(&quot;未传入Value数据！&quot;); return; } let func = binding.value['func']; let time=binding.value['time']; if(typeof time !=='number'){ alert(&quot;传入等待时间错误&quot;); return; } let args=[]; for (const key in binding.value) { if (binding.value.hasOwnProperty(key)) { if(key==='func'||key==='time')continue; args.push(binding.value[key]) } } setTimeout(() =&gt; { openDelay=!openDelay; }, time); func(...args); } }) })() 2、main.js中引入 import clickState from '@/utils/intervalclick' 3、使用 v-intervalclick=&quot;{func:nextControl, time:1000}&quot; 其中，第一个参数nextControl为方法，time为时间间隔 ","link":"https://hviker.github.io/post/vue-fang-zhi-an-niu-zai-duan-shi-jian-nei-bei-duo-ci-dian-ji-de-fang-fa/"},{"title":"cnpm install 报错  cnpm 报错 Install fail! SyntaxError: Unexpected end of JSON input","content":"1、清空缓存 cnpm cache clean --force 如果是npm清除缓存，则使用 npm cache clean --force 2、重新安装cnpm，并设置淘宝镜像 npm install -g cnpm --registry=https://registry.npm.taobao.org 3、安装 cnpm install ","link":"https://hviker.github.io/post/cnpm-install-bao-cuo-cnpm-bao-cuo-install-fail-syntaxerror-unexpected-end-of-json-input/"},{"title":"CentOS7 启动防火墙 报错 Failed to start iptables.service: Unit not found.解决方案","content":"service iptables restart/start/stop Redirecting to /bin/systemctl restart iptables.service Failed to restart iptables.service: Unit not found. 原因是因为CentOS7 里面是用 firewalld (相关介绍介绍请点击)来管理防火墙的。 命令语法：firewall-cmd [--zone=zone] 动作 [--permanent] 注：如果不指定--zone选项，则为当前所在的默认区域，--permanent选项为是否将改动写入到区域配置文件中 firewall的状态： --state ##查看防火墙的状态 --reload ##重新加载防火墙，中断用户的连接，将临时配置清掉，加载配置文件中的永久配置 --complete-reload ##重新加载防火墙，不中断用户的连接（防火墙出严重故障时使用） --panic-on ##紧急模式，强制关闭所有网络连接,--panic-off是关闭紧急模式 例: 添加80端口为允许： firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent 没有此参数重启后失效） 添加范围例外端口 如 5000-10000： firewall-cmd --zone=public --add-port=5000-10000/tcp --permanent 添加完成后立刻生效： 重新载入 firewall-cmd --reload 查看 firewall-cmd --zone=public --query-port=80/tcp 删除 firewall-cmd --zone=public --remove-port=80/tcp --permanent ","link":"https://hviker.github.io/post/centos7-qi-dong-fang-huo-qiang-bao-cuo-failed-to-start-iptablesservice-unit-not-foundjie-jue-fang-an/"},{"title":"区分js 编码和解码","content":"1、encodeURI()是Javascript中真正用来对URL编码的函数。编码整个url地址，但对特殊含义的符号&quot;; / ? : @ &amp; = + $ , #&quot;，也不进行编码。对应的解码函数是：decodeURI()。 2、encodeURIComponent()能编码&quot;; / ? : @ &amp; = + $ , #&quot;这些特殊字符。对应的解码函数是decodeURIComponent()。 3、encodeURIComponent()能编码&quot;; / ? : @ &amp; = + $ , #&quot;这些特殊字符。对应的解码函数是decodeURIComponent()。 ","link":"https://hviker.github.io/post/qu-fen-js-bian-ma-he-jie-ma/"},{"title":"D3相关 -- 区分选择集和xx对象","content":"1、示例 var rect = svg.append(&quot;rect&quot;) .attr(&quot;fill&quot;,&quot;yellow&quot;) .attr(&quot;x&quot;,100) .attr(&quot;y&quot;,100) .attr(&quot;width&quot;,100) .attr(&quot;height&quot;,30) //打印rect console.log(rect) //rect是选择集 //启动过渡效果 var rectTran = rect.transition() //打印rectTran console.log(rectTran) //rectTran是一个过渡对象 2、选择某一类型的选择集 // 在根元素document.documentElement上返回一个新的对象，等价于d3.select d3.selectAll('circle') 3、选择某一类型的过渡对象 d3.selectAll('circle').transition() 4、d3.transition([selection],[name]) //创建一个过渡对象。但是由于每个选择集中都有transition()方法，可用d3.select(&quot;rect&quot;).transition()的方式来创建过渡，因此一般不直接用d3.transition()。 d3.transition().selection().selectAll('circle').transition().duration(5000).attr('fill', 'red') 等价于 d3.selectAll('circle').transition().duration(5000).attr('fill', 'red') 1 ","link":"https://hviker.github.io/post/d3-xiang-guan-qu-fen-xuan-ze-ji-he-xx-dui-xiang/"},{"title":"D3相关-transition （动画）","content":"一、动画相关 1、选中元素添加动画 d3.selectAll('circle').transition().duration(500).style('fill', 'red'); // 动画持续500ms d3.selectAll('circle').transition().delay(500).style('fill', 'red'); // 延迟500ms后执行动画 2、中止动画 该方法取消指定node上未执行的过渡部分(如果存在未执行的过渡部分) d3.select('.circle').interrupt(); 3、筛选 筛选不存在circle1类的circle图元，添加动画 d3.selectAll('circle').filter(filterFunc).transition().style('fill', 'red'); function filterFunc() { return d3.select(this).attr('class') != 'circle1' } 4、循环动画 实现黄灯每隔500ms的闪烁效果 d3.selectAll('circle').transition().on('start', function repeat() { d3.active(this).duration(500).style('fill', 'green') .transition().duration(500),style('fill', 'transparent') .on('start', repeat) }) 二、属性操作 1、attr、style 2、xxxTween xxxTween：自定义插值器，相当于是把延迟的过程放到了方法里。有attrTween, styleTween // 在5s之内把r从原大小变成500px d3.selectAll('.circle').transition().duration(5000).attrTween(&quot;r&quot;, function() { return d3.interpolateNumber(this.getAttribute(&quot;r&quot;), 500) }) 这里需要根据value值使用对应的获取值方法 如果 value 为数值, 使用 interpolateNumber. 如果 value 为 color 或可以被强制转为颜色的字符串, 使用 interpolateRgb. 使用 interpolateString. 3、tween // 在5s之内把fill 从原颜色变成blue d3.selectAll('.circle').transition().duration(5000).tween(&quot;fill&quot;, function() { var node = this, i = d3.interpolateRgb(node.getAttribute(&quot;fill&quot;), &quot;blue&quot;); // i是一个方法，从原颜色到blue渐变。 // t 的大小为[0,1] return function(t) { node.setAttribute(&quot;fill&quot;, i(t)) } }) ","link":"https://hviker.github.io/post/d3-xiang-guan-transition-dong-hua/"},{"title":"D3相关- drag（拖动）","content":"1、添加拖动方法 d3.selectAll('circle').call(d3.drag().on('start',function() { d3.select(this).attr('fill', 'red'); // 修改颜色 }) .on('drag', function() { // 获取并设定移动位置 let {x, y} = d3.event; d3.select(this).attr('cx', x).attr('cy', y); }) .on('end',function() { d3.select(this).attr('fill', 'green') }) 2、解除某些图元的drag绑定 d3.selectAll('circle1').call(d3.drag().on('.drag', null)) 该方法用于将circle中带有circle1类的图元取消drag拖动绑定 3、详解 (1) d3.drag():创建一个拖拽行为并返回自身，需要用selection.call()进行调用 即:d3.selectAll('circle').call(d3.drag()) (2) d3.drag().on():添加事件回调 start - 拖拽开始 drag - 拖拽中 end - 拖拽结束 (3) 在回调过程中返回当前拖拽对象信息，即d3.event target - 相关联的drag behavior. type - 字符串 “start”, “drag” 或 “end”; 参考 drag.on. subject - 通过 drag.subject定义的subject. x - subject 的 x-坐标; 参考 drag.container. y - subject 的 y-坐标; 参考 drag.container. dx - 与上一次拖拽相比 x-坐标 的变化. dy - 与上一次拖拽相比 y-坐标 的变化. identifier - 字符串 “mouse”, 或者表示 touch identifier的数字. active - 当前活动的拖拽手势的数量(在start和end, 不包含这个). sourceEvent - 底层原始事件比如 mousemove 或 touchmove. (4) 关于容器的设定 d3.drag().container(Func)，用于指定容器，暂不清楚如何使用 (5) 关于过滤器的设定 d3.drag().filter(Func),用于指定过滤器，暂不清楚如何使用 ","link":"https://hviker.github.io/post/d3-xiang-guan-dragtuo-dong/"},{"title":"GIT 忽略本地已存在文件修改","content":"1、将文件修改忽略 git update-index --assume-unchanged FILENAME 2、取消文件忽略 git update-index --no-assume-unchanged FILENAME 3、如果文件未上传到库中，并为提交到本地版本库中记录，最好使用： .gitignore 4、.gitignore文件忽略规则： 空格不匹配任意文件，可作为分隔符，可用反斜杠转义 # 开头的文件标识注释，可以使用反斜杠进行转义 ! 开头的模式标识否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用 ! 也不会再次被包含。可以使用反斜杠进行转义 / 结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件 / 开始的模式匹配项目跟目录 如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录 ** 匹配多级目录，可在开始，中间，结束 ? 通用匹配单个字符 [] 通用匹配单个字符列表 常用匹配示例： bin/: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件 /bin: 忽略根目录下的bin文件 /*.c: 忽略 cat.c，不忽略 build/cat.c debug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj **/foo: 忽略/foo, a/foo, a/b/foo等 a/**/b: 忽略a/b, a/x/b, a/x/y/b等 !/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件 *.log: 忽略所有 .log 文件 config.php: 忽略当前路径的 config.php 文件 ","link":"https://hviker.github.io/post/git-hu-lue-ben-di-yi-cun-zai-wen-jian-xiu-gai/"},{"title":"Linux常用命令","content":"1、cd 定位到文件夹 2、ls 查看当前文件下存在的内容 3、cd .. 返回至上一级目录 4、cd / 返回至最上级目录 5、pwd 查看当前路径 6、cat 查看当前文件内容 7、rm -rf 删除文件夹及下所有文件、文件夹 8、rm -f 删除文件 9、执行sh 文件 sh /root/datelog.sh 10、查看ftp是否安装 rpm -qa|grep vsftpd 11、查看ftp是否启动 service vsftpd status 12、启动ftp服务 service vsftpd start 下载ftp客户端:http://mirror.centos.org/centos-7/7.7.1908/os/x86_64/Packages/ 安装 rpm Uvh xxx 压缩文件 到指定目录 tar zcvf /root/gitbackups/gitlab20200423.tar.gz /root/gitlab/* z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名 /root/gitbackups/gitlab20200423.tar.gz 压缩到指定目录并命名 /root/gitlab/* 压缩内容 把/root/test目录中所有文件打包并使用gzip压缩为test.tar.gz文件 tar -zcvf /root/gitbackups/test.tar.gz /root/test 把/root/gitbackups/test.tar.gz目录中的所有文件解压，解压位置为/root/gitbackups tar -zxvf /root/gitbackups/test.tar.gz -C /root/gitbackups ","link":"https://hviker.github.io/post/linux-chang-yong-ming-ling/"},{"title":"CSS实现单行、多行文本溢出显示省略号","content":"### 1、单行文本溢出显示省略号 实现方法： overflow: hidden; text-overflow:ellipsis; white-space: nowrap; ### 2、多行文本溢出显示省略号 chrome实现方法： 不兼容IE及其他浏览器 display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; IE及其他浏览器实现方法： 使用插件clamps .js 插件下载地址：https://github.com/josephschmitt/Clamp.js 使用： // 引入 &lt;script src=&quot;js/Clamp.js-master/clamp.js&quot;&gt;&lt;/script&gt; // 样式 &lt;style&gt; .divarea { width: 300px; height: 84px; } p { width: 100%; } &lt;/style&gt; // html &lt;div class=&quot;divarea&quot;&gt; &lt;p&gt;这两个选择元素的API,ualCrew小组耗时两年翻译，保持与D3 V3最后一版（3.5.17）一致.D3 V4最新版API请参考d3.v4-API翻译&lt;/p&gt; &lt;/div&gt; // js &lt;script&gt; $(document).ready(function () { $clamp($(&quot;.divarea p&quot;)[0], { clamp: '2' }) }) &lt;/script&gt; ","link":"https://hviker.github.io/post/css-shi-xian-dan-xing-duo-xing-wen-ben-yi-chu-xian-shi-sheng-lue-hao/"},{"title":"纯CSS绘制各种三角形","content":"纯 CSS 实现绘制各种三角形（各种角度） 一、前言 三角形实现原理：宽度width为0；height为0；（1）有一条横竖边（上下左右）的设置为border-方向：长度 solid red，这个画的就是底部的直线。其他边使用border-方向：长度 solid transparent。（2）有两个横竖边（上下左右）的设置，若斜边是在三角形的右边，这时候设置top或bottom的直线，和右边的斜线。若斜边是在三角形的左边，这时候设置top或bottom的直线，和左边的斜线。 二、实现 2.1 Triangle Up #triangle-up { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red; } 2.2 Triangle Down #triangle-down { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; } 2.3 Triangle Left #triangle-left { width: 0; height: 0; border-top: 50px solid transparent; border-right: 100px solid red; border-bottom: 50px solid transparent; } 2.4 Triangle Right #triangle-right { width: 0; height: 0; border-top: 50px solid transparent; border-left: 100px solid red; border-bottom: 50px solid transparent; } 2.5 Triangle Top Left #triangle-topleft { width: 0; height: 0; border-top: 100px solid red; border-right: 100px solid transparent; } 2.6 Triangle Top Right #triangle-topright { width: 0; height: 0; border-top: 100px solid red; border-left: 100px solid transparent; } 2.7 Triangle Bottom Left #triangle-bottomleft { width: 0; height: 0; border-bottom: 100px solid red; border-right: 100px solid transparent; } 2.8 Triangle Bottom Right #triangle-bottomright { width: 0; height: 0; border-bottom: 100px solid red; border-left: 100px solid transparent; } ","link":"https://hviker.github.io/post/chun-css-hui-zhi-ge-chong-san-jiao-xing/"},{"title":"IE下多个tab页(嵌套iframe)打开导致内存一直上涨","content":"(1) 使用iframe时 ，确保公用一个iframe (2) ie下添加代码 let mainframe = document.getElementById(&quot;mainFrame&quot;); this.src = &quot;about:blank&quot;; //src地址清空 mainframe.contentWindow.document.write(''); // 清空iframe内容 mainframe.contentWindow.close(); CollectGarbage(); ","link":"https://hviker.github.io/post/ie-xia-duo-ge-tab-ye-qian-tao-iframeda-kai-dao-zhi-nei-cun-yi-zhi-shang-zhang/"},{"title":"vue+ws在刷新页面时使用beforeDestroy无法触发的解决方法","content":"vue的钩子函数beforeDestroy()、destroy() 只是在页面切换的时候触发，并不能监听F5或者网页关闭时的事件。 js种beforeunload事件可以在当前页面刷新或者关闭时调用。 使用： methods:{ // beforeunload对用的方法 beforeunloadFn(e) { if(this.socket) { this.socket.close(); clearInterval(this.heartBeatInterval); this.heartBeatInterval = null; } } }, mounted() { // 初始化socket this.init(); // 给beforeunload添加事件，并监听beforeunload window.addEventListener('beforeunload', e =&gt; this.beforeunloadFn(e)) }, beforeDestroy () { // 当页面切换时关闭监听 window.removeEventListener('beforeunload', e =&gt; this.beforeunloadFn(e)) } ","link":"https://hviker.github.io/post/vuews-zai-shua-xin-ye-mian-shi-shi-yong-beforedestroy-wu-fa-hong-fa-de-jie-jue-fang-fa/"},{"title":"Sass","content":"Sass(css)预处理器的特性 1、变量 使用变量来存储需要再css中复用的信息，使用$去声明一个变量 &lt;style lang='scss' scoped&gt; $bg_color:red; .container{ width: 20px; height: 20px; background-color: $bg_color; } &lt;/style&gt; 2、嵌套 以嵌套的方式使用css，父级元素包子级元素 3、引入 @import '位置/文件名' ： 引入.scss文件，将多个.scss文件合并成一个 可以引入代码片段，也可以引入某个变量 (1) 引入代码片段 ( b中引入a) 可以看出a是可以使用中b的变量。当引入.css时不允许存在变量 ​ a.scss .inter{ width: 10px; height: 10px; background-color:$inter_color1; } ​ b.scss $bg_color:red; $inter_color:green; $inter_color1:blue; .container{ width: 20px; height: 20px; background-color: $bg_color; } .inter1{ width: 10px; height: 10px; background-color:$inter_color; } @import 'a'; (2) 引入变量 此时显示颜色为blue ​ a.scss $inter_color:blue; ​ b.scss $bg_color:red; $inter_color:green; .container{ width: 20px; height: 20px; background-color: $bg_color; } @import 'a'; .inter{ width: 10px; height: 10px; background-color:$inter_color; } 备注：与css3中的引入不同，@import url('a')需要加载；而sass的@import则不需要加载 我们可以将公共变量放在一个.scss中，使样式代码更加清晰 4、混合(Mixin) 用于分组需要在页面中复用的css声明，通过向Mixin传递变量参数让代码更加灵活 声明：@mixin 名字(变量) 调用：@include 名字(数值) 页面： &lt;div class=&quot;divView&quot;&gt;123&lt;/div&gt; 声明 @mixin divStyle($divWidth, $divHeight, $divColor) { width: $divWidth; height: $divHeight; background-color: $divColor } 调用 .divView { @include divStyle(80px, 50px, blue) } 思考：可以用于多浏览器适配，例如 @mixin border-radius($radius) { border-radius: $radius; -ms-border-radius: $radius; -moz-border-radius: $radius; -webkit-border-radius: $radius; } .box { @include border-radius(10px); } 5、继承 使用@extend在选择器之间复用css属性，避免产生冗余代码 公用代码片段使用 % 声明，使用 @extend 继承 // 该代码没有被继承，不会输出到最终的css中 %box-other { border: 1px solid #000; } // 该代码被继承，会输出到最终的css中 %box-common { border: 1px solid green } .box1 { @extend %box-common ; width:50px; height: 50px; } .box2 { @extend %box-common ; width: 100px; height: 200px; } 6、操作符 sass提供了标准的算术运算符，例如 +、-、*、/、%,可以让开发人员更容易将像素转换成百分比 $width:600px; .box1 { width: $width / 1000px * 100%; height: 200px; background-color: $inter_color; } 转换代码 ==》 .box1 { width: 60%; height: 200px; background-color: green; } 7、引用父级 &amp; “&amp;” 会使用父级选择器替换全部出现的位置 伪类选择器使用场景： .container { width: $width; height: $height; background-color: $bg_color; &amp;:hover { background-color: $inter_color } } 当子类元素class的开头是父元素时也可以使用 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;container_divView&quot;&gt;123&lt;/div&gt; &lt;/div&gt; .container { width: $width; height: $height; background-color: $bg_color; &amp;_divView { font-size:20px } } 8、嵌套属性 css许多属性都有相同的命名空间，比如font-family,font-size,font-weight等， scss中只需要编写命名空间一次，后续嵌套的子属性都将位于该命名空间之下 /*===== SCSS =====*/ .demo { // 命令空间后带有冒号: font: { family: fantasy; size: 30em; weight: bold; } } /*===== CSS =====*/ .demo { font-family: fantasy; font-size: 30em; font-weight: bold; } ","link":"https://hviker.github.io/post/sass/"},{"title":"Web Worker","content":"1、介绍 Web Worker,运行在后台的javascript，不占浏览器自身的线程，独立于其他脚本。 通常来讲javascript是单线程的，js处理逻辑与页面渲染走线程，代码会自上而下执行，可以理解为同步。在html中执行js脚本时，在js脚本加载完成之前，页面的状态是不响应的。我们可以将一些复杂逻辑交给web worker在后台执行，相当于是将部分逻辑异步处理，在这段逻辑处理之间页面依然可以响应用户的操作。 web worker有两种类型，一种是专用线程 dedicated web worker，一种是共享线程 shared web worker;专用线程会随着页面的关闭而关闭，只能在创建它的页面访问。而共享线程可以被多个页面访问，一般用于同浏览器下多页面的通信（必须保证同源策略） 2、专用线程在vue的使用 每一个worker对象都是使用构造函数创建的对象。主程序通过worker对象的postMessage(obj)发送数据,可以发送对象；通过worker对象的onmessage(data)接收数据；而子线程worker.js需要设置onmessage(obj) 来接收主程序发送的数据，处理完成之后使用postMessage(data)将处理好的数据发送给主程序。子线程中也有错误信息的监听方法onerror() 以vue-cli 3.x为例子 (1) 需要下载worker-loader,并且在vue.config.js中配置worker.js文件能被读取 chainWebpack(config) { // set worker config.module .rule(&quot;worker.js&quot;) // 读取worker.js结尾的js .test(/\\.worker\\.js$/) // 正则匹配 .use('worker-loader') // 使用worker-loader .loader('worker-loader') .options({ inline: true, name: 'workerName.[hash].js' }) } (2) 创建子线程 webworker.worker.js，设置onmessage、onerror方法 onmessage = function(evt){ //工作线程接收到主线程的消息,处理逻辑 let arr = evt.data let name = ''; arr.forEach(element =&gt; { name = element.name }); //向主线程发送消息 postMessage(name); }; //错误信息 onerror = function (event) { console.log(event.message); } (3) 在主程序中引入子线程，并且创建实例，使用worker对象发送与接收数据 import WorkerSetss from '@/static/webworker.worker.js' this.worker = new WorkerSetss(); //向工作线程发送消息 let arr = []; let obj = {}; obj.name = &quot;小明&quot; obj.id = &quot;1&quot; arr.push(obj) this.worker.postMessage(arr); this.worker.onmessage = function(event) { console.log(event) } 备注： (1) 只能用于单个页面，不能出现跨页面的情况。 (2) 有浏览器的兼容问题。 ","link":"https://hviker.github.io/post/web-worker/"},{"title":"实现同浏览器不同页面下的数据通信","content":"1、项目场景 同浏览器下的两个窗口分别开着项目的两个页面A、B，点击A窗口页面的某个按钮，实现B窗口下页面数据的刷新。 2、实现方案 2.1 使用BroadcastChannel实现 BroadcastChannel ，广播频道，允许统一来源下不同文档(在不同的窗口、选项卡、iframe)之间进行通信。内容发布后，创建该频道的所有文档都能接收到数据。 使用： (1) 创建BroadcastChannel实体，并通过name添加频道唯一标识 (2) 发布消息,使用postMessage(obj)方法 (3) 当结束之后关闭连接，使用close()方法，允许垃圾回收 let channel = new BroadcastChannel('test_channel'); // 创建BroadcastChannel实体，name为test_channel let data = &quot;使用BroadcastChannel实现&quot; channel.postMessage(data) // 发送消息 channel.close(); //关闭连接 (4) 其他页面接收时需要创建相同标识的BroadcastChannel实体，使用onmessage方法 let channel = new BroadcastChannel('test_channel'); channel.onmessage = (event) =&gt;{ console.log(event) this.test = event.data this.handleClick() // 注意，虽然能动态改变另一个浏览器的数据，但是不能触发另一个浏览器的方法 } 备注: (1) 每一种通道可以发布一种或者多种数据，一个页面可以存在多个通道。 (2) 当通道不需要时，需要手动关闭，使用close()，允许垃圾回收 (3) 跨浏览器时有问题。比如chrome中打开一个窗口，IE打开一个窗口，尝试后不能该改变数据 (4) 可以动态修改另一个浏览器的数据并渲染。如果另一个浏览器窗口使用onmessage接收到数据后调用自己的方法，这个方法不会立即触发。只有鼠标点到另一个浏览器后才会触发。 (5) 可以传对象，接收也是对象。接收到对象数组不需要转换。 (6) 需要满足同源策略。 (7) 使用简单，只要初始化实例后，传入相同的频道值，就会被接入到相同得广播频道中。 (8) BroadcastChannel存在浏览器的兼容问题，只支持版本较新的Chrome和Firefox,不支持IE和Safari具体兼容见下图。 BroadcastChannel详细api地址：https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel 2.2 localstorage localstorage 浏览器多个标签公用的存储空间，可以实现多页签之间的通信。(sessionstorage是会话级别的存储空间，用于单页面) 使用： (1) A页面设置locastorage,B页面使用addEventListener去监听localstorage A页面设置： let data = &quot;使用localstorage存储2&quot; window.sessionStorage.setItem(&quot;msg&quot;,data) B页面设置： window.addEventListener(&quot;storage&quot;, (evt) =&gt;{ if(evt.key == 'msg') { console.log(evt.newValue) this.storage_session = evt.newValue } }) 备注： (1) localstorage如果不手动清除是不会消失的，需要手动清除。 (2) 如果B页面打开，B页面会监听到所有“storage”变化的数据，evt中有对应storage的key ，可以进行针对性的判断。当localstorage的某值比较上一次没有变化时，即使set也不会触发。当自身页面通过set设置localstorage的值的时候，并不能监听。 (3) localstorage默认存储的是字符串，对于json数据需要使用stringfiy()、parse()方法；对于[[]]需要通过代码进行数据转换。如果数据量较大会出现页面卡死的情况。 2.3 cookie + setInterval cookie,当一个页面设置cookie后，能被另一个页面访问。代码实现上需要监听cookie的数据变化，然后再设置响应 setInterval(() =&gt;{ // 获取cookie }, 1000) 备注： (1) cookie存储空间有限，存储内容少 (2) 定时需要考虑时间上的设置，时间过大影响时效性，时间过小影响浏览器使用。不推荐使用。 2.4 SharedWorker web worker中的共享线程。相比于专线线程，可以用于同浏览器下多页面的通信。使用上对VUE页面 下一篇 Sass ","link":"https://hviker.github.io/post/shi-xian-tong-liu-lan-qi-bu-tong-ye-mian-xia-de-shu-ju-tong-xin/"},{"title":"SpringBoot下实现原生Websocket","content":"1、pom.xml中引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 2、开启对Websocket的支持 @Configuration public class WebSocketConfigs { @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } 3、封装server package com.jxdinfo.gdjf.train.websocketOrigin; import com.jxdinfo.gdjf.train.proto.HeartBeatClass; import org.springframework.stereotype.Component; import javax.websocket.*; import javax.websocket.server.PathParam; import javax.websocket.server.ServerEndpoint; import java.io.IOException; import java.util.concurrent.CopyOnWriteArraySet; @ServerEndpoint(&quot;/websocket&quot;) @Component public class WebSocketServer { //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。 private static int onlineCount = 0; //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。 private static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketServer&gt;(); //与某个客户端的连接会话，需要通过它来给客户端发送数据 private Session session; //接收sid private String sid=&quot;&quot;; /** * 连接建立成功调用的方法 */ @OnOpen public void onOpen(Session session) { this.session = session; webSocketSet.add(this); //加入set中 addOnlineCount(); //在线数加1 this.sid=sid; try { sendMessage(&quot;连接成功&quot;); } catch (IOException e) { System.out.print(e); } } /** * 连接关闭调用的方法 */ @OnClose public void onClose() { webSocketSet.remove(this); //从set中删除 subOnlineCount(); //在线数减1 System.out.print(&quot;有一连接关闭！当前在线人数为&quot; + getOnlineCount()); } /** * 收到客户端消息后调用的方法 * @param message * @param session */ @OnMessage public void onMessage(String message, Session session) { System.out.print(&quot;收到来自窗口&quot; + sid + &quot;的信息:&quot;); //群发消息 for (WebSocketServer item : webSocketSet) { try { item.sendMessage(message); } catch (IOException e) { e.printStackTrace(); } } } /** * 错误处理 */ @OnError public void onError(Session session, Throwable error) { System.out.print(&quot;发生错误&quot;); error.printStackTrace(); } /** * 实现服务器主动推送 */ public void sendMessage(String message) throws IOException { this.session.getBasicRemote().sendText(message); } /** * 消息群发自定义 * @param message * @param * @throws IOException */ public static void sendInfo(String message) throws IOException { System.out.print(&quot;推送消息到窗口&quot;+ &quot;推送内容:&quot;+message); } public static synchronized int getOnlineCount() { return onlineCount; } public static synchronized void addOnlineCount() { WebSocketServer.onlineCount++; } public static synchronized void subOnlineCount() { WebSocketServer.onlineCount--; } public static CopyOnWriteArraySet&lt;WebSocketServer&gt; getWebSocketSet() { return webSocketSet; } } ","link":"https://hviker.github.io/post/springboot-xia-shi-xian-yuan-sheng-websocket/"},{"title":"VUE+Websocket+Protobuf","content":"1、项目场景 监控某工程状态变化，将后台推送信息解析并实时展示，推送数据量较大。 2、使用技术 vue+websocket+protobuf 3、技术介绍 Websocket 通信协议,基于tcp。与http协议不同，http是短连接，浏览器给服务端发送请求时开始，服务端接收处理响应后关闭，而且http协议只能由浏览器端发起，服务端无法直接推送。而ws是一个长连接，在vue的单个页面中，从页面创建(或者调用ws初始化方法)时开始，在当前页面关闭时结束。如果想要在整个项目中通用一个ws,可以将ws的触发放在app.vue上。ws可以实现浏览器端和服务端的双向通信，消息可以是文本也可以是二进制流数据(blob)，不存在跨域问题。使用ws就可以实现后台主动向前端推送数据，保证数据的实时渲染。 protobuf protobuf是一种与语言无关、平台无关、可扩展的序列化数据结构，可以用于数据通信、数据存储。序列化是指将数据结构或者对象转换成能够被存储和传输的格式，同时保证序列化的结果在另一种环境中能够被重建回原来的数据或者对象。相比于XML、JSON，protobuf更加高效，适用于数据量较大的场景。 4、前端websocket实现 这里提供两种ws实现方式：原生ws、借助stompJS实现ws，两者差距在于后台ws的使用。如果后台使用的是Spring底层及的Websocket API,就使用原生的ws,如果后台启用了SockJS通信，就使用借助stompJS实现ws。需要注意的是，原生的ws在由浏览器端向后台发送数据时，后台支持接收的数据类型有String,ArrayBuffer、Blob、ArrayBufferView，但是借助stompJS的实现方式只支持发送String。 原生ws实现 &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;&quot;, components: {}, props: [], data() { return { path: &quot;ws://127.0.0.1:8085/binaryHandler&quot;, // socket连接地址 socket: &quot;&quot;, // socket对象 }; }, watch: {}, computed: {}, methods: { init() { // 判断浏览器是否支持socket if (typeof WebSocket === &quot;undefined&quot;) { this.$message({ message: &quot;您的浏览器不支持socket&quot;, type: &quot;warn&quot; }); } else { // 实例化socket this.socket = new WebSocket(this.path); // 监听socket连接 this.socket.onopen = this.open; // 监听socket错误信息 this.socket.onerror = this.error; // 监听socket推送消息 this.socket.onmessage = this.getMessage; } }, open() { console.log(&quot;socket连接成功&quot;); }, error() { console.log(&quot;连接错误&quot;); }, getMessage(msg) { console.log(msg) }, send() { this.socket.send(&quot;数据发送&quot;); }, close() { console.log(&quot;socket已关闭&quot;); } }, created() {}, mounted() { this.init(); }, destroyed() { this.socket.close = this.close; } }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; &lt;/style&gt; 基于stompJS实现 &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import SockJS from &quot;sockjs-client&quot;; import Stomp from &quot;stompjs&quot;; import heartBeat from &quot;@/proto/HeartBeat_pb&quot;; export default { name: &quot;SocketLink&quot;, components: {}, props: [], data() { return { socketDir: &quot;http://127.0.0.1:8085/gs-guide-websocket&quot;, // socket连接地址 stompClient: null, // STOMP子协议的客户端对象 sendUrl: &quot;/app/hello&quot;, // 发送数据通道 receiveUrl: &quot;/topic/greetings&quot; // 接收数据通道 }; }, watch: {}, computed: {}, methods: { // socket创建连接 initWebSocket() { // 建立连接对象 let socket = new SockJS(this.socketDir); this.stompClient = Stomp.over(socket); // 获取STOMP子协议的客户端对象 this.connection(); }, connection() { // 定义客户端的认证信息,按需求配置 let headers = {}; // 向服务器发起websocket连接 this.stompClient.connect( headers, () =&gt; { this.stompClient.subscribe( this.receiveUrl, msg =&gt; { // todo 对数据处理 let data = msg; }, headers ); }, err =&gt; { // 连接发生错误时的处理函数 console.log(err); } ); }, // 断开连接 disconnect() { if (this.stompClient) { this.stompClient.disconnect(); } }, // 发送数据 sendMessage() { let msg = &quot;aaa&quot;; // 这里只支持发送string类型 this.stompClient.send(this.sendUrl, {}, msg); } }, created() {}, mounted() { this.initWebSocket(); } }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; &lt;/style&gt; 5、前端protobuf数据处理 这里提供两种protobuf数据处理方式，借助google-protobuf、借助protobufJS。借助于StompJS的ws的实现后台不能接收arraybuffer数据类型，这里仅配合后台原生ws的实现。 借助google-protobuf (1) 使用npm下载 google-protobuf。 npm install google-protobuf -S (2) 由于是在vue中使用，建议将后台提供的proto转化成js。后台提供的proto文件类似于以下格式： syntax = &quot;proto3&quot;; option java_package = &quot;com.train.proto&quot;; option java_outer_classname = &quot;HeartBeatClass&quot;; message HeartBeat { int32 heart =1; int32 time =2; int32 ids =3; int64 requestInfo =4; } 在命令行执行下面代码，转化成js文件 protoc.exe --js_out=import_style=commonjs,binary:. xxx.proto (3) google-protobuf提供了序列化和反序列化的方法，可以实现对二进制数据的处理 &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import heartBeat from &quot;@/proto/HeartBeat_pb&quot;; export default { name: &quot;&quot;, components: {}, props: [], data() { return { path: &quot;ws://127.0.0.1:8085/binaryHandler&quot;, // socket连接地址 socket: &quot;&quot;, // socket对象 }; }, watch: {}, computed: {}, methods: { init() { // 判断浏览器是否支持socket if (typeof WebSocket === &quot;undefined&quot;) { this.$message({ message: &quot;您的浏览器不支持socket&quot;, type: &quot;warn&quot; }); } else { // 实例化socket this.socket = new WebSocket(this.path); // 监听socket连接 // 监听socket错误信息 this.socket.onerror = this.error; // 监听socket推送消息 this.socket.onmessage = this.getMessage; } }, open() { console.log(&quot;socket连接成功&quot;); }, error() { console.log(&quot;连接错误&quot;); }, getMessage(msg) { // websocket server 返回的是blob let result = msg.data; if (result instanceof Blob) { // 对blob数据进行处理 let reader = new FileReader(); reader.readAsArrayBuffer(result); reader.onload = ()=&gt;{ const buf = new Uint8Array(reader.result); // 反序列化 let decodeMsg = heartBeat.HeartBeat.deserializeBinary(buf); // 获取数据，使用getXXX(); let requestInfo = decodeMsg.getRequestinfo() } } }, send() { if(this.socket === &quot;&quot;) return; // 创建heart对象 const heart = new heartBeat.HeartBeat(); // 赋值,使用setXXX heart.setHeart(100); heart.setTime(150); heart.setIds(200); heart.setRequestinfo(250); // 序列化 const hearts = heart.serializeBinary(); this.socket.send(buf); }, close() { console.log(&quot;socket已关闭&quot;); } }, created() {}, mounted() { this.init() }, destroyed() { this.socket.close = this.close; } }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; &lt;/style&gt; 关于google-protobuf的详细介绍见官网:https://www.npmjs.com/package/google-protobuf 借助于protobufJS (1) 使用npm下载 protobufJS。 npm install protobufjs -S； (2) 同样推荐将proto文件转化成js文件 在项目跟目录下执行，A：生成js文件存放位置 B:需要生成js的proto文件 npx pbjs -t json-module -w commonjs -o A B 例如： npx pbjs -t json-module -w commonjs -o src/proto/HeartBeat.js src/proto/HeartBeat.proto (3) protobufJS提供方法较多，lookup、encode、decode等 &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import heartBeatOth from &quot;@/proto/HeartBeat&quot; export default { name: &quot;&quot;, components: {}, props: [], data() { return { path: &quot;ws://127.0.0.1:8085/binaryHandler&quot;, // socket连接地址 socket: &quot;&quot;, // socket实例 heartOther: &quot;&quot;, // heartBeatOth对象 }; }, watch: {}, computed: {}, methods: { init() { // 判断浏览器是否支持socket if (typeof WebSocket === &quot;undefined&quot;) { this.$message({ message: &quot;您的浏览器不支持socket&quot;, type: &quot;warn&quot; }); } else { // 实例化socket this.socket = new WebSocket(this.path); // 监听socket连接 this.socket.onopen = this.open; // 获取消息类型 this.heartOther = heartBeatOth.lookup(&quot;HeartBeat&quot;); // 监听socket错误信息 this.socket.onerror = this.error; // 监听socket推送消息 this.socket.onmessage = this.getMessage; } }, open() { console.log(&quot;socket连接成功&quot;); }, error() { console.log(&quot;连接错误&quot;); }, getMessage(msg) { // websocket server返回的是blob let result = msg.data; if (result instanceof Blob) { // 对blob进行处理 let reader = new FileReader(); reader.readAsArrayBuffer(result); reader.onload = ()=&gt;{ const buf = new Uint8Array(reader.result); let decodeMsg = this.heartOther.decode(buf); let { requestInfo } = decodeMsg; } } }, send() { if(this.socket === &quot;&quot;) return; // 传递内容 let cont = { heart: 100, time: 150, ids: 200, requestInfo: 250 } // 验证内容是否有效 let errMsg = this.heartOther.verify(cont); if(errMsg) throw Error(errMsg); // 创建消息实体 let message = this.heartOther.create(cont); // 将消息实体编码成Uint8Array let buf = this.heartOther.encode(message).finish(); this.socket.send(buf); }, close() { console.log(&quot;socket已关闭&quot;); } }, created() {}, mounted() { this.init(); }, destroyed() { this.socket.close = this.close; } }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; &lt;/style&gt; 关于google-protobuf的详细介绍见官网:https://www.npmjs.com/package/protobufjs 补充 (1) 使用axios对接收protobuf数据的处理。需要修改content-type, responseType import Vue from 'vue' import axios from 'axios' const protoSer = axios.create({ timeout: 60000, headers: { 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/x-protobuf;charset=UTF-8' }, responseType: 'arraybuffer' }) Vue.prototype.$protoSer = protoSer export default protoSer (2) 使用google-protobuf、protobufJS在数据反序列化、序列化、获取数据上的打印结果 google-protobuf反序列化 protobufJS反序列化 google-protobuf序列化 protobufJS序列化 google-protobuf获取数据 protobufJS获取数据 ","link":"https://hviker.github.io/post/vuewebsocketprotobuf/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://hviker.github.io/post/hello-gridea/"}]}