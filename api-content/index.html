{"posts":[{"title":"dm8安装、卸载、创建实例、启动服务、可视化工具连接","content":" 环境：docker拉取的centos7镜像(aarch64) 内容：完成达梦数据库(DM8)安装、卸载，数据库实例创建，服务注册，生成新镜像、以及使用DataGrip连接dm8等操作 1、基础配置 centos7。本人从docker中拉取的centos镜像为arm架构(aarch64)，与linux服务器差别不大。 centos7镜像中中安装好wget、unzip、xhost、firewalld等指令。 新建安装包并添加用户、权限、环境变量等。 在/opt下新建dmdbms文件夹，并新建用户组、用户、修改用户密码、规划权限 mkdir /opt/dmdbms 使用root角色，给文件夹添加写入操作 chmod 777 /opt/dmdbms 新建用户组 groupadd dinstall 新建用户 useradd -g dinstall dmdba 修改密码 passwd dmdba 查看dmdbms权限、用户及文件大小 ls -dl /opt/dmdbms/ 将指定文件的拥有者改为指定的用户和组 chown dmdba.dinstall -R /opt/dmdbms/ 再次运行上面ls -dl命令，确认是否更改 配置环境变量 vi ~/.bash_profile 添加path export DM_HOME=/opt/dmdbms export PATH=$DM_HOME/bin:$DM_HOME/tool:$PATH:$HOME/bin 编译文件 source ~/.bash_profile 测试是否成功 echo $DM_HOME 2、运行安装好的centos7镜像 这里建议以管理员身份运行，centos镜像有防火墙，使用管理员登录可以在安装、连接的时候随意关闭 docker run --privileged=true centos_dev /usr/sbin/init docker exec -it tender_haibt /bin/bash 3、关闭防火墙 查看防火墙状态 systemctl status firewalld 关闭防火墙状态 systemctl stop firewalld 4、下载达梦数据库 去达梦数据库官网下载，地址：https://www.dameng.com/ucenter/docs.html 本人从docker中拉取的centos7镜像为arm架构(aarch64)，不确定的可以使用lscpu指令确认。DM8开发版-飞腾能够在该架构上安装运行。 DM8开发版-飞腾下载地址：https://package.dameng.com/official/DM8/DM8_20210709_飞腾_麒麟_64位.zip 将压缩包下载到/opt中： wget https://package.dameng.com/official/DM8/DM8_20210709_飞腾_麒麟_64位.zip /opt/ 5、解压数据库 在/opt下执行命令 mkdir dmpackage unzip -o DM8_20210709_飞腾_麒麟_64位.zip -d dmpackage/ 6、挂载解压包中的.iso文件 使用mount -o loop挂载文件到指定位置 mkdir /mnt/dm8 mount -o loop /opt/dmpackage/dm8_20210709_FTarm_kylin_64_ent_8.1.2.38.iso /mnt/dm8/ 出现上图说明挂载成功 7、安装数据库 进入 /mnt/dm8,切换为dmdba用户 su - dmdba 执行命令 使用图形化安装./DMInstall.bin报错，这里需要安装全局安装libXtst、org-x11-fonts-Type1、gtk2 yum -y install gtk2 libXtst xorg-x11-fonts-Type1 继续安装，提示 运行xhost +, 提示 xhost + 继续运行，修改文件并重新生效 vi /etc/profile export DISPLAY=:0.0 source /etc/profile 还是报错timeout,欲哭无泪，猜测可能和镜像有关系。最后使用指令行进行安装 ./DMInstall.bin -i 按照提示进行安装，最后提示安装完成 以root用户执行 /opt/dmdbms/script/root/root_installer.sh 提示Job for DmAPService.service failed because a timeout was exceeded. See &quot;systemctl status DmAPService.service&quot; and &quot;journalctl -xe&quot; for details. 官网提示可以忽略。官网安装部署常见问题地址：https://eco.dameng.com/docs/zh-cn/faq/faq-dm-install.html 8、删除数据库 这里使用指令行进行删除，在dmdbms文件夹中运行指令 ./uninstall.sh -i 9、创建数据库实例 在bin目录下，运行指令./dminit help能看所有配置项 以下命令设置页大小为 32 KB，簇大小为 32 KB，大小写敏感，字符集为 utf_8，数据库名为 DMDB，实例名为 DBSERVER，端口为 5237。 ./dminit path=/opt/dmdbms/example PAGE_SIZE=32 EXTENT_SIZE=32 CASE_SENSITIVE=y CHARSET=1 DB_NAME=DMDB INSTANCE_NAME=DBSERVER PORT_NUM=5237 10、注册服务 需要使用root用户注册服务。 进入/script/root后，运行 ./dm_service_installer.sh -t dmserver -dm_ini /opt/dmdbms/example/DMDB/dm.ini -p DMSERVER 11、启动、停止、查看数据库服务 启动服务，这种方式在镜像中报错timeout，猜测还是和镜像有关系。 systemctl start DmServiceDMSERVER.service bin目录下执行 ./DmServiceDMSERVER start 查看连接状态 ./DmServiceDMSERVER status 关闭连接 ./DmServiceDMSERVER stop 12、生成新镜像 docker commit xxx centos_dev_dm 生成新镜像后，以管理员身份启动新镜像，并打开5237端口，允许外部访问。这里以管理员身份启动，主要是为了关闭防火墙。否则外部访问不到端口。 docker run -p 5237:5237 --privileged=true centos_dev_dm /usr/sbin/init docker exec -it xxx bash 13、使用DataGrip连接dm8 mac好像只能使用DataGrip来连接dm8，有点难受。 下载DataGrip，点击加号,添加dm8连接配置 这里需要添加驱动，dm8就引入dm8的驱动,点击OK. 重新点击加号，选择Database，输入连接信息，点击test connection提示成功后就可以愉快地使用了。 14、参考 达梦数据库安装：https://eco.dameng.com/docs/zh-cn/start/install-dm-linux-prepare.html ","link":"https://hviker.github.io/post/dm8-an-zhuang-xie-zai-chuang-jian-shi-li-qi-dong-fu-wu-ke-shi-hua-gong-ju-lian-jie/"},{"title":"桌面通知 Notification API","content":"1、介绍 Notification 是H5新增的桌面通知API，用于向用户通知信息，即使用户没有停留在当前标签页，甚至是最小化了浏览器，该通知信息也会置顶显示出来。 2、用户权限 需要获取到用户权限后才能向用户显示。 Notification.permission 该属性用户表明当前通知显示的授权状态，值包括： default: 不知道用户的选择，默认。 granted: 用户允许。 denied: 用户拒绝。 if(Notification.permission === 'granted'){ console.log('用户允许通知'); }else if(Notification.permission === 'denied'){ console.log('用户拒绝通知'); }else{ console.log('用户还没选择，去向用户申请权限吧'); } 3、请求权限 当不知道用户选择时，我们需要向用户请求权限。Notification提供了requestPermission() 方法请求用户当前来源的权限以显示通知。 Notification.requestPermission().then(permission =&gt; { if(permission === 'granted'){ console.log('用户允许通知'); }else if(permission === 'denied'){ console.log('用户拒绝通知'); } }) 4、推送通知 当获取用户权限后就可以推送通知了。 var notification = new Notification(title, options); title: 要显示的标题 options: 通知的设置选项(可选) body: 通知的内容。 tag: 代表通知的一个识别标签，相同tag时只会打开同一个通知窗口。 icon:要在通知中显示的图标的URL。 image: 要在通知中显示的图片的URL。 data：想要和通知关联的任务类型的数据。 requireInteration: 通知保持有效不自动关闭，默认为false。 var notification = new Notification(NOTIFICATION_TITLE, { body: NOTIFICATION_BODY, icon: 'http://img18.house365.com/newcms/2017/03/16/148964317858ca26aacf7b5.jpg', data: { url: 'https://www.baidu.com/' } requireInteraction: true, // 不自动关闭通知 }) 5、关闭通知 获取notification实例后，调用.close(); 6、事件触发及data方法获取 var notification = new Notification(NOTIFICATION_TITLE, { body: NOTIFICATION_BODY, icon: 'http://img18.house365.com/newcms/2017/03/16/148964317858ca26aacf7b5.jpg', requireInteraction: true, // 不自动关闭通知 data: { url: 'https://www.baidu.com/' } }).onclick = () =&gt; { window.open(notification.data.url, '_blank'); notification.close(); } 7、兼容 不兼容IE，其他的PC端浏览器几乎全支持。 移动端浏览器不支持。 8、显示 这里以mac为例 9、应用场景 消息推送 ","link":"https://hviker.github.io/post/zhuo-mian-tong-zhi-notification-api/"},{"title":"解决vue2.x 跳转报错Redirected when going from \"/xxx\" to \"/XXXX\" via a navigation guard.的问题","content":"高版本vue-router在跳转时会有报错。 解决：在router.js中添加代码 const originalPush = Router.prototype.push Router.prototype.push = function push(location, onResolve, onReject) { if (onResolve || onReject) { return originalPush.call(this, location, onResolve, onReject) } return originalPush.call(this, location).catch((err) =&gt; err) } ","link":"https://hviker.github.io/post/jie-jue-vue2x-tiao-zhuan-bao-cuo-redirected-when-going-from-xxx-to-xxxx-via-a-navigation-guardde-wen-ti/"},{"title":"layui扩展内置模块","content":"将公共代码提取，并以layui模块规范要求进行编写，封装成layui扩展模块，方便页面调用。 1、扩展模块定义 // commonSearch.js layui.define(['jquery', 'form', 'laydate'], function (exports) { var commonSearch = { getPersonIdentity: function() { // todo }, getTljDictory: function() { // todo }, // todo } exports('commonSearch', commonSearch) }) 使用layui.define()定义模块，其中jquery,form, laydate都是已经存在于layui中的内置模块，可以在该扩展组件中使用。 这里定义了commonSearch对象，然后通过exports抛出变量。 2、注册 // layui.baseExtend.js layui.config({ base: '/static/' , version: '20190927' }).extend({ commonSearch: &quot;assets/js/commonSearch&quot; }) 使用layui.config().extend({...})进行多个内置模块的注册。 base: 定义公共目录前缀，commonSearch的真实路径为/static/assets/js/commonSearch.js。 extend():以对象的形式声明抛出模块的使用名称以及模块文件对应路径。 官网中也可以使用use方法加载合并模块后的入口文件。 3、使用 在script引入layui.js后引入layui.baseExtend.js &lt;script src=&quot;/static/assets/lib/layui2.4.5/layui.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/static/assets/js/layui.baseExtend.js&quot;&gt;&lt;/script&gt; 模块化引入使用 layui.use(['layer','table','commonSearch'], function(){ // todo }) ","link":"https://hviker.github.io/post/layui-kuo-zhan-nei-zhi-mo-kuai/"},{"title":"shim 预置依赖","content":"1、使用场景 ​ 1.1 将一些第三方库作为全局依赖，例如jquery中的$, lodash中的_ ​ 1.2 使用polyfill扩展浏览器能力，来支持更多的语法。 2、预置全局依赖 例如我们要引入lodash-es，我们需要使用到webpack的ProvidePlugin()。在webpack.config,js中设置： const webpack = require('webpack'); module.exports = { plugins: [ new webpack.ProvidePlugin({ _:'lodash-es', join: ['lodash-es', 'join'] }), ] } 这里我们可以将整个lodash-es定义为-, 将其join()定义为join。这样在代码编译过程中，遇到- 或者 join就回去使用lodash-es。 不建议使用全局依赖。使用全局依赖后，bundle中会整个引入第三方库，无法优化bundle打包方式。而且前端的模块化开发要求模块之间彼此隔离，不依赖于全局变量。 3、全局export ​ 将某些不支持模块化规范的模块所声明的全局变量导出。使用exports-loader。 npm install exports-loader --save-dev webpack中配置 module.exports = { module: { rules: [ { test: path.resolve(__dirname, 'src/globals.js'), use: &quot;exports-loader?file,parse=helpers.parse&quot; }, ], }, } 这里使用exports-loader指定/src/globals.js，将file导出为file，helpers.parse导出为parse。 globals.js var file = 'blah.txt' var helpers = { test: () =&gt; { console.log('test') }, parse: () =&gt; { console.log('parse') } } index.js import { file, parse } from './globals.js' function components() { var dom = document.createElement('p'); dom.innerHTML = _.join(['123', 'webpack'], ' '); var bar = document.createElement('br'); dom.appendChild(bar); console.log(file); parse(); return dom; } document.body.appendChild(components()); 上面demo可以看到,globals.js是不符合模块化规范的，只是定义了几个全局变量，正常情况下无法在index.js中使用import()。 通过exports-loader将globals.js导出并声明，这样就可以实现在全局内引用。 4、babel-polyfill babel默认只转换新的js语法，但是不转换新的API，比如Map、Set、Promise，以及一些定义在全局对象上的方法，比如Array.from。如果想让这个方法运行，必须使用babel-polyfill,为当前环境提供一个垫片。 polyfill指的是&quot;用于实现浏览器不支持原生功能的代码&quot;。比如对于不支持fetch函数的浏览器，需要在网页引入对应fetch的polyfill。然后这个polyfill就给window对象添加了一个fetch函数。 npm install babel-polyfill --save 这里使用 --save而不是--save-dev，因为我们需要babel-polyfill在源代码之前运行，需要它成为一个dependencies,而不是一个devDependencies。 然后在index.js最上面引入 import 'babel-polyfill' 对于fetch npm install --save whatwg-fetch import 'babel-polyfill'; import 'whatwg-fetch'; shim/polyfill必须运行于所有其他代码之前，而且需要同步加载。下载第三方包是需要--save 而不是 --save-dev ","link":"https://hviker.github.io/post/shim-yu-zhi-yi-lai/"},{"title":"webpack-bundle-analyzer使用","content":"1、作用 webpack的可视化资源分析工具。查看项目中各模块文件大小、定位模块包含内容，也能看到使用gzip压缩后的模块大小，进而对模块进行优化。 2、安装及配置 npm install --save-dev webpack-bundle-analyzer const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; module.exports = { plugins: [ new BundleAnalyzerPlugin({ analyzerMode: 'server', analyzerHost: '127.0.0.1', analyzerPort: '8888', logLevel: 'info' }), ] } package.json中设置 &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --open --config webpack.dev.js&quot;, &quot;prod&quot;: &quot;webpack --config webpack.prod.js&quot;, &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;start&quot;: &quot;webpack-dev-server --open&quot;, &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;, &quot;server&quot;: &quot;node server.js&quot;, &quot;analysis&quot;: &quot;NODE_ENV=production npm_config_report=true npm run prod&quot; }, 细节查看：https://www.npmjs.com/package/webpack-bundle-analyzer ","link":"https://hviker.github.io/post/webpack-bundle-analyzer-shi-yong/"},{"title":"代码分离","content":"1、splitChunks 使用SplitChunksPlugin 插件可以将公共的依赖模块提取到已有的 entry chunk 中，或者提取到一个新生成的 chunk。 optimization: { splitChunks: { chunks: &quot;all&quot; } } 2、动态导入 btn.onclick = e =&gt; import(/* webpackChunkName: &quot;print&quot; */ &quot;./print&quot;).then(module =&gt; { var print = module.default; print(); }) 推荐使用import() 实现动态引入。 使用动态引入时，不需要在entry设置bundle入口，在output中设置chunkFilename，它决定了非入口chunk名称。 output: { chunkFilename: '[name].lazybundle.js', } 我们在import中使用了注释，注释中提供了webpackChunkName,这样会拆分出来命名为print.lazybundle.js的bundle。import() 会返回一个promise，所以需要.then()进行后续操作。这里也可使使用async、await来实现同步效果。 当调用import()方法引用模块时，必须指向模块的.default值，因为它才是promise被处理后返回的实际的module对象。 3、预取、预加载模块(prefetch、preload) 预取(prefetch)：表示用户在接下来的浏览中可能会用到对应的资源，提示浏览器在空闲的时候获取对应资源。获取资源后不解析。 会生成以下代码并追加到头部，告诉浏览器在闲置时间加载...bundle.js &lt;link rel=&quot;prefetch&quot; href=&quot;...bundle.js&quot; /&gt; 预加载(preload): 下载资源后解析文件。 预取与预加载区别 prefetch preload 与父chunk执行顺序 父chunk加载完成后才进行加载 在父chunk加载时进行加载 在浏览器中执行时间 浏览器闲置时加载 在父chunk加载时立即执行 4、懒加载 将后续执行的代码从源代码中分离出来，在需要触发时再引入执行。具体见上述动态引入的例子。 ","link":"https://hviker.github.io/post/dai-ma-fen-chi/"},{"title":"缓存 ","content":"浏览器可以使用缓存技术来降低网页流量，从而使网站加载速度更快。 但是我们在部署新版本时如果不更改资源名称，浏览器很可能认为资源没有被更新从而使用缓存版本。 我们可以通过配置，确保webpack编译生成的文件能被浏览器缓存，而文件内容发生变化后可以请求到新的文件。 1、可替换模板字符串（substitution） 利用[contenthash]可以根据资源内容创建出唯一的hash。当资源发生变化时，文件名称就会发生变化。 module.exports = { output: { filename: &quot;[name].[contenthash].js&quot;, }, } 2、提取引导模板(runtime) 使用optimization.runtimeChunk将runtime代码拆分出一个独立的chunk，将其设置为single来为所有的chunk创建一个runtime bundle。 用于webpack优化。 optimization: { runtimeChunk: &quot;single&quot;, } 3、提取第三方库 一些第三方库很少修改，可以将第三方库提取到vendor chunk中。 这样可以利用浏览器的偿还村机制，命中缓存来消除请求，并减少向server获取资源。 通过设置splitChunks.cacheGroups进行设置。 optimization: { splitChunks: { cacheGroups: { vendor: { test: /[\\\\/]node_modules[\\\\/]/, name: 'vendors', chunks: 'all' } } } } 4、模块标识符 上面的代码中我们已经将chunk分为了app.[hash].js、runtime.[hash].js、vendor.[hash].js。其中vendor chunk主要是第三方库，我们希望能够利用浏览器缓存机制缓存起来提升页面的加载速度。但是目前每次打包后vendor.[hash].js的名称都会发生变化。 app: 当自身内容修改后会发生变化 runtime（manifest） ：当新增bundle时发生变化，比如在entry中新增入口，或者使用动态引入等。只要bundle出现修改就会发生变化。 vendor: 随自身module.id的变化而变化。webpack打包时module.id使用自增长数字，当有新增|删除module模块时，module.id就会发生变化。 我们在这里不希望module.id发生变化，使用webpack提供的 HashedModuleIdsPlugin，用于生产环境构建。 const webpack = require(&quot;webpack&quot;); module.exports = { plugins: [ new webpack.HashedModuleIdsPlugin() ] } 这里是对module.id进行固定。如果对chunk.id固定需要自定义插件，参考：https://zhuanlan.zhihu.com/p/34110535 ","link":"https://hviker.github.io/post/huan-cun/"},{"title":"tree shaking","content":"1、原理 ​ tree shaking是基于es module的静态分析，在编译期间就确定了模块(module)使用情况，并且配合解构赋值能够确定module中哪些方法用到了，哪些没有用到。然后对用到的和没用到的进行标记，在压缩阶段删除没有用到的部分。 2、作用 删除项目中没有用到的代码，有针对性的优化代码来达到最小的bundle size。 3、基本使用 开发环境下 webpack.config.js设置mode、optimization.usedExports、devtool属性。 module.exports = { mode: 'development', optimization: { usedExports: true }, devtool: 'inline-source-map', entry: { app: &quot;./src/index.js&quot;, }, ... } 这里设置devtool为inline-source-map主要是为了以源代码的方式查看export使用情况。对于未使用的export，optimization.usedExports会添加unused harmony export square的注释 正式环境 webpack.config.js设置mode、optimization.usedExports、devtool属性。 module.exports = { mode: 'production', optimization: { usedExports: true }, devtool: '(none)', } mode设置为production后会开启压缩模式，查找压缩后代码中也只是引入了使用的代码。 4、使用tree shaking的注意事项 使用es module的模块规范，使用解构赋值。 tree shaking是机遇es module的静态分析，所以代码必须使用esm规范。我们在业务代码中一般都会基于esm规范，但是对于第三方的插件不一定，部分第三方插件基于commonJS规范。 开启optimization.usedExports属性。 optimization: { usedExports: true }, 该属性主要是用于产生标记，标记哪些export使用到了，哪些export没有被使用到。 使用压缩插件。 webpack4+ 直接将mode设置为production即可开启压缩。 tree shaking只能做到export级别。 如果模块导出一个对象，我们在使用时可能只使用到了对象中的几个属性或者方法，这时候是不能被tree shaking作用的。 为了更好地配合tree shaking，我们在编码过程中尽量不要export出对象使用，这样能够保证tree shaking打包成最小的bundle。 不需要tree shaking的模块，可以在package.json中添加sideEffects进行配置。 如果所有的模块都不包含副作用，可以直接将该属性设置为false，来告诉webpack可以安全删除未用到的export。 如果有些模块有副作用，我们不想让webpack去删除这些export，可以在sideEffects中提供一个数组 { &quot;name&quot;: &quot;your-project&quot;, &quot;sideEffects&quot;: [ &quot;./src/some-side-effectful-file.js&quot;, &quot;*.css&quot; ] } 注意，所有导入文件都会受到 tree shaking 的影响。这意味着，如果在项目中使用类似 css-loader *并 import 一个 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除。 5、使用lodash-es 代替 lodash 我们在项目中可能会使用到lodash的一些功能，进而引入了整个lodash,而lodash是基于commonJS的第三方包，即使使用解构赋值也不会触发tree shaking，导致打包的bundle体积会大很多。 这里推荐使用lodash-es，lodash-es所提供的api与lodash相同，是基于ESM规范的。这里使用解构赋值的方式仅引入使用到的接口，很大程度上减小构建的bundle体积。 ","link":"https://hviker.github.io/post/tree-shaking/"},{"title":"模块热替换","content":"webpack的模块热替换功能，简称HMR，允许在运行时更新各模块而无需对网页进行刷新。 webpack-dev-server中提供了模块热替换功能，只需要将hot属性设置为true即可使用。 只用于开发环境。 demo： webpack.config.js const path = require(&quot;path&quot;); const HtmlWebpackPlugin = require('html-webpack-plugin'); const { CleanWebpackPlugin } = require('clean-webpack-plugin'); const { WebpackManifestPlugin } = require('webpack-manifest-plugin'); module.exports = { mode: 'development', entry: { app: &quot;./src/index.js&quot;, }, devtool: 'eval-source-map', devServer: { contentBase: path.join(__dirname, 'dist'), port: 9000, compress: true, // hot: true }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ title: '管理输出' }), new WebpackManifestPlugin() ], output: { filename: &quot;[name].bundle.js&quot;, path: path.resolve(__dirname, &quot;dist&quot;), publicPath: '/' }, module: { rules: [ { test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;], }, { test: /\\.(png|svg|jpe?g|gif)$/, use: [ { loader: &quot;url-loader&quot;, options: { limit: 35840, name: '[name]_[hash:7].[ext]', outputPath: '/images/', publicPath: 'images/' } }, ], }, { test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'url-loader' ] } ], }, }; index.js import _ from 'loadsh'; import './style.css' import Icon from './image/icon.png'; import printMe from './print' function component() { let element = document.createElement('div'); let btn = document.createElement('button'); element.innerHTML = _.join(['Hello', 'webpack'], ' '); element.classList.add('hello'); btn.innerHTML = 'printMe'; btn.onclick = printMe; element.appendChild(btn) return element; } document.body.appendChild(component()); print.js export default function printMe() { let appendDiv = document.createElement('div'); appendDiv.classList.add('divStyle') document.body.appendChild(appendDiv) } style.css @font-face { font-family: 'GraublauWeb'; src: url('./font/GraublauWeb.woff.ttf'); font-weight: 400; font-style: normal; } .hello { font-size: 36px; color: green; font-family: 'GraublauWeb'; background: url('./image/icon.png'); } .imageStyle { display: block; width: 50px; height: 50px; } .divStyle { width: 100px; height: 100px; margin: 10px; background: yellow; } package.json { &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;private&quot;: true, &quot;scripts&quot;: { &quot;watch&quot;: &quot;webpack --watch&quot;, &quot;start&quot;: &quot;webpack-dev-server --open&quot;, &quot;build&quot;: &quot;npx webpack --config webpack.config.js&quot;, &quot;server&quot;: &quot;node server.js&quot; }, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: { &quot;file-loader&quot;: &quot;^6.2.0&quot;, &quot;html-webpack-plugin&quot;: &quot;^4.5.2&quot;, &quot;loadsh&quot;: &quot;0.0.4&quot;, &quot;webpack&quot;: &quot;^4.20.2&quot;, &quot;webpack-cli&quot;: &quot;^3.1.2&quot; }, &quot;devDependencies&quot;: { &quot;clean-webpack-plugin&quot;: &quot;^4.0.0-alpha.0&quot;, &quot;css-loader&quot;: &quot;^5.2.4&quot;, &quot;express&quot;: &quot;^4.17.1&quot;, &quot;image-webpack-loader&quot;: &quot;^6.0.0&quot;, &quot;style-loader&quot;: &quot;^2.0.0&quot;, &quot;url-loader&quot;: &quot;^4.1.1&quot;, &quot;webpack-dev-middleware&quot;: &quot;^4.1.0&quot;, &quot;webpack-dev-server&quot;: &quot;^3.11.2&quot;, &quot;webpack-manifest-plugin&quot;: &quot;^3.1.1&quot;, &quot;webpack-nano&quot;: &quot;^1.1.1&quot; } } 当我们执行npm run start时，会打开localhost:9000的网址，并且每点击一次按钮会出现一个div 但是当我们去修改.divStyle的background属性时，就会引起浏览器的刷新，导致这些通过点击生成的div就会消失。 但是如果开始webpack-dev-server的hot属性，就可以保证在修改css时不会引起浏览器的刷新，这样动态生成的div就不会消失。 ","link":"https://hviker.github.io/post/mo-kuai-re-ti-huan/"},{"title":"开发环境","content":"1、source map source map: 可以将编译后的代码映射回原始代码。 当我们将多个源文件打包到一个bundle时，如果其中的一个源文件报错，那么报错就会直接指向bundle。为了准确知道错误来自于哪个源文件，js提供了source map。 在webpack配置中对应devtool选项，此选项控制是否生成以及如何生成source map。 module.exports = { ..., devtool: '(none)', ... } 这里列举devtool在开发环境和生产环境下常用的选项。 devtool 构建速度 重新构建速度 生产环境 品质 (none) +++ +++ yes 打包后的代码 eval +++ +++ no 生成后(转换过)的代码 eval-source-map -- ++ no 原始源代码 source-map -- -- yes 源代码 +++ 非常快速, ++ 快速, + 比较快, o 中等, - 比较慢, -- 慢 打包后的代码：将所有生成的代码视为一大块代码，无法做到模块分离 生成后的代码：每个模块相互分离，并用模块名称进行注释。但是部分语法会转换过，比如exports，import，class等，非源代码。 原始源代码：源代码，方便调试。 eval-source-map会生成用于开发环境的最佳品质的 source map，方便调试。 (none)不生成 source map。打包成的bundle文件体积最小。 在使用上，我们需要区分mode模式，开发环境使用eval-source-map,非开发模式可以使用(none)。 合理使用source map可以优化项目，影响bundle文件体积，文件构建、重建速度等。 避免在生产中使用 inline-*** 和 eval-***，因为它们会增加 bundle 体积大小，并降低整体性能。 更多devtool选项值和配置，可以查看https://v4.webpack.docschina.org/configuration/devtool 2、自动编译 ​ 正常情况下，如果对代码进行修改，需要每次运行npx webpack --config webpack.config.js来完成代码编译。webpack提供了几种可选的方式，来实现代码变化后的自动编译。 2.1 使用webpack watch mode（webpack的观察者模式） npx webpack --watch 或者在package.json中添加script，然后运行npm run watch &quot;scripts&quot;: { &quot;watch&quot;: &quot;webpack --watch&quot;, }, 执行完成后，如果代码发生变化则会自动重新编译。 缺点是需要重新刷新浏览器才能看到修改后的效果。 Q1: webpack中配置了html-webpack-plugin，用于实现index.html的自动创建及bundle的动态引入。使用watch mode后，当修改文件存在问题时很容易出现index.html消失的情况。 查看plugins中是否使用了clean-webpack-plugin，clean-webpack-plugin会先清除dist下的文件，在编译过程中出现问题时会停止后续编译。 2.2 使用webpakc-dev-server 提供了一个简单的web server，并且具有实时加载的功能，及时刷新浏览器。 npm install --save-dev webpack-dev-server webpack.config.js： module.exports = { devServer: { contentBase: path.join(__dirname, 'dist'), port: 9000, compress: true }, } contentBase:告诉服务器查找文件的位置，可以从多个目录提供内容，多个目录地址用逗号隔开。 port: server 端口号。 compress: 一切服务都启用gzip压缩。 host： 指定使用一个host，默认是localhost。如果洗完服务器外部可以访问，可以指定host hot：是否启动模块热替换功能，值为true或者false。 open： 高度dev-server在server启动后打开浏览器，值为true或者false。 proxy: 设置代理， devServer: { proxy: { '/api': { target: 'http://localhost:3000', pathRewrite: { '^/api': '' } } } } 这样会使/api/use代理到 http://localhost:3000/api/use 如果不想传递/api,则添加属性 pathRewrite 更多webpack-dev-server配置查看:https://v4.webpack.docschina.org/configuration/dev-server 2.3 使用 webpack-dev-middleware 封装器，可以将webpack处理的文件发送到指定server。webpack-dev-server已经包含了webpack-dev-middleware的功能 npm install --save-dev express webpack-dev-middleware 更多使用查看：https://v4.webpack.docschina.org/guides/development/#%E4%BD%BF%E7%94%A8-webpack-dev-middleware Q1：webpack-dev-server与webpack-dev-middleware使用时不会在dist文件夹下生成文件。 他们在编译之后不会写入任何文件，而是将bundle文件保留到内存上，然后发送到指定的server中。 ","link":"https://hviker.github.io/post/kai-fa-huan-jing/"},{"title":"管理输出","content":"1、html-webpack-plugin 当我们根据功能或者模块将代码分成多个js，这时候利用webpack会输出多个bundle。index.html需要手动引入多个bundle会变得困难。这时候可以通过设置HtmlWebpackPlugin来实现多个bundle的自动化引入。 npm install --save-dev html-webpack-plugin const path = require(&quot;path&quot;); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = { mode: 'production', entry: { app: &quot;./src/index.js&quot;, print: &quot;./src/print.js&quot; }, plugins: [ new HtmlWebpackPlugin({ title: '管理输出' }) ], output: { filename: &quot;[name].bundle.js&quot;, path: path.resolve(__dirname, &quot;dist&quot;), }, } 1、下载html-webpack-plugin，并引入 2、在entry中定义多个入口，同时output的filename设置为`[name].bundle.js``,这样可以使打包生成的bundle名称分别为app.bundle.js、print.bundle.js。否则执行打包命令会报错出现多个重名的bundle。 3、plugins中使用html-webpack-plugin，这里上面声明的HtmlWebpackPlugin是一个构造函数，需要通过new HtmlWebpackPlugin({...})使用。html-webpack-plugin可以动态生成index.html并且动态引入entry中定义的文件。 Q1：使用html-webpack-plugin报错 Cannot read property 'tap' of undefined。 查看自己webpack版本是否与html-webpack-plugin版本一致。自己项目中webpack用的4+,则html-webpack-plugin也用4+。 2、clean-webpack-plugin clean-webpack-plugin负责清理/dist文件夹。 经过webpack打包后，生成文件会被输出到output定义的path中。有些打包文件在项目开发过程中已经不需要了，但是webpack本身不具有自动清理/dist的功能。这时候需要clean-webpack-plugin。 const path = require(&quot;path&quot;); const HtmlWebpackPlugin = require('html-webpack-plugin'); const { CleanWebpackPlugin } = require('clean-webpack-plugin'); module.exports = { mode: 'production', entry: { app: &quot;./src/index.js&quot;, print: &quot;./src/print.js&quot;, }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ title: '管理输出' }) ], output: { filename: &quot;[name].bundle.js&quot;, path: path.resolve(__dirname, &quot;dist&quot;), }, module: { rules: [ { test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;], } ], }, }; 3、manifest 描述模块与所生成的bundle之间的映射关系。可以使用webpack-manifest-plugin将mainfest数据提取为到json文件中。 npm install webpack-nano webpack-manifest-plugin --save-dev const path = require(&quot;path&quot;); const HtmlWebpackPlugin = require('html-webpack-plugin'); const { CleanWebpackPlugin } = require('clean-webpack-plugin'); const { WebpackManifestPlugin } = require('webpack-manifest-plugin'); module.exports = { mode: 'production', entry: { app: &quot;./src/index.js&quot;, print: &quot;./src/print.js&quot;, // test: &quot;./src/test.js&quot; }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ title: '管理输出' }), new WebpackManifestPlugin() ], output: { filename: &quot;[name].bundle.js&quot;, path: path.resolve(__dirname, &quot;dist&quot;), }, } 所生成的mainfest.json文件 ","link":"https://hviker.github.io/post/guan-li-shu-chu/"},{"title":"loader：管理资源","content":"1 链式loader执行顺序 一组链式的loader按照相反的顺序执行，从右到左。 链式的最后一个loader将转换过后的结果传递给前一个loader，以此类推。链中的第一个loader，返回webpack期望的js。 2 管理资源 对于webapack来说，默认只能打包js文件，或者说是js模块。 Webpack中的loader可以引入、打包非js文件/模块。 当webpack对项目代码进行打包时，遇到非js文件，会去webpack的配置文件中查找module节点，查询有没有配置去处理对应的节点。 允许将文件从不同的语言(如ts)转换为js,或者将内联图片转换为data URL,允许直接在js模块中import css文件。 2.1 加载css 需要安装 style-loader 和 css-loader npm install --save-dev style-loader css-loader webpack根据正则表达式，来查找所有以.css结尾的文件，都将被提供style-loader，css-loader。 这样可以使你在js文件中使用import './style.css'。 在编译该模块时，引入的style.css将会被&lt;style&gt;给包裹，并添加到html的&lt;head&gt;中。 module: { rules: [ { test: /\\.css$/, use: [&quot;style-loader&quot;, &quot;css-loader&quot;], } ] } Q1: 为什么先引入style-loader,后引入css-loader ? 1、css-loader的作用： 帮助解析css文件中的css代码，除了正常的css代码外，还解析css中的@import、url(..)这种方法来实现require的功能，但是样式内容并没有添加到&lt;style&gt;中。 2、style-loader的作用：帮助我们将css-loader解析后的内容包裹在&lt;style&gt;中，并添加到html的&lt;head&gt;中。 3、loader执行顺序，从右往左。webpack肯定是先将所有css模块解析完成后再添加到style标签中，所以css-loader在后，style-loader在前。 2.2 加载images图像 对于图片，不管是css中的background-image，还是img中的src，使用file-loader | url-loader进行处理。 file-loader解决了路径引入问题。拿图片来说，webpack打包后这些图片的打包路径可能和编码中引入路径不一样，比如开发坏境中引入./images目录下的图片，但是打包却打包到./imgs文件夹下，甚至设置很多文件夹嵌套，导致引用出现问题。file-loader会修改打包后图片的存储路径，首先会将图片移动到output所在文件夹，并且随机生成一个hash值作为图片的名字。并将打包后的图片名称返回import | require函数。 { test: /\\.(png|svg|jpe?g|gif)$/i, use: [ { loader: &quot;file-loader&quot;, options: { name: &quot;[name]_[contenthash:7].[ext]&quot;, outputPath: 'images/' } } ] } file-loader的常用配置项(options) name: 设置打包生成文件的名称。其中，[name]: 源文件名； [contenthash]: 随机生成的hash值,:7 表示生成的hash值截取前7位； [ext]: 源文件后缀； 一定要用&quot;&quot;包裹。 outputPath: 打包文件目录，相对路径，相对于output的设置。我们最终导出的文件路径为output.path + file-loader.outputPath + file-loader.name。例如上面images,会在dist文件夹下创建images文件夹并存储文件。 publicPath:指定最终引用的文件路径(打包生成的index.html文件里面引用资源的前缀)。最终引用文件路径：output.outputPath + file-loader.outputPath + file-loader.name 。例如访问文件路径为http://localhost:8080/dist/images,其中output.publicPath默认为/dist, 这里可以设置为images/。 url-loader:https://www.npmjs.com/package/url-loader url-loader: 内置file-loader。使用url-loader时，可以不用安装file-loader。 当图片较多时会发起很多http请求，会降低页面的性能，这个问题可以使用url-loader进行解决。url-loader会将引入的图片编码，生成dataURL并将其打包到文件中。最终不需要请求直接访问这个dataURL就能访问图片。如果图片过大编码过程将会降低性能，建议将较小的图标设置为baseURL。 url-loader提供了limit参数，如果文件小于limit限制，则返回DataURL（根据encoding设置，默认base64，也可以设置utf-8等），如果大于则会调用file-loader。 进一步压缩、优化图片： 图片压缩： image-webpack-loader { loader: &quot;image-webpack-loader&quot;, options: { bypassOnDebug: true, } } loader中使用image-webpack-loader时经常报错：Cannot find module 'imagemin-gifsicle' 这是因为npm下载包时下载不全导致的。 解决方法： 不要使用npm，使用cnpm i image-webpack-loader@6.0.0 -D; 这里一定要加版本号，如果不加版本号很容易下载不下来。 使用cnpm下载低版本的包。 比较url-loader、file-loader:https://segmentfault.com/a/1190000018987483?utm_source=tag-newest 最终对图片的优化loader为： 这里先对图片使用image-webpack-loader进行压缩为二次图片，二次图片再使用url-loader。 当二次图片大小大于8k直接使用压缩后的文件，小于8k是进行base64编码。 module: { rules: [ { test: /\\.(png|svg|jpe?g|gif)$/, use: [ { loader: &quot;url-loader&quot;, options: { limit: 8192, // 8k name: '[name]_[hash:7].[ext]', } }, { loader: &quot;image-webpack-loader&quot;, options: { bypassOnDebug: true, } } ], }, ], } 这里能够看到原图片压缩了70% 2.3 加载font字体 使用file-loader 或者 url-loader可以接收、加载字体文件。 对指定文件添加loader module: { rules: [ { test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'url-loader' ] } ], } ​ 存放字体文件并使用@font-face声明混合。url(...)指令会给webpack处理。 2.4 加载csv|tsv|xml数据 对于数据，json属于内置的，也就是说使用import导入.json文件时默认正常运行。但是如果导入CSV、TSV、XML时需要下载csv-loader 和 xml-loader。 module: { rules: [ { test: /\\.(csv|tsv)$/, use: [ 'csv-loader' ] }, { test: /\\.xml$/, use: [ 'xml-loader' ] } ] } ","link":"https://hviker.github.io/post/webpack-loaderguan-li-zi-yuan/"},{"title":"Vue2.0部分API整理(一)","content":"1、provide, inject ​ 用于父组件向子组件、孙子组件传递数据。 ​ provide, inject是成对出现的，provide在父组件使用，用于传递变量 ；inject在子、孙子组件使用，用于接收变量。 ​ 相对于props，主要用于跨组件传递。 ​ 传递的数据为非响应式数据。父组件中主动触发修改变量的操作，不会影响子组件展示。 1.1、使用 ​ 父组件： export default { components: { Othertext }, provide() { return { currentPermission: this.currentPermission } }, data() { return { currentPermission: 'editor', } } } ​ 子组件： export default { inject: { currentPermission: { default: () =&gt; ({}) } }, } 1.2、注意 ​ 1) provide 的值需要是一个对象或者是返回对象的函数，与data属性类型。 ​ 2) inject的值需要是个数组，或者对象，与props属性类似。 ​ 3) 传递的值为非响应式数据，由于父组件的主动行为引起属性发生变化时，子组件并不会响应。 ​ 4） 一般vue项目的根页面为vue.app,同时也是所有页面的父页面。我们会根据项目要求存储些公共变量或者方法，如果需要在其他页面调用，可以将app.vue的当前实例传进去。 // app.vue provide() { return { app: this } } ... // 其他页面 inject: { app: { default: () =&gt; ({}) }, }, 但是我们不建议这样使用。对于公共变量完全可以放到vuex中，公共方法可以进行提取调用。 2、watch两个属性 immediate 、deep 2.1、使用 watch: { info1: { handler(newVal, oldVal) { // todo }, deep: true }， info2: { handler(newVal, oldVal) { // todo }, immediate: true } }, 2.2 区别 deep: 深度监听。在vue2.x的版本中，响应式使用Object.defineProperty(),在组件实例创建时，只是对对象的存在属性做了响应式。但是在实际开发过程中我们可能会存在增加属性的情况。对于这种情况，我们可以使用$set() 或者 深拷贝的方式来解决。对于对象的监听，尤其是上述增加属性的情况，deep可以做到深层次的监听，即当属性发生变化时也会watch到当前对象发生了变化。 immediate: 主要是用于页面加载时需不需要触发watch函数。如果是true则触发，否则之后在属性或对象发生变化时才会触发。 2、slot ​ 插槽。当父组件调用子组件时，允许将子组件内容、逻辑以插槽的形式写在父组件中。插槽有默认插槽，即v-slot:default，也有具名插槽，下面demo主要是具名插槽使用。 3.1 使用 ​ slot.vue &lt;template&gt; &lt;div class=&quot;container-wrapper&quot;&gt; slots.vue &lt;br/&gt; &lt;Testslot&gt; // v-slot只能用在&lt;template&gt;; // v-slot: 可以使用 # 来简化， 接收对应子组件插槽传递的数据value直接在对应v-slot后加={value},value可以使用解构赋值 // v-slot:name 其中name为具名插槽的name，即代码插入位置 &lt;template #header=&quot;{ user: { name } }&quot;&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;h2&gt;{{ username }}&lt;/h2&gt; &lt;h3&gt;{{ name }}&lt;/h3&gt; &lt;/template&gt; &lt;template v-slot:default&gt; &lt;p&gt;middle&lt;/p&gt; &lt;/template&gt; &lt;template #footer&gt; &lt;h2&gt;footer&lt;/h2&gt; &lt;/template&gt; &lt;/Testslot&gt; &lt;Vfor :arr=&quot;permission&quot;&gt; // v-slot 接收的参数可以key &lt;template #vfor=&quot;arritem&quot;&gt; &lt;span v-if=&quot;arritem.item != 1&quot;&gt;{{ arritem }}&lt;/span&gt; &lt;/template&gt; &lt;/Vfor&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Testslot from './_testslot'; import Vfor from './vfor'; export default { name: &quot;&quot;, components: { Testslot, Vfor }, data() { return { username: 'xiaoming', permission: ['1', '2', '3'] }; }, computed: {}, watch: {}, created() {}, mounted() {}, beforeDestroy() {}, //生命周期 - 销毁之前 destroyed() {}, //生命周期 - 销毁完成 activated() {}, //如果页面有keep-alive缓存功能，这个函数会触发 //方法集合 methods: {}, }; &lt;/script&gt; ​ Testslot.vue &lt;template&gt; &lt;div class=&quot;container-wrapper2&quot;&gt; &lt;header&gt; // 需要将子组件的值传递给父组件是，使用v-bind:prpperty = &quot;data&quot; // 具名插槽需要使用name，默认name=&quot;default&quot; &lt;slot name=&quot;header&quot; v-bind:user=&quot;user&quot;&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;&quot;, props: [], components: {}, data() { return { user: { name: '1' } }; }, computed: {}, watch: {}, created() { }, mounted() {}, beforeDestroy() {}, //生命周期 - 销毁之前 destroyed() {}, //生命周期 - 销毁完成 activated() {}, //如果页面有keep-alive缓存功能，这个函数会触发 //方法集合 methods: {}, }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; //@import url(); 引入公共css类 &lt;/style&gt; ​ Vfor.vue &lt;template&gt; &lt;div class=&quot;container-wrapper&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;index&quot;&gt; // 这里将item传递给父组件，这里v-bind:item可以写成:item, :后面的[item]可以修改，传递给父组件的时候，需要父组件自定义key.[item] 获取到数据 // 后备显示内容为item &lt;slot name=&quot;vfor&quot; v-bind:item=&quot;item&quot;&gt;{{ item }}&lt;/slot&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;&quot;, props: { arr: { type: Array } }, components: {}, data() { return {}; }, computed: {}, watch: {}, created() {}, mounted() {}, beforeDestroy() {}, //生命周期 - 销毁之前 destroyed() {}, //生命周期 - 销毁完成 activated() {}, //如果页面有keep-alive缓存功能，这个函数会触发 //方法集合 methods: {}, }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; //@import url(); 引入公共css类 &lt;/style&gt; 3、delimiters 改变纯文本插入分隔符。 现在我们的插值形式就变成了${},代替了{{ }},在页面中就可以使用 ${xxxxx} 绑定对应的值。 4、inheritAttrs 如果你不希望组件的根元素继承特性，你可以在组件的选项中设置 inheritAttrs: false 当inheritAttrs: false ，使用组件时组件自定义的属性不会覆盖组件中属性名称的值，同时组件中未定义的属性也不会添加到组件中 当inheritAttrs:true，使用组件时组件自定义的属性会覆盖组件中属性名称的值，同时组件中未定义的属性会添加到组件中 但是在组件中插入style、class时，不管inheritAttrs是true还是false，都会叠加到一起。 arrt使用：给组件添加v−bind=arrt 使用：给组件添加v-bind=arrt使用：给组件添加v−bind=arrts。 当设置为true或者false时功能与上述一致。 &lt;div id =&quot;wxApp&quot; class =&quot;appclass&quot;&gt; &lt;blog-post title=&quot;标题&quot; demo-one=&quot;未定义属性1&quot; demo-tow=&quot;未定义属性2&quot; class=&quot;cointer2&quot; style=&quot;color:red&quot;&gt;&lt;/blog-post&gt; &lt;/div&gt; Vue.component(&quot;blog-post&quot;,{ props:{ title:String, }, inheritAttrs:false, template:`&lt;div demo-one=&quot;hello&quot; class=&quot;cointer&quot; style=&quot;width:500px&quot; &gt; &lt;h1&gt;title:{{title}}&lt;/h1&gt; &lt;/div&gt; ` }) 当inheritAttrs为false时， 当inheritAttrs为true时 参考：https://blog.csdn.net/weixin_49868928/article/details/111935639 ","link":"https://hviker.github.io/post/vue20-bu-fen-api-zheng-li-yi/"},{"title":"Vue.directive","content":"1、基本使用 参数： {string} id {Function | Object} [definition] 用法： 注册或获取全局指令。 // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el，bind, vnode, oldVnode) { // 触发 } }) &lt;input type='text' v-focus/&gt; 关于钩子函数： 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 关于钩子函数参数： 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM。 binding ：一个对象，包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 2、高级使用 ​ 定义可拖动组件 Vue.directive('drag', { inserted: function(el) { el.onmousedown = function(e) { let left = e.clientX - el.offsetLeft, // 鼠标点击位置距离div最左侧位置 top = e.clientY - el.offsetTop, // 鼠标点击位置距离div最顶侧位置 right = el.scrollWidth - left, // 鼠标点击位置距离div最右侧位置 bottom = el.scrollHeight - top, // 鼠标点击位置距离div最低侧位置 clientWidth = document.body.clientWidth, // 屏幕宽度 clientHeight = document.body.clientHeight; // 屏幕高度 console.log(clientHeight) document.onmousemove = function(e) { // 保证块在显示区域内移动 if(e.clientX &gt; left &amp;&amp; e.clientX + right &lt; clientWidth &amp;&amp; e.clientY &gt; top &amp;&amp; e.clientY + bottom &lt; clientHeight) { el.style.left = e.clientX - left + 'px'; el.style.top = e.clientY - top + 'px'; } } } el.onmouseup = function() { document.onmousemove = null; } } }) ​ 高精度页面权限资源控制 ​ vue页面： &lt;!-- 高精度资源权限控制 --&gt; &lt;button v-permission=&quot;{ curPer:currentPermission, perArr: permissionArr, curPath: currentPath }&quot;&gt;编辑&lt;/button&gt; &lt;script&gt; export default { computed: { // 这里获取路由，是因为在资源控制方法中添加了页面定位，方便调试 currentPath(){ return this.$route.path; } }, data() { return { permissionArr: ['superadmin', 'editor'], currentPermission: 'editors' } }, } &lt;/script&gt; ​ js方法 function isHanPermission(permissionArr, permissionItem) { if(permissionArr.length) { const index = permissionArr.indexOf(permissionItem); return index &gt; -1; } } Vue.directive('permission', { inserted: function(el, bind) { const { curPer, perArr, curPath } = bind.value; if(curPer &amp;&amp; perArr &amp;&amp; curPath &amp;&amp; perArr.length) !isHanPermission(perArr, curPer) &amp;&amp; (el.parentNode &amp;&amp; el.parentNode.removeChild(el)); else throw new Error(`权限控制存在问题，路由位置:${curPath}`); } }) ","link":"https://hviker.github.io/post/vue-yuan-ma-xue-xi-vuedirective/"},{"title":"CSS设置滚动条样式(兼容IE)","content":"webkit浏览器滚动条样式设置位置参考如下： IE浏览器滚动条样式设置位置参考如下图: #scroll{ width:200px; height:200px; overflow:auto; margin-bottom: 20px; } #scroll div{ width:400px; height:400px; } #scroll::-webkit-scrollbar{/*滚动条整体部分，其中的属性有width,height,background,border等（就和一个块级元素一样）（位置1）*/ width:10px; height:10px; } #scroll::-webkit-scrollbar-button{/*滚动条两端的按钮，可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果（位置2）*/ background:#74D334; } #scroll::-webkit-scrollbar-track{/*外层轨道，可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果（位置3）*/ background:#FF66D5; } #scroll::-webkit-scrollbar-track-piece{/*内层轨道，滚动条中间部分（位置4）*/ background:#FF66D5; } #scroll::-webkit-scrollbar-thumb{/*滚动条里面可以拖动的那部分（位置5）*/ background:#FFA711; border-radius:4px; } #scroll::-webkit-scrollbar-corner {/*边角（位置6）*/ background:#82AFFF; } #scroll::-webkit-scrollbar-resizer {/*定义右下角拖动块的样式（位置7）*/ background:#FF0BEE; } #scroll{ scrollbar-arrow-color: #f4ae21; /**//*三角箭头的颜色*/ scrollbar-face-color: #333; /**//*立体滚动条的颜色*/ scrollbar-3dlight-color: #666; /**//*立体滚动条亮边的颜色*/ scrollbar-highlight-color: #666; /**//*滚动条空白部分的颜色*/ scrollbar-shadow-color: #999; /**//*立体滚动条阴影的颜色*/ scrollbar-darkshadow-color: #666; /**//*立体滚动条强阴影的颜色*/ scrollbar-track-color: #666; /**//*立体滚动条背景颜色*/ scrollbar-base-color:#f8f8f8; /**//*滚动条的基本颜色*/ } 参考：https://blog.csdn.net/zh_rey/article/details/72473284 ","link":"https://hviker.github.io/post/css-she-zhi-gun-dong-tiao-yang-shi-jian-rong-ie/"},{"title":"培训-ES语法","content":"一、概念 ECMAScript（ES）：是一个国际通用性的标准化脚本语言。 JavaScript（JS）：ECMAScript、DOM和BOM组成。 简单地理解为：ECMAScript是JavaScript的语言规范，JavaScript是ECMAScript的实现和扩展。 2011 年，ECMAScript 5.1 版发布。也就是ES5('use strict', forEach, map,filter.some...[Array.prototype], JSON.parse, JSON.stringfiy, object.defineProperty)。 2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。 目前已经发展至ES12。 二、为什么要学习ES? 精简代码，且主流浏览器已支持ES6（如果需要适配IE9-，不建议使用）。 行业内较新的前端框架（vue、react、原生微信小程序、uniapp、taro）都已经使用ES6+语法。 便于阅读框架源码。 三、常用ES6语法 let、const 限制在块级作用域({})的变量定义方式。 let是新的var，但是声明的变量只能在当前块级作用域有效。 const声明常量，常量只能赋值一次，一旦声明就不能改变。 与var区别: 1）var声明的变量为全局变量，默认绑定到windows上，全局作用域有效；而let仅在当前声明的块级作用域内有效。 在同一个块级作用域里，变量只能被let声明一次；在不同的块级作用域里，变量可以被let声明多次。var可以在全局作用域内声明多次。 let严格遵守代码顺序，不存在变量提升。而var声明的变量，会忽略声明顺序，可以提升变量。 模板字符串 模板字符串为构造字符串提供了语法糖。符号 `` let person = 'xiaoming'; console.log(person + '是个好学生')； // 等价于 console.log(`${person}是个好学生`)； 扩展(延展)运算符、rest运算符 都是三个点 &quot;...&quot;。 扩展(延展)运算符：用于把数组或者类数组对象展开形成一系列用逗号隔开的值。 let getFunc = (x, y) =&gt; { console.log(x); console.log(y); } let arr = [1, 2]; // 普通做法 getFunc(arr[0], arr[1]); // 打印 1， 2 // 使用扩展运算符 getFunc(...arr)；// 打印1， 2 使用场景 1、给数组做深拷贝 let arr1 = [1, 2]; let arr2 = [...arr1]; console.log(arr1 === arr2); // false 2、合并数组，相当于ES5中的concat let arr1 = [1, 2]; let arr2 = [3, 4]; console.log(arr1.concat(arr2)); // 打印 [1, 2, 3, 4] console.log([...arr1, ...arr2]); // 打印 [1, 2, 3, 4] 3、字符串转数组 let str = 'hello'; console.log([...str]); // 打印 ['h', 'e', 'e', 'l', 'o'] rest运算符：把逗号隔开的值组合成一个数组 or 对象。 使用场景 1、不定参数传值 // 不定参数传值 - 数组 let getArrItem = ([...args]) =&gt; { console.log(args[0]); console.log(args[1]); console.log(args[2]); console.log(args[3]); } getArrItem([1, 2, 3]) // 不定参数传值 - 对象 let getObjItem = ({ ...args }) =&gt; { console.log(args.id); console.log(args.name); } getObjItem({ id: '1', name: 'xiaoming', address: '济南市' })； 2、与解构赋值关联使用，具体见解构赋值。 解构赋值 允许基于模式匹配的方式进行赋值，这种模式匹配能够支持 数组和对象。 对于数组： ​ 1、数组中的数据会自动解析到对应接受该值的变量中，数组的解构赋值要一一对应，否则就是undefined。 ​ 2、可以直接省略元素，使用','做占位符。 ​ 3、rest运算符 '...', 可以用于获取数组部分数据。 // 数组 let [ a, b, c, , d ] = [1, 2, 3, 4, 5] console.log('a:' + a) console.log('b:' +b) console.log('c:' +c) console.log(d) 对于对象： ​ 1、对象与数组不同，对象不要求一一对应，但是要求变量必须与属性同名(不使用别名的情况),这样才能获取到正确的值。 ​ 2、使用别名：let { local:address } = { local: '山东' } 可以访问address ​ 3、rest运算符 '...'，可以用于获取对象部分数据。 ​ 4、嵌套对象时与上述相同。 // 对象 let { id, name, address: local, ...otherinfo } = { id: 1 , name: 'xiaoming',address: '济南市', sex: '男', note: '' }; console.log(id) console.log(name) console.log(local) console.log(otherinfo) let obj = { id: 2, ...otherinfo } console.log(obj) // 嵌套对象 let { ids, otherinfos: { company } } = { ids: 2, otherinfos: { company: 'jxd' } }; console.log(company) 箭头函数 类似于匿名函数，将原函数的&quot;function&quot;关键字和函数名都去掉，并且用&quot;=&gt;&quot;连接参数列表和函数体。 function add(x, y) { return x + y } // 等价于 let add = (x, y) =&gt; { return x + y } // 等价于 let add = (x, y) =&gt; x + y console.log(add(1,2)); 注意点： 函数的参数只有一个时，可以省略 ()。 ​ 函数体内只有一条return语句,且返回非对象时，可以省略 return关键字和{}；当返回对象时，需要加()，避免和函数体的{...}有语法冲突。 // 返回非对象 let getNum = （x）=&gt; { return x }; // 等价于 let getNum = x =&gt; x; // 返回对象 let getObj = name =&gt; ({ name: name }); console.log(getObj('xiaoming')); 2）箭头函数的this指向就是上下文里对象this的指向，如果没有上下文对象，this就指向window。不受call、apply、bind等方法的影响。 // 关于this指向 let obj = { id: '1', age: this, // 指向window name: () =&gt; { console.log(this); // 指向window setTimeout(() =&gt; { console.log(this);// 指向window })}, getFunc: function() { console.log(this); // 指向obj setTimeout(() =&gt; { console.log(this); // 指向obj }) } } obj.age; obj.name(); obj.getFunc(); 类(class) ​ 类（class）是在基于原型的面向对象模式上简单包装的语法糖。拥有一个 单一且方便的声明形式将更易于使用，并且 鼓励混合使用。类（class）支持基于原型的继承、super 调用、 实例和静态方法以及构造函数。 等价于构造函数。 1、基本格式 ​ 1) class后面紧跟方法名，方法名需要大写。 ​ 2) 创建实例时，使用new Xxx()的格式。 ​ 3) 都存在constructor,即构造函数。 // 声明类 class Person { constructor(name) { this.name = name; } getPersonInfo() { console.log(this.name) } } // 创建实例 let person = new Person('xiaoming'); person.getPersonInfo(); 2、继承 ​ 1) 使用关键字 extends。 ​ 2) constructor中必须使用super(),用于继承父元素的属性和方法。 // 声明类 class BoyPerson extends Person { constructor(name, sex) { super(name); this.sex = sex; } getBoyPersonInfo() { console.log(`姓名: ${this.name}, 性别: ${this.sex}`); } } // 创建实例 let boy = new BoyPerson('xiaoli', '男') boy.getBoyPersonInfo(); 3、实例属性 ​ 1) 定义在constructor()方法中的属性都是对象的属性，可以用this获取。 ​ 2) 实例属性也可以定义在类顶层的，定义格式 _xxx， 通过this获取。 4、静态属性和方法 ​ 所有在类中定义的属性和方法，都会被实例继承。如果在属性和方法前面添加static，则该属性和方法不会被实例继承，而是直接通过类来调用，这就是静态方法。 ​ 1) 使用关键字 static。 ​ 2) 不能通过实例调用，只能通过类调用，即构造函数.方法名。 5、私有属性和方法 只能在类的内部访问的属性和方法，外部不能调用。 ​ 写法： 在属性或者方法前面加 #。 ​ 内部访问:需要 this.#属性名|方法名。 class BoyPerson extends Person { _local = '济南市'; #age = 10; constructor(name, sex) { super(name); this.sex = sex; } getBoyPersonInfo() { console.log(`姓名: ${this.name}, 性别: ${this.sex}, 地址: ${this._local}, 年龄${this.#age}`); } } let boy = new BoyPerson('xiaoli', '男') boy.getBoyPersonInfo(); console.log(boy._local); // 打印 济南市 console.log(boy.#age); // 报错 PS: ​ 1）类声明和函数声明一个重要的区别，类声明不会在作用域内导致变量提升。所以在使用类的时候先声明后创建实例。 ​ 2) constructor中定义的内容都会绑定到对象的属性上，类的所有方法会定义prototype上，例如constructor()、getBoyPersonInfo() 会绑定到构造函数的prototype上。 ​ 3) 添加方法确实可以通过 Person.prototype.add = () { return 1 } || person.proto.add = () =&gt; { return 1 }。但是不推荐，会影响其他实例。 class Person { static comeFrom = 'china' constructor(name) { this.name = name; } getPersonInfo() { console.log(this.name) } } let person = new Person('xiaoming'); let person2 = new Person('xiaoli'); person.__proto__.getName = () =&gt; { console.log(this.name) }; Promise ​ 构造函数，异步操作容器，里面存在一个异步操作。通过Promise可以获取该异步操作可能发生的结果，比如pending, fulfilled, rejected。 1、Promise对象特点 ​ 1）提供三种状态，pending(进行中)、fulfilled(已成功)、rejected(已失败)，只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个操作。 ​ 2）状态变化有两种，从pending -&gt; fulfilled || pending -&gt; rejected。 2、作用 ​ 1) 异步操作以同步的写法表现出来,避免回调函数层层嵌套 .then().catch().finally()。 ​ 2) Promise对象提供了许多API，使异步函数处理更加容易。 3、基本用法 ​ 1) 创建promise实例。Promise构造函数接收一个函数作为参数，该函数中有两个参数，分别是resolve，reject。 ​ 2) 调用Promise提供方法。Promise对象生成后，可以用then() 指定resolve(必选)和reject(可选)状态的回调函数。 ​ 3) 如果resolve()带有参数，该参数会被传递给回调函数。如果reject() 带有参数，该参数一般是Error对象的实例，也会被传递给回调函数。 const promise = new Promise((resolve, reject) =&gt; { // todo 这里处理逻辑 if(success) { // 成功时执行 resolve(value) } else { // 失败时执行 reject(value) } }) promise.then(value =&gt; { }, err =&gt; { }) 4、Promise实例提供的方法 ​ 1) Promise.all(iterator),其中iterator必须是个可迭代的对象，比如Array 或者 String，返回一个Promise实例 ​ 传入参数中任意一个primise返回失败，则整体返回失败，返回的错误信息为第一个失败的promise结果。 ​ 2) Promise.race(iterator)。返回最先发生改变的实例。 ​ 3) Promise.resolve(value): 返回一个以给定的值解析后的Promise对象。 ​ 4) Promise.reject(reason): 返回一个含有reason的状态为rejected的Promise对象。 ​ 5) Promise.prototype.then(): 为Promise实例状态发生变化时添加回调函数，接受两个参数，fulfilled状态时的回调函数，rejected状态时的回到函数。并且该方法返回一个新的Promise对象。 ​ 6) Promise.prototype.finally(): 返回一个Promise, 在上一轮promise运行后，无论状态是fullfilled还是rejected，都会执行finally中指定的回调函数。 ​ 7) Promise.prototype.catch(): 返回一个Promise，并且处理拒绝情况，与then中的err相同。这里推荐使用catch方法，不要在then() 中定义rejected状态的回调函数，这是因为catch还可以捕捉在then()方法执行中存在的错误。 getPreApprovalList(params) { return new Promise((resolve, reject) =&gt; { OtherContractService.getPreApprovalList(params).then(data =&gt; { (data.list || []).forEach(i =&gt; this.$set(i, 'deleteLoading', false)) resolve(data) }).catch(e =&gt; { reject(e) }) }) } promise具有then(),返回一个新的promise实例，因此可以采用链式写法，即then方法后面再调用then。 5、关于Promise执行顺序 // 执行顺序 function timeOut(ms) { return new Promise((resolve, reject) =&gt; { console.log(4) return setTimeout(resolve, ms, '5' ) }) } timeOut(100).then(val =&gt; { console.log(val) }, err =&gt; { console.log('失败') }) let promise = new Promise((resolve, reject) =&gt; { resolve(2); // 这里比较下加return的情况 console.log(1); }) promise.then(val =&gt; { console.log(val) }) console.log(3) 解析： 1、创建Promise实例时，优先执行Promise实例中的console。 2、执行同步console。 3、从上往下执行不含延时的Promise的resolve or reject。 4、从上往下执行含有延时的Promise的resolve or reject。 timeOut是个含有返回Promise对象的方法，当执行timeOut(100)时，会生成Promise实例，这里面的4优先打印，then()暂缓； let promise = new Promise({...}),这时候Promise对象已经创建，所以接下来打印1，then()暂缓； 打印同步的3； 从上往下数，第二个promise没有延时，优先打印2。 最后打印5。 6、实现异步加载图片 let url = &quot;图片地址&quot;; function loadImageAsync(url) { return new Promise((resolve, reject) =&gt; { var image = new Image(); image.src = url; image.onload = function() { resolve(image); } image.onerror = function() { reject('加载失败') } }) } loadImageAsync(url).then(val =&gt; {}) 7、总结 ​ 1) 什么是Promise? ​ Promise() 其实是个构造函数，用户可以根据操作状态给与处理。Promise()的prototype提供了多个api，比如all()、race()、then()、catch()、finally()，给实例化的promise对象提供了操作、执行、异常捕捉、后续执行这些方法。 ​ 2）与普通回调函数的区别。 ​ 在执行多项异步操作时，普通的回调函数需要在回调中嵌套回调，代码比较臃肿，容易出现回调地狱。通过promise，可以在then()中resolve返回下一个异步操作，then()返回的是一个新的promise对象，原型对象上存在then(),可以链式调用。 数据结构 Set 构造函数，类似于数组，但是成员的值都是唯一的，可以用于去重（仅适用于普通数组，不适用于对象数组）。 数组去重方法：[ ...new Set(arr) ] 1）Set的属性及方法 ​ constructor: 构造函数，返回Set(); ​ size: 返回实例的成员总数 ​ add(val): 添加某个值，返回Set结构本身 ​ delete(val): 删除某个值，返回boolean; ​ has(val): 查找是否含有某个值，返回boolean; ​ clear(): 清除所有指，没有返回值。 2) Set遍历操作 ​ keys(): 返回键名的遍历器 ​ values(): 返回键值的遍历器 ​ entries(): 返回键值对的遍历器 ​ forEach((value, keys) =&gt; {}) 数据结构Map 构造函数，类似于Object，{ key: value }的形式，但是和Object有区别 Object:只能用字符串当key， &quot;字符串 -&gt; 值&quot; Map: 键的范围不限于字符串，各种类型的值（包括对象）都可以当做key，&quot;值 -&gt; 值&quot;； const map = new Map([['name', 'xiaoming'], ['title', 'author']]) 1）Map的属性和方法 ​ size: 返回Map结构的成员总数 ​ set(key, value): 设置键名为key的对应键值为value，然后返回整个Map。 ​ get(key): 读取键值为key的键值 ​ has(key): 判断某个键是否在当前的Map对象中，返回Boolean。 ​ delete(key): 删除某个值，返回boolean ​ clear(): 清空Map对象 四、ES7~ES12部分常用语法 async 、await 异步终极解决方案。以同步的写法完成异步操作流程，避免异步嵌套。 async: 表示函数里有异步操作。 await: 表示跟随在后面的表达式需要等待结果， await 后面跟着Promise对象 。 当函数执行时一旦遇到await就返回，等到触发的异步操作完成，再接着执行函数体后面的语句。 let timeOut = ms =&gt; { return new Promise((resolve, reject) =&gt; { return setTimeout(resolve, ms, 'timeOut') }) } // 打印顺序 timeOut, 1 let asyncMethod = async () =&gt; { try { let timeConsole = await timeOut(2000); console.log(timeConsole); console.log(1) } catch(e) { console.log(e) } } asyncMethod(); 注意点： await 后面的Promise对象，运行有可能返回reject，最好把await放在try...catch里,这样能够捕捉异常。 await只能用在async函数中，如果是普通函数就会报错。 可以使用 promise.all 方法发起多个请求。 async function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results); } // 或者使用下面的写法 ES9 异步迭代 await可以和for...of循环一起使用，以串行的方式运行异步操作 async function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = []; for (let promise of promises) { results.push(await promise); } console.log(results); } 当出现多个Promise ```javascript let timeOut1 = ms =&gt; { return new Promise((resolve, reject) =&gt; { return setTimeout(resolve, ms, 'timeOut1') }) } let timeOut2 = ms =&gt; { return new Promise((resolve, reject) =&gt; { return setTimeout(resolve, ms, 'timeOut2') }) } let timeOut3 = ms =&gt; { return new Promise((resolve, reject) =&gt; { return setTimeout(resolve, ms, 'timeOut3') }) } let funcArr = [ timeOut1(1000), timeOut2(2000), timeOut3(3000) ] async function promiseFunc() { console.time(); let result = await Promise.all(funcArr); console.log(result); console.timeEnd(); console.log('结束') } promiseFunc(); Array.prototype.includes 返回Boolean，表示某个数组是否包含指定值。 let arr = [1, 2, 3]; if(arr.includes(1)) { console.log('包含') } String.trimStart()和String.trimEnd() 去除字符串首尾空白字符。 空值处理 ?? 表达式在 ?? 的左侧 运算符求值为undefined或null，返回其右侧。 Optional chaining（可选链） ?.用户检测不确定的中间节点 let person = {}; // let childName = person.children.name; // 报错 Cannot read property 'name' of undefined let childName = person.children ?. name; // undefined console.log(childName); 五、参考 Babel官网中文文档：https://www.babeljs.cn/docs/learn Babel官网中文文档：https://www.liaoxuefeng.com/wiki/1022910821149312 阿西河ECMAScript 文档说明：https://www.axihe.com/api/js-es/api/api.html 六、补充 原型、原型链关系 ","link":"https://hviker.github.io/post/pei-xun-es-yu-fa/"},{"title":"培训-Git提交流程","content":"一、目的： ​ 1、增加项目负责人或组长对代码审核操作，对不规范代码及时打回指正。不规范代码指不符合该项目组原定编码规范、可复用功能代码多次编写、垃圾代码垃圾注释等，避免新人多次编写不规范代码。 ​ 2、统一编码规范，便于后期代码交接维护。 二、具体提交流程 1、项目基本设置 ​ 1.1 后期项目负责人在上传项目时，需要设置三个分支。master：主分支(默认存在)，release： 开发分支，test： 测试分支。其中三个分支在允许合并到以及允许推送到上都选择maintainers权限，只能由项目负责人完成三个分支上的操作权限，不允许其他成员通过merge或者push的方式推送项目代码。 ​ 人员设置： 2、个人推送代码方式 ​ 2.1 拉取代码后执行git branch（获取本地所有分支）命令后，显示只有master。对于已经存在的远程分支，需要使用git chekcout 【分支名称】来拉取到本地。这里以拉取已存在的release分支为例： ​ 2.2 执行git checkout -b chore-update-【姓名首字母缩写】创建并切换到属于自己的本地分支,该分支内容与本次切换过来的release分支内容相同。这里也可以由项目负责人提前建好每个人分支名称，这时候就可以跳过接下来的2.3、2.4操作，在个人分支开发完成后直接add、commit、push即可。 ​ Ps:此时只是在本地添加了分支，远程环境上并不存在该分支。 ​ 2.3 后期本人需要在该分支上修改，完成add、commit操作。 ​ 2.4 执行完commit后需要创建同名的远程分支，并做关联。执行命令 git push --set-upstream origin 【同名的远程分支名】，这里以chore-update-lly为例。 ​ 此时再去查看远程分支就多了一项不受保护的远程分支： chore-update-lly ​ **ps:这里如果没有配置SSH会提示没有匹配，所以在使用git时大家一定要关联好自己的SSH。**没有SSH时会报以下错误： ​ 2.5 确定提交到个人分支后，登录117git，选中项目后发起合并请求，确定修改分支和目标分支，并填写审核人员，发起合并申请。并通知审核人员及时审核。 点击比较分支后继续按钮，进入下面页面 下面是负责人相关界面： 这里点击Merge when piole success右侧下拉时会出现两个按钮。第一个是配置自动化部署jenkins并且流水线完成后才合并(这里只是审核代码，不需要合并)。第二个直接点击合并。合并前请项目负责人或者组长做好审查代码工作！！！ 选择第二个后会显示已合并状态，虽然流水线还在等待但是不影响合并功能。 此时查看release记录会增加修改的提交记录,查看release分支后已经存在合并内容。 2.6 合并完成后远程release分支相对于本地的release分支以及本地的chore-update-lly是有区别的，提前于本地分支。为了避免后期合并冲突增多，需要更新本地release以及chore-update-lly分支。 ​ (1) 对于release分支，直接切换到分支执行 git pull --rebase即可。 ​ (2) 对于chore-update-lly分支，需要切换到该分支，然后执行merge命令。经过上述命令可以知道release是最新的，切换到chore-update-lly分支后执行命令 git merge release，git push即可。 上面执行git merge release后，会把release的更新内容更新到本地的chore-update-lly上，但是chore-update-lly是存在没有保护状态远程分支的，这里需要提交下及时更新该远程分支。确保chore-update-lly分支内容与当前release分支最新内容保持一致。 3、常见问题 ​ 3.1 在其他分支修改后如何调整到源分支？例如下图，需要在chore-update-lly上修改，但是却发生在release分支。 ​ 这时候请保持在未add状态，执行git stash将内容暂存，切换到chore-update-lly后再执行git stash pop命令，将暂存内容转移至chore-update-lly分支。 3.2 如果2.6 操作不及时，可能会出现很多冲突。冲突的地方请联系代码提交者合并冲突后再提交。如果冲突过多建议重新创建本地分支及远程分支，将修改内容重新放置新分支上再执行上述操作。远程分支删除一定要跟项目负责人沟通,确认没问题后由项目负责人删除远程分支. ","link":"https://hviker.github.io/post/pei-xun-git-ti-jiao-liu-cheng/"},{"title":"判断js变量类型的几种方法","content":"typeof、instanceof、Object.prototype.toString.call() 当我们需要判断一个变量的类型时经常会用到typeof,但是当去判断一个引用数据类型对象时，它返回的永远是&quot;object&quot;。 这时候我们需要用到instanceof来判断某个对象是不是另一个对象的实例，instanceof运算符用来检测构造函数的prototype属性是否存在于参数object的原型链上。语法： object instanceof constructor 例如我们去判断一个数组 let arr = []; console.log(typeof arr); // 打印 object console.log(arr instanceof Array); // 打印 true 再比如我们去判断person是不是Person的实例 function Person(name) { this.name = name; } let person = new Person(); console.log(typeof person); // 打印 object console.log(person instanceof Person); // 打印true instanceof可以在继承关系中用来判断一个实例是否属于它的父类型。 class Person { constructor(name) { this.name = name; } } class BoyPerson extends Person{ constructor(name, age) { super(name); this.age = age; } } let boy = new BoyPerson('xiaoming', 12); console.log(boy instanceof BoyPerson); // 打印 true console.log(boy instanceof Person); // 打印 true Object.prototype.toString.call(property)也可以判断变量是属于那种内置类型。 Object.prototype.toString.call(null); // &quot;[object Null]&quot; Object.prototype.toString.call(undefined); // &quot;[object Undefined]&quot; Object.prototype.toString.call(“abc”);// &quot;[object String]&quot; Object.prototype.toString.call(123);// &quot;[object Number]&quot; Object.prototype.toString.call(true);// &quot;[object Boolean]&quot; **函数类型** Function fn(){ console.log(“test”); } Object.prototype.toString.call(fn); // &quot;[object Function]&quot; **日期类型** var date = new Date(); Object.prototype.toString.call(date); // &quot;[object Date]&quot; **数组类型** var arr = [1,2,3]; Object.prototype.toString.call(arr); // &quot;[object Array]&quot; **正则表达式** var reg = /[hbc]at/gi; Object.prototype.toString.call(reg); // &quot;[object RegExp]&quot; **自定义类型** function Person(name, age) { this.name = name; this.age = age; } var person = new Person(&quot;Rose&quot;, 18); Object.prototype.toString.call(arr); // &quot;[object Object]&quot; 总结： 如果仅判断基本数据类型，typeof相对简单。 使用上typeof property === 'number' 如果要判断是对象、数组、日期、Function、RegExp，可以使用arr instanceof Array、Object.prototype.toString.call(obj) === '[object, Object]'来判断。 如果判断某变量是某构造函数实例，使用instanceof. ","link":"https://hviker.github.io/post/typeof-yu-instanceof-de-qu-bie/"},{"title":"apply、call、bind","content":"1、作用 都是为了改变某个函数运行时的上下文(context)，也就是改变函数内部的this指向,继承其他对象的属性。 三个方法是每个函数都有的__proto__，而且是非继承而来的方法。 通俗来讲，A、B为构造函数对象，A有C方法，B没有C方法。 如果你想让B去调用C方法，就使用A.C.apply(B) or A.C.call(B) or A.C.bind(B); 2、使用方式 ​ apply(obj, [])： apply方法后面跟两个参数，第一个参数是要指向的obj对象，第二个参数是数组。 ​ call(obj, property)：call方法后面跟多个参数，第一个参数是要指向的obj对象，从第二个参数起就是单个要传递的属性。 ​ bind(obj, [])(): 相比于apply来说，使用上加个(). 以Person为例，使用Person.apply(this, [name, age])。 // 定义Person类 function Person (name, age) { this.name = name; this.age = age; this.getPersonInfo = function() { console.log(`姓名：${this.name} 年龄：${this.age}`) } } // 定义学生类 function Student (name, age, grade) { Person.apply(this, [name, age]); // 这里使用apply,其中第一个参数是this,指向student this.grade = grade; } let student = new Student('xiaming', 18, '1'); console.log(student); student.getPersonInfo(); 打印结果： 从打印结果上看，student多了name，age以及getPersonInfo(),其来源就是继承于Person。 call 比 apply 的性能要好，平常可以多用 call, call 传入参数的格式正是内部所需要的格式。 3、关于apply的思考 我们在调用apply()的时候，第二个参数是个数组，它可以将数组（ [ param1, param2, param3] ）默认转化成属性参数的形式（param1, param2, param3）,利用这一特点可以在需要属性传值的地方使用apply()传入对应数组，简化代码。 例如我们要取数组的最大值，但是Math.max()不支持传入数组，这时候可以使用Math.max(null, arr)。这里第一个参数传入null，是因为没有对象去调用这回方法，我们只需要调用到Math的max()返回结果就行了。 4、使用场景 继承。如上例person. 获取数组最大值或者最小值。 最大值：Math.max.apply(null, arr); 最小值： Math.min.apply(null, arr) 合并数组，但是不会去重。 let arr1 = [1, 2, 3], arr2 = [3, 5, 6]; Array.prototype.push.apply(arr1, arr2); console.log(arr1); // 打印 [1, 2, 3, 3, 5, 6] console.log(arr2); // 打印 [1, 2, 3] ","link":"https://hviker.github.io/post/applycallbind/"},{"title":"工程化注册Vue全局组件","content":"Q1: 前端工程化注册全局组件 借助webpack的require.context() 来创建模块的上下文，然后实现自动动态require组件。这里以引入全局组件为例。 1、文件目录及命名方式 其中globals文件夹为全局组件存放位置。require,context()在使用时需要定位所在文件夹的位置，建议将全局组件放到一个文件夹下。 global文件夹下存放install.js(用于实现工程化注册全局组件)，以及各全局组件具体实现。 全局组件实现过程中可能会进行进一步拆分，建议分主文件和拆分文件，主文件命名建议：文件夹名称_index.vue，拆分文件命名建议：_功能名称，vue。 主文件命名原因：1) 方便开发工具、控制台定位调试。 2) 本工程化是正则匹配以_index.vue结尾的文件。 拆分文件命名只要不和主文件正则匹配冲突即可。 2、install.vue实现 // 组件名称首字母大写 function toUpperStrStart(str) { return str.charAt(0).toUpperCase() + str.slice(1); } const globalComponent = require.context('./', true, /\\_index.vue$/); // 全局匹配globals文件夹下所有的以_index.vue结尾的文件 const install = Vue =&gt; { globalComponent.keys().forEach(item =&gt; { let config = globalComponent(item); let { name, __file } = config.default || config; if(!name) throw new Error(`组件name属性不存在，请按照格式填写。文件地址:${__file}`) Vue.component(toUpperStrStart(name), config.default || config) }) } export default { install } 这里调用Vue.component()需要组件名称name、组件。组件获取直接拿config.default。在name处理上，我们要求组件的name必须存在，如果不存在的话给出错误提示。这里多做了一步处理，强制让name的首字母大写，主要是为了符合组件的命名规范。 然后返回install(),便于main函数值直接Vue.use()调用。 3、main.js调用 import globalComponent from './components/globals/install' Vue.use(globalComponent); ","link":"https://hviker.github.io/post/gong-cheng-hua-zhu-ce-quan-ju-zu-jian/"},{"title":"如何封装全局组件并且被Vue.use(plugin) 使用","content":"1、首先我们要先了解下Vue.use(plugin)的用法。 参数： {Object | Function} plugin 用法： 安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。 该方法需要在调用 new Vue() 之前被调用。 当 install 方法被同一个插件多次调用，插件将只会被安装一次。 下面是vue2.0源码，使用vue.use(plugins)其实是将plugin放到vue构造器的_installedPlugins属性里，防止重复安装，并且以Vue.component的方式做全局组件。 Vue.use = function (plugin) { // 获取vue构造器当前已经use的组件，如果组件已经存在则返回当前vue对象，避免同一组件重复use var installedPlugins = (this._installedPlugins || (this._installedPlugins = [])); if (installedPlugins.indexOf(plugin) &gt; -1) { return this } // additional parameters // 将类数组对象转化成数组，满足apply(对象， 数组) var args = toArray(arguments, 1); args.unshift(this); if (typeof plugin.install === 'function') { plugin.install.apply(plugin, args); } else if (typeof plugin === 'function') { plugin.apply(null, args); } // 填充到vue的_installedPlugins中 installedPlugins.push(plugin); return this }; plugin必须是个对象或者方法，对象的话必须存在install(), 方法的话默认该方法就是install(); 2、如何封装自己的组件 ​ 这里分自写组件库使用和自己项目上使用。 自写组件库使用 参考element-ui，具体分层和代码如下 1) 按照包格式编写组件。 内容： 2）各文件内容 /dbutton/src/main.vue &lt;template&gt; &lt;button class=&quot;btn&quot;&gt;点击&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;Dbutton&quot;, // 这里名称建议为组件包名称，首字母大写 components: {}, data() { return {}; }, computed: {}, watch: {}, created() {}, mounted() {}, methods: {}, }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; //@import url(); 引入公共css类 .btn { padding: 12px 20px; font-size: 16px; background: blue; border-radius: 5px; color: #ffffff; &amp;:hover { background: red; } } &lt;/style&gt; /dbutton/src/index.js import Dbutton from './src/main'; // 给单独的组件添加install事件，便于按需注册 Dbutton.install = Vue =&gt;{ Vue.component(Dbutton.name, Dbutton); } export default Dbutton; /dbutton/src/install.js import Dbutton from './dbutton/index.js'; // 这里为组件数组，便于install方法循环 const commonComponnet = [ Dbutton ] // 注册全局install方法，这里的install会循环遍历component,给vue实例注册全局组件 const install = function (Vue, options = {}) { commonComponnet.forEach(component =&gt; { Vue.component(component.name, component) }) } // 导出对象，对象属性为各组件，以及install方法 export default { install, Dbutton } 3) main.js使用 全局引入。这里使用use不仅会调用全局的install(),也会调用各组件的install(),但是没有影响。vue.use()已经给我们做了处理，相同组件只允许注册一次。 import HavikerUI from './components/install'; Vue.use(HavikerUI); 局部引入。这样的话就只会调用Dbutton的install(). import HavikerUI from './components/install'; const { install, Dbutton } = HavikerUI; Vue.use(Dbutton); 项目使用 项目上所使用的组件分为两种，全局组件和局部组件。局部组件在对应页面import后使用即可，全局组件去掉/dbutton/src/index.js，修改/dbutton/src/install.js的引入，改为import Dbutton from './src/main'; 即可。 如何开发插件 Vue.js 要求插件应该有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象。 在 install 方法里面，便可以做相关的处理： 添加全局方法或者属性 添加全局资源：指令/过滤器/过渡等， 通过全局 mixin 方法添加一些组件选项， 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。 一个库，提供自己的 API，同时提供上面提到的一个或多个功能 MyPlugin.install = function (Vue, options) { // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () { // 逻辑... } // 2. 添加全局资源 Vue.directive('my-directive', { bind (el, binding, vnode, oldVnode) { // 逻辑... } ... }) // 3. 注入组件 Vue.mixin({ created: function () { // 逻辑... } ... }) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) { // 逻辑... } } ","link":"https://hviker.github.io/post/ru-he-feng-zhuang-quan-ju-zu-jian-bing-qie-bei-vueuseplugin-shi-yong/"},{"title":"vue强制跳转","content":"url相同、参数不同。强制跳转刷新 跳转方法 wlb(){ this.$router.push({ path: '/zxxx/index', query: { index: '1' } }) }, wkc(){ this.$router.push({ path: '/zxxx/index', query: { index: '0'} }) }, 当在path为'/zxxx/index'页面，点击wlb()、wkc() 方法时是不走vue生命周期函数的。需要监听$route变化。 '$route'(to, from) { let { index } = to.query; this.activeName = index === '1' ? 'second' : 'first' this.handleClick({index: index}) } ","link":"https://hviker.github.io/post/vue-qiang-zhi-tiao-zhuan/"},{"title":"arguments使用","content":"以类数组对象的形式存储函数实参。 1、作用: 获取实参。 arguments.callee()方法返回当前方法，可以用于递归。 let organizeArr = [ { id: '01', name: 'xiaoming', children: [ { id: '0101', name: 'xiaoming1', children: [ { id: '010101', name: 'xiaoming2', children: [] } ] }, { id: '0102', name: 'xiaoming3', children: [ { id: '010201', name: 'xiaoming4', children: [] } ] } ] } ] function printName(arr) { console.log(arguements); arr.forEach(item =&gt; { console.log(item.name); if(item.children &amp;&amp; Array.isArray(item.children)) { // 这里递归 arguments.callee(item.children) } }); } printName(organizeArr); 2、转变成数组方法:toArray() /** * 取自vue2.0源码 将一个类数组对象转化成数组 * Convert an Array-like object to a real Array. */ function toArray (list, start) { start = start || 0; var i = list.length - start; var ret = new Array(i); while (i--) { ret[i] = list[i + start]; } return ret } ","link":"https://hviker.github.io/post/arguments-shi-yong/"},{"title":"el-table表格合并","content":"1、实现效果 2、代码实现 &lt;el-table :data=&quot;basePerformanceInfoTable&quot; border style=&quot;width: 100%&quot; :span-method=&quot;objectSpanMethod&quot; &gt; &lt;el-table-column prop=&quot;variety&quot; label=&quot;品种&quot; width=&quot;150&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;shape&quot; label=&quot;形状&quot; width=&quot;80&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;deliveryState&quot; label=&quot;交货状态&quot; width=&quot;150&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;specification&quot; label=&quot;规格&quot; width=&quot;100&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;详情&quot; class=&quot;remarkInfo&quot; &gt; &lt;template slot-scope=&quot;{row}&quot;&gt; &lt;ul class=&quot;remarkTableInfo clearfix&quot;&gt; &lt;li :title=&quot;row.performanceKey&quot;&gt;{{ row.performanceKey }}&lt;/li&gt; &lt;li :title=&quot;row.performanceValue&quot;&gt;{{ row.performanceValue }}&lt;/li&gt; &lt;li :title=&quot;row.remarkTitle&quot;&gt;{{ row.remarkTitle }}&lt;/li&gt; &lt;li :title=&quot;row.remark&quot;&gt;{{ row.remark }}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; // 材料搜索详情 export const MainInfo = { data() { return { previousItem: null, // 循环的上一个元素 spanArr: [], //用于存放每一行记录的合并数 pos: 0, // spanArr的索引 basePerformanceInfoTable: [ // 基本力学性能table数据 { variety: &quot;06Ni9DR-板(5~30)&quot;, shape: &quot;板&quot;, deliveryState: &quot;淬火+回火&quot;, specification: &quot;5~30&quot;, performanceKey: &quot;ReL(MPa)&quot;, performanceValue: &quot;≥560&quot;, remarkTitle: &quot;说明&quot;, remark: &quot;屈服不明显时，采用Rp0.2&quot;, }, { variety: &quot;06Ni9DR-板(5~30)&quot;, shape: &quot;板&quot;, deliveryState: &quot;淬火+回火&quot;, specification: &quot;5~30&quot;, performanceKey: &quot;Rm(MPa)&quot;, performanceValue: &quot;680~820&quot;, remarkTitle: &quot;说明&quot;, remark: &quot;&quot;, }, { variety: &quot;06Ni9DR-板(5~30)&quot;, shape: &quot;板&quot;, deliveryState: &quot;淬火+回火&quot;, specification: &quot;5~30&quot;, performanceKey: &quot;A(%)&quot;, performanceValue: &quot;≥18&quot;, remarkTitle: &quot;说明&quot;, remark: &quot;&quot;, }, { variety: &quot;06Ni9DR-板(&gt;30~50)&quot;, shape: &quot;板&quot;, deliveryState: &quot;淬火+回火&quot;, specification: &quot;&gt;30~50&quot;, performanceKey: &quot;ReL(MPa)&quot;, performanceValue: &quot;≥550&quot;, remarkTitle: &quot;说明&quot;, remark: &quot;屈服不明显时，采用Rp0.2&quot;, }, { variety: &quot;06Ni9DR-板(&gt;30~50)&quot;, shape: &quot;板&quot;, deliveryState: &quot;淬火+回火&quot;, specification: &quot;5~30&quot;, performanceKey: &quot;Rm(MPa)&quot;, performanceValue: &quot;680~820&quot;, remarkTitle: &quot;说明&quot;, remark: &quot;&quot;, }, ], }; }, methods: { // 合并数组 getSpanArr(data) { data.forEach((item, index) =&gt; { if (index === 0) { this.spanArr.push(1); this.pos = 0; } else { // 判断当前元素是否与上一个元素相同,根据合并字段匹配 if (item.variety == this.previousItem.variety) { this.spanArr[this.pos] += 1; this.spanArr.push(0); } else { this.spanArr.push(1); this.pos = index; } } this.previousItem = item; }); }, // 表格合并方法 objectSpanMethod({ row, column, rowIndex, columnIndex }) { if (columnIndex !== 4) { let _row = this.spanArr[rowIndex]; let _col = _row &gt; 0 ? 1 : 0; return { rowspan: _row, colspan: _col, }; } }, }, created() { this.getSpanArr(this.basePerformanceInfoTable); } } ","link":"https://hviker.github.io/post/el-table-biao-ge-he-bing/"},{"title":"高级搜索实现","content":"1、实现效果 页面初始化效果 单选选中效果 全部选择效果 取消选中(点击各查询条件或者已选条件的叉号) 2、代码实现 主页面方法 &lt;template&gt; &lt;div class=&quot;pageContainer&quot;&gt; &lt;div class=&quot;superSearchArea&quot; v-show=&quot;!searchMoreFlag&quot;&gt; &lt;div class=&quot;clearfix&quot; v-for=&quot;renderItem in renderEntity&quot; :key=&quot;renderItem.entityType&quot; &gt; &lt;div :class=&quot;renderItem.isSelectTypeNameClass ? 'selectTitle selectTitleSpace fl': 'selectTitle fl'&quot;&gt;{{ renderItem.selectTypeName }}&lt;/div&gt; &lt;div class=&quot;selectType&quot;&gt; &lt;div :class=&quot;submitReadySelectObj[renderItem.entityType].length === renderItem.entityList.length ? 'selectAll fl selectAllActive': 'selectAll fl '&quot; @click=&quot;handleAllSelect(renderItem.entityType)&quot; &gt; {{ renderItem.allSelectName }} &lt;/div&gt; &lt;div v-for=&quot;item in renderItem.entityList&quot; :key=&quot;item.key&quot; @click=&quot;handleSelectType(item.type, item.key, item.value, item.id, renderItem.entityType)&quot; :class=&quot;item.isSelect ? 'selectItem selectActive' : 'selectItem'&quot; &gt; {{ item.value }} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 已选条件 --&gt; &lt;div class=&quot;clearfix&quot;&gt; &lt;div class=&quot;selectTitle fl&quot;&gt;已选条件&lt;/div&gt; &lt;ul class=&quot;readySelectType fl clearfix&quot;&gt; &lt;li v-for=&quot;item in allReadySelectArr&quot; :key=&quot;item.key&quot; &gt; &lt;span class=&quot;fl&quot;&gt;{{ item.text }}&lt;/span&gt;&lt;label class=&quot;fr&quot; @click=&quot;delReadySelectItem(item.key, item.list, item.id)&quot; &gt;X&lt;/label&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!-- 化学成分,力学性能,关键字搜素 --&gt; &lt;select-component :keyWords=&quot;keyWords&quot; :materialArr=&quot;materialArr&quot; :dynamicsArr=&quot;dynamicsArr&quot; @changeKeyWords=&quot;changeKeyWords&quot; ref=&quot;selectComponent&quot; &gt;&lt;/select-component&gt; &lt;!-- 搜素及清空条件 --&gt; &lt;div class=&quot;searchBtnArea&quot;&gt; &lt;div class=&quot;clearInfo fr&quot; @click=&quot;clearSelectInfo&quot; &gt; &lt;img src=&quot;@/assets/mainPage/clearinfo.png&quot; alt=&quot;clearinfo&quot; /&gt; 清空条件 &lt;/div&gt; &lt;div class=&quot;searchBtn&quot;&gt; &lt;el-button type=&quot;danger&quot; @click=&quot;searchInfo&quot; &gt;搜索&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 底部表格 --&gt; &lt;el-table :data=&quot;tableData&quot; style=&quot;width: 100%&quot; &gt; &lt;el-table-column label=&quot;牌号&quot;&gt; &lt;template slot-scope=&quot;{row}&quot;&gt; &lt;span @click=&quot;handleGoInfo('gcss', row.steelNum)&quot; class=&quot;handGoInfo&quot; &gt; {{ row.steelNum }} &lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;applyStandard&quot; label=&quot;适用标准&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;system&quot; label=&quot;体系&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;steelNum&quot; label=&quot;牌号&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;dataSource&quot; label=&quot;数据来源&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;materialType&quot; label=&quot;材料类别&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;配送信息&quot;&gt; &lt;el-table-column prop=&quot;C&quot; label=&quot;C&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;Si&quot; label=&quot;Si&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;Mn&quot; label=&quot;Mn&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;P&quot; label=&quot;P&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;S&quot; label=&quot;S&quot; &gt; &lt;/el-table-column&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;力学性能&quot;&gt; &lt;el-table-column prop=&quot;YS&quot; label=&quot;YS&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;Rm&quot; label=&quot;Rm&quot; &gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;Akv&quot; label=&quot;Akv&quot; &gt; &lt;/el-table-column&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 分页插件 --&gt; &lt;pagination v-show=&quot;total &gt; 0&quot; :total=&quot;total&quot; :page.sync=&quot;listQuery.page&quot; :limit.sync=&quot;listQuery.limit&quot; @pagination=&quot;getList&quot; /&gt; &lt;/div&gt; &lt;/template&gt;value &lt;script&gt; import { SelectType } from &quot;@/mixins/shycss/selectType&quot;; export default { name: &quot;Gcss&quot;, components: {}, mixins: [SelectType], props: { searchMoreFlag: { type: Boolean, default: false, }, }, data() { return { matchRelation: { // list 与 type对应关系， 主要是用于type对应 steelTypeList: &quot;SteelTypeList&quot;, shapeTypeList: &quot;ShapeTypeList&quot;, productCategoryTypeList: &quot;ProductCategoryTypeList&quot;, deliveryStateTypeList: &quot;DeliveryStateTypeList&quot;, standardTypeList: &quot;StandardTypeList&quot;, }, submitReadySelectObj: { // 查询条件提交数组，放在对象中方便提交 steelTypeList: [], // 钢类 shapeTypeList: [], // 形状 productCategoryTypeList: [], // 产品类别 deliveryStateTypeList: [], // 交货状态 standardTypeList: [], // 标准体系 }, steelTypeList: [ // 钢类数组，type: 类别， id: 后台返回唯一键， value: 显示名称 key: 前端唯一键(这里使用v-for循环，且存在多个查询条件，为避免前端v-for在指定key时报错重复，这里组合前端唯一键，使用type_id的形式，如果确定id唯一可删除，isSelect: 选中状态) { type: &quot;SteelTypeList&quot;, id: &quot;g01&quot;, value: &quot;碳素结构钢&quot;, key: &quot;SteelTypeList_g01&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g02&quot;, value: &quot;低合金高强度钢&quot;, key: &quot;SteelTypeList_g02&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g03&quot;, value: &quot;合金结构钢&quot;, key: &quot;SteelTypeList_g03&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g04&quot;, value: &quot;不锈钢&quot;, key: &quot;SteelTypeList_g04&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g05&quot;, value: &quot;易切削钢&quot;, key: &quot;SteelTypeList_g05&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g06&quot;, value: &quot;弹簧钢&quot;, key: &quot;SteelTypeList_g06&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g07&quot;, value: &quot;耐热钢&quot;, key: &quot;SteelTypeList_g07&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g08&quot;, value: &quot;工模具钢&quot;, key: &quot;SteelTypeList_g08&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g09&quot;, value: &quot;轴承钢&quot;, key: &quot;SteelTypeList_g09&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g10&quot;, value: &quot;弹簧钢&quot;, key: &quot;SteelTypeList_g10&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g11&quot;, value: &quot;铸钢铸铁&quot;, key: &quot;SteelTypeList_g11&quot;, isSelect: false, }, { type: &quot;SteelTypeList&quot;, id: &quot;g12&quot;, value: &quot;耐候钢&quot;, key: &quot;SteelTypeList_g12&quot;, isSelect: false, }, ], shapeTypeList: [ // 形状数组 { type: &quot;ShapeTypeList&quot;, id: &quot;xz01&quot;, value: &quot;板&quot;, key: &quot;ShapeTypeList_xz01&quot;, isSelect: false, }, { type: &quot;ShapeTypeList&quot;, id: &quot;xz02&quot;, value: &quot;带&quot;, key: &quot;ShapeTypeList_xz02&quot;, isSelect: false, }, { type: &quot;ShapeTypeList&quot;, id: &quot;xz03&quot;, value: &quot;薄带&quot;, key: &quot;ShapeTypeList_xz03&quot;, isSelect: false, }, { type: &quot;ShapeTypeList&quot;, id: &quot;xz04&quot;, value: &quot;棒&quot;, key: &quot;ShapeTypeList_xz04&quot;, isSelect: false, }, { type: &quot;ShapeTypeList&quot;, id: &quot;xz05&quot;, value: &quot;线&quot;, key: &quot;ShapeTypeList_xz05&quot;, isSelect: false, }, ], productCategoryTypeList: [ // 产品类别 { type: &quot;ProductCategoryTypeList&quot;, id: &quot;cplb01&quot;, value: &quot;热轧钢&quot;, key: &quot;ProductCategoryTypeList_cplb01&quot;, isSelect: false, }, { type: &quot;ProductCategoryTypeList&quot;, id: &quot;cplb02&quot;, value: &quot;冷轧钢&quot;, key: &quot;ProductCategoryTypeList_cplb02&quot;, isSelect: false, }, { type: &quot;ProductCategoryTypeList&quot;, id: &quot;cplb03&quot;, value: &quot;无缝管&quot;, key: &quot;ProductCategoryTypeList_cplb03&quot;, isSelect: false, }, { type: &quot;ProductCategoryTypeList&quot;, id: &quot;cplb04&quot;, value: &quot;焊管&quot;, key: &quot;ProductCategoryTypeList_cplb04&quot;, isSelect: false, }, { type: &quot;ProductCategoryTypeList&quot;, id: &quot;cplb05&quot;, value: &quot;铸造管&quot;, key: &quot;ProductCategoryTypeList_cplb05&quot;, isSelect: false, }, ], deliveryStateTypeList: [ // 交货状态 { type: &quot;DeliveryStateTypeList&quot;, id: &quot;jhzt01&quot;, value: &quot;热轧&quot;, key: &quot;DeliveryStateTypeList_jhzt01&quot;, isSelect: false, }, { type: &quot;DeliveryStateTypeList&quot;, id: &quot;jhzt02&quot;, value: &quot;冷轧&quot;, key: &quot;DeliveryStateTypeList_jhzt02&quot;, isSelect: false, }, { type: &quot;DeliveryStateTypeList&quot;, id: &quot;jhzt03&quot;, value: &quot;热加工&quot;, key: &quot;DeliveryStateTypeList_jhzt03&quot;, isSelect: false, }, { type: &quot;DeliveryStateTypeList&quot;, id: &quot;jhzt04&quot;, value: &quot;冷加工&quot;, key: &quot;DeliveryStateTypeList_jhzt04&quot;, isSelect: false, }, ], standardTypeList: [ // 标准体系 { type: &quot;StandardTypeList&quot;, id: &quot;bztx01&quot;, value: &quot;所有企业标准&quot;, key: &quot;StandardTypeList_bztx01&quot;, isSelect: false, }, { type: &quot;StandardTypeList&quot;, id: &quot;bztx02&quot;, value: &quot;中国(GB)&quot;, key: &quot;StandardTypeList_bztx02&quot;, isSelect: false, }, { type: &quot;StandardTypeList&quot;, id: &quot;bztx03&quot;, value: &quot;日本(JIS)&quot;, key: &quot;StandardTypeList_bztx03&quot;, isSelect: false, }, { type: &quot;StandardTypeList&quot;, id: &quot;bztx04&quot;, value: &quot;美国(ASTM)&quot;, key: &quot;StandardTypeList_bztx04&quot;, isSelect: false, }, ], allReadySelectArr: [], // 所有选中数组，显示使用 tableData: [ { steelNum: &quot;06Ni1DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni2DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni3DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni4DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni5DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni6DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni7DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, { steelNum: &quot;06Ni8DR&quot;, applyStandard: &quot;GB 3531-2014&quot;, system: &quot;中国GB&quot;, dataSource: &quot;新材道公有云&quot;, materialType: &quot;钢材&quot;, C: &quot;≤0.08&quot;, Si: &quot;0.15~0.35&quot;, Mn: &quot;0.3~0.8&quot;, P: &quot;≤0.008&quot;, S: &quot;≤0.004&quot;, YS: &quot;≥560&quot;, Rm: &quot;680~820&quot;, Akv: &quot;≥100&quot;, }, ], materialArr: [ // 化学性能 { key: &quot;C&quot;, value: &quot;C&quot; }, { key: &quot;Si&quot;, value: &quot;Si&quot; }, { key: &quot;Mr&quot;, value: &quot;Mr&quot; }, { key: &quot;P&quot;, value: &quot;P&quot; }, { key: &quot;S&quot;, value: &quot;S&quot; }, ], dynamicsArr: [ // 力学性能 { key: &quot;qfqd&quot;, value: &quot;屈服强度YS(MPa)&quot; }, { key: &quot;cjg&quot;, value: &quot;冲击功Akv(J)&quot; }, { key: &quot;cjwd&quot;, value: &quot;冲击温度(℃)&quot; }, { key: &quot;klqd&quot;, value: &quot;抗拉强度TS(MPa)&quot; }, { key: &quot;ysl&quot;, value: &quot;延伸率A(%)&quot; }, ], }; }, watch: { // searchMoreFlag(newVal) { // console.log(&quot;flag&quot; + newVal); // }, }, computed: {}, methods: { // 清空搜素条件 clearSelectInfo() { // submitReadySelectObj数据清空 this.submitReadySelectObj = { // 查询条件提交数组 steelTypeList: [], // 钢类 shapeTypeList: [], // 形状 productCategoryTypeList: [], // 产品类别 deliveryStateTypeList: [], // 交货状态 standardTypeList: [], // 标准体系 }; // 将数据中的isSelect置为false this.steelTypeList = [...this.resetIsSelect(this.steelTypeList)]; this.shapeTypeList = [...this.resetIsSelect(this.shapeTypeList)]; this.productCategoryTypeList = [ ...this.resetIsSelect(this.productCategoryTypeList), ]; this.deliveryStateTypeList = [ ...this.resetIsSelect(this.deliveryStateTypeList), ]; this.standardTypeList = [...this.resetIsSelect(this.standardTypeList)]; // allReadySelectArr清空 this.allReadySelectArr = []; // selectComponent数据清空 this.$refs.selectComponent.clearSelectInfo(); }, // 搜索 searchInfo() { // 获取selectComponent中的查询内容 let selectComponentInfo = this.$refs.selectComponent.getSelectInfo(); // todo 这里需要组合其他查询条件进行请求数据 this.searchData(); }, // 查询数据 searchData() {}, }, created() {}, mounted() { // 修改数据格式，渲染实体 this.renderEntity = [ { selectTypeName: &quot;钢类&quot;, allSelectName: &quot;全部&quot;, isSelectTypeNameClass: true, entityType: &quot;steelTypeList&quot;, entityList: this.steelTypeList, }, { selectTypeName: &quot;形状&quot;, allSelectName: &quot;全部&quot;, isSelectTypeNameClass: false, entityType: &quot;shapeTypeList&quot;, entityList: this.shapeTypeList, }, { selectTypeName: &quot;产品类别&quot;, allSelectName: &quot;全部&quot;, isSelectTypeNameClass: false, entityType: &quot;productCategoryTypeList&quot;, entityList: this.productCategoryTypeList, }, { selectTypeName: &quot;交货状态&quot;, allSelectName: &quot;全部&quot;, isSelectTypeNameClass: false, entityType: &quot;deliveryStateTypeList&quot;, entityList: this.deliveryStateTypeList, }, { selectTypeName: &quot;标准体系&quot;, allSelectName: &quot;所有国际及行业标准&quot;, isSelectTypeNameClass: false, entityType: &quot;standardTypeList&quot;, entityList: this.standardTypeList, }, ]; }, }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; &lt;/style&gt; 复用方法 import SelectComponent from '@/views/shycss/component/selectComponent_index'; import Pagination from &quot;@/components/Pagination/Pagination_index&quot;; export const SelectType = { components: { SelectComponent, Pagination }, props: { searchMoreFlag: { type: Boolean, }, keyWords: { type: String } }, data() { return { allReadySelectArr: [], // 所有选中数组，显示使用 renderEntity: [], // 渲染实体 total: 8, // 数据总条数 listQuery: { page: 1, // 当前页 limit: 20, // 每页条数 } } }, methods: { // 分页查询方法 getList(obj) { this.listQuery.page = obj.page; this.listQuery.limit = obj.limit; this.searchData(); }, // 修改关键字 changeKeyWords(val) { this.$emit(&quot;changeKeyWords&quot;, val) }, // 将数组中的isSelect置为false resetIsSelect(arr) { arr.forEach(item =&gt; { item.isSelect = false; }) return arr; }, // 查询条件 handleSelectType(type, key, text, id, list) { this[list].some((item) =&gt; { if (item.key == key) { this.changeSelectItemState(item.isSelect, key, type, id, list, text); item.isSelect = !item.isSelect; return true; } }); }, // 根据查询条件当前选中状态动态新增/删除显示选中数组和提交显示数组中的数据 // 如果原来是选中状态，则点击后为非选中状态，需要在所有选中数组中删除 // 如果原来是非选中状态，则点击后为选中状态，需要在所有选中数组中添加 changeSelectItemState(isSelect, key, type, id, list, text) { if (isSelect) { // 删除已选数组中的数组 this.delFromAllReadyArr(key); // 删除提交数组中的数据 this.delFromSubmitReadySelectArr(list, id); } else { // 新增已选显示数组中的数据 this.addToAllReadyArr(key, text, list, id); // 新增提交数组中的数据 this.addToSubmitReadySelectArr(type, id, text, list); } }, // 添加到显示选中数组 addToAllReadyArr(key, text, list, id) { this.allReadySelectArr.push({ key: key, text: text, list: list, id: id }); }, // 添加到提交选中数组中 addToSubmitReadySelectArr(type, id, text, list) { let obj = { key: id, value: text, type: type }; this.submitReadySelectObj[list].push(obj); }, // 从显示选中数组中删除 delFromAllReadyArr(key) { let flag = false; let index = 0; this.allReadySelectArr.some((item) =&gt; { if (item.key == key) { flag = true; return true; } index++; }); flag &amp;&amp; this.allReadySelectArr.splice(index, 1); }, // 删除提交数组中的数据 delFromSubmitReadySelectArr(list, id) { let flag = false, index = 0; this.submitReadySelectObj[list].some((item) =&gt; { if (item.key == id) { flag = true; return true; } index++; }); flag &amp;&amp; this.submitReadySelectObj[list].splice(index, 1); }, // 删除所选选项 delReadySelectItem(key, list, id) { // 删除显示选中数组中的对应数据 this.delFromAllReadyArr(key); // 删除提交选中数组中的对应数据 this.delFromSubmitReadySelectArr(list, id); // 取消查询条件的选中样式 this.cancelIsSelect(this[list], key); // 查询数据 this.searchData(); }, // 取消查询条件选中状态 cancelIsSelect(arr, key) { arr.some((item) =&gt; { if (item.key == key) { item.isSelect = false; return true; } }); }, // 点击全部按钮 handleAllSelect(list) { // 判断提交选中数组中的个数是否等于list数组的个数 // 如果是则删除显示数组中所有该类型数据，提交数组置空,然后将所有该类型数据select置为false // 如果否则说明存在所有或部分数据未被选中，这时候删除显示数组中所有该类型数据，并新增数据；提交选中数组中将该类型所有数据填充，然后将所有该类型数据select置为true if (!this.submitReadySelectObj[list] || !this.matchRelation[list]) return; // 循环删除显示数组中所有该类型数据 this.delSpecTypeFromAllReadySelelctArr(list); if (this.submitReadySelectObj[list].length === this[list].length) { // 提交数组置空 this.submitReadySelectObj[list] = []; this[list].forEach((item) =&gt; { // 将所有选项改为非选中状态 item.isSelect = false; }); } else { // 提交数组置空 this.submitReadySelectObj[list] = []; this[list].forEach((item) =&gt; { // push到显示选中数组的对象 let obj1 = { key: item.key, text: item.value, list: list, id: item.id, }; // push到提交选中数组的对象 let obj2 = { key: item.id, value: item.value, type: this.matchRelation[list], }; this.allReadySelectArr.push(obj1); this.submitReadySelectObj[list].push(obj2); // 将所有选项改为选中状态 item.isSelect = true; }); } this.searchData(); }, // 循环删除显示数组中所有该类型数据 delSpecTypeFromAllReadySelelctArr(list) { for (let i = this.allReadySelectArr.length - 1; i &gt;= 0; i--) { if (this.allReadySelectArr[i].list == list) { this.allReadySelectArr.splice(i, 1); } } }, // 跳转详情 handleGoInfo(type, steelName) { switch(type) { case &quot;gcss&quot;: this.$router.push({ path: '/shycss/gcssMainInfo', query: { name: steelName } }) break; case &quot;yshjsu&quot;: this.$router.push({ path: '/shycss/yshjssMainInfo', query: { name: steelName } }) break; case &quot;hcss&quot;: this.$router.push({ path: '/shycss/hcssMainInfo', query: { name: steelName } }) break; } } } } ","link":"https://hviker.github.io/post/gao-ji-sou-suo-shi-xian/"},{"title":"防抖-监听浏览器窗口变化","content":"addListenerResize: function() { var self = this; window.addEventListener('resize', self.resizeDebounce(self.testFunc, 1000), false) }, resizeDebounce: function(func, wait) { let timeout = null; return function() { if(timeout) clearInterval(timeout); timeout = setTimeout(function(){ func.apply(this, arguments); }, wait) } }, testFunc:function(){ console.log(1) } echarts示例 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;财务与资产管理&lt;/title&gt; &lt;style&gt; html, body { width: 100%; height: 400px; } .container { width: 100%; height: 400px; } .echartsView { width: 15%; height: 400px; float: left; } p { margin: 0; padding: 0; } .tootTipCircle { display: inline-block; width: 10px; height: 10px; border-radius: 5px; } .tootTipInsideText { margin-left: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div id=&quot;app1&quot; class=&quot;echartsView&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app2&quot; class=&quot;echartsView&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app3&quot; class=&quot;echartsView&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app4&quot; class=&quot;echartsView&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app5&quot; class=&quot;echartsView&quot;&gt;&lt;/div&gt; &lt;div id=&quot;app6&quot; class=&quot;echartsView&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;../lib/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../lib/echart/echarts.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;../js/echartsColor.js&quot;&gt;&lt;/script&gt; &lt;script&gt; (function () { $(document).ready(function () { echartsEntity.init(); echartsEntity.addListenerResize(); }) var echarts1 = echarts.init(document.getElementById(&quot;app1&quot;)) var echarts2 = echarts.init(document.getElementById(&quot;app2&quot;)) var echarts3 = echarts.init(document.getElementById(&quot;app3&quot;)) var echarts4 = echarts.init(document.getElementById(&quot;app4&quot;)) var echarts5 = echarts.init(document.getElementById(&quot;app5&quot;)) var echarts6 = echarts.init(document.getElementById(&quot;app6&quot;)) var echartsEntity = { init: function () { var self = this; var echarts1Data = { category: ['1月', '2月', '3月', '4月', '5月'], barData: [260, 280, 300, 180, 400] } this.drawEcharts(echarts1, echarts1Data, true, true); this.drawEcharts(echarts2, echarts1Data, false, false); this.drawEcharts(echarts3, echarts1Data, false, true); this.drawEcharts(echarts4, echarts1Data, false, false); this.drawEcharts(echarts5, echarts1Data, false, true); this.drawEcharts(echarts6, echarts1Data, false, true); echarts.connect([echarts1, echarts2, echarts3, echarts4, echarts5, echarts6]); }, // 绘制柱状图, echarts实例, echarts数据, 是否显示纵坐标(true显示， false不显示), 颜色配置(true绿色渐变, false蓝色渐变) drawEcharts: function (echartsDom, echartsData, yAxisViewflag, colorViewFlag) { var self = this; var category = echartsData.category; // 横轴 var barData = echartsData.barData; // 柱状图数据 var yAxisLabel = yAxisViewflag ? { formatter: '{value} ', color: echartsColor.yAxis.axisLabel.color } : { show: false }; var linearGradientColor = colorViewFlag ? [{ offset: 0, color: '#44D3D2' }, { offset: 1, color: '#0A315F' }] : [{ offset: 0, color: '#00B7F6' }, { offset: 1, color: '#022D63' }] var options = { backgroundColor: echartsColor.backgroundColor, legend: { show: false, }, tooltip: { trigger: 'axis', backgroundColor: echartsColor.tooltip.backgroundColor, borderWidth: 1, borderColor: echartsColor.tooltip.borderColor, textStyle: { color: echartsColor.tooltip.textStyle.color, fontSize: 12, lineHeight: 14 }, padding: [5, 10], axisPointer: { type: 'shadow', label: { show: true, backgroundColor: echartsColor.tooltip.axisPointer.label.backgroundColor } }, formatter: function (params) { var str = &quot;&quot;; params.forEach(function (item, index) { if (item.seriesType == 'bar') { str += '&lt;p class=&quot;tootTipText&quot;&gt;&lt;label class=&quot;tootTipCircle&quot; style=&quot;background-color: ' + item.color.colorStops[0].color + '&quot;&gt;&lt;/label&gt;' + ' ' + item.seriesName + ':' + item.value + '&lt;/p&gt;'; } }) return str; } }, grid: { left: '15%', right: '5%' }, xAxis: { show: false, type: 'value' }, yAxis: { type: 'category', inverse: true, axisLabel: yAxisLabel, splitLine: { show: false }, axisTick: { show: false }, axisLine: { show: false }, data: category }, series: [ { name: '', type: 'bar', barWidth: 10, label: { show: false }, itemStyle: { normal: { barBorderRadius: 5, color: new echarts.graphic.LinearGradient( 1, 1, 0, 0, linearGradientColor ) } }, data: barData }, { // 分隔 type: &quot;pictorialBar&quot;, itemStyle: { normal: { color: &quot;#124970&quot; } }, symbolRepeat: &quot;fixed&quot;, symbolMargin: -1, symbolRotate: 45, symbol: &quot;rect&quot;, symbolClip: true, symbolSize: [13, 1], symbolPosition: &quot;start&quot;, data: barData, z: 10, animationEasing: &quot;elasticOut&quot; }, ] }; echartsDom.setOption(options, true) }, addListenerResize: function () { var self = this; window.addEventListener('resize', self.resizeDebounce(self.ecahrtsResizeFunc, 500), false) }, resizeDebounce: function (func, wait) { let timeout = null; return function () { if (timeout) clearInterval(timeout); timeout = setTimeout(function () { func.apply(this, arguments); }, wait) } }, ecahrtsResizeFunc: function () { echarts1.resize(); echarts2.resize(); echarts3.resize(); echarts4.resize(); echarts5.resize(); echarts6.resize(); } } })(); &lt;/script&gt; &lt;/html&gt; ","link":"https://hviker.github.io/post/fang-dou-jian-ting-liu-lan-qi-chuang-kou-bian-hua/"},{"title":"使用vuex监听Layout的滚动，实现子组件指定页面的懒加载","content":"1、描述 整个.main-container分为三部分, 面包屑、内容显示区域、底部。现在 中部分页面需要监听滚动条的高度，当触及底部时需要像后台发起请求。这里采用监听vuex变量的方式，当 的滚动条触及底部时，变量+1，指定页面监听到变量发生变化就发起请求。考虑到下拉时存在多次请求的情况，这里做了防抖处理，只有myTestDataAntiShake为true时可以请求。刚触及底部时myTestDataAntiShake设置为false，只有请求响应后才设置为true。 2、使用 页面 &lt;!-- 右侧内容区域 --&gt; &lt;div :class=&quot;{hasTagsView:needTagsView}&quot; class=&quot;main-container&quot; @click=&quot;closeSiderBar&quot; ref=&quot;mainContainer&quot;&gt; &lt;div :class=&quot;{'fixed-header':fixedHeader}&quot;&gt; &lt;!-- --&gt; &lt;navbar /&gt; &lt;tags-view v-if=&quot;needTagsView&quot; /&gt; &lt;/div&gt; &lt;app-main /&gt; &lt;div class=&quot;mbFooter&quot; v-if=&quot;innerFooterFiewFlag &amp;&amp; device != 'mobile'&quot;&gt;&lt;main-footer /&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; js // 监听滚动条变化 addEventListerByMainContainer() { // 如果不是手机端，直接退出 if(this.$store.getters.device != 'mobile') return; let self = this; const myTestDataTop = 50； // 顶部面包屑 let dom = this.$refs.mainContainer; dom.addEventListener('scroll', () =&gt; { let routerPath = this.$route.path; if(self.fixdRouterPath.indexOf(routerPath) === -1) return; let scrollHeight = dom.scrollHeight, // 滚动页面高度 scrollTop = dom.scrollTop, // 滚动条距离顶部位置 clientHeight = dom.clientHeight; // 显示区域大小 if(scrollTop &gt; myTestDataTop) { switch (routerPath) { case &quot;/testDetectionMobile/myTestData/myTestDataTable&quot;: // 试验检测列表，用于固定头部显示区域 self.$store.dispatch(&quot;mobilescroll/setIsFixMytestData&quot;, true); break; case &quot;/dataUpdate/myUploadDataMobile&quot;: // 试验结果列表，用于固定头部显示区域 self.$store.dispatch(&quot;mobilescroll/setIsFixMyUploadData&quot;, true); break; } } else { switch (routerPath) { case &quot;/testDetectionMobile/myTestData/myTestDataTable&quot;: // 试验检测列表 self.$store.dispatch(&quot;mobilescroll/setIsFixMytestData&quot;, false); break; case &quot;/dataUpdate/myUploadDataMobile&quot;: // 试验结果 self.$store.dispatch(&quot;mobilescroll/setIsFixMyUploadData&quot;, false); break; } } // 当滑倒底部时， if(scrollTop + clientHeight - scrollHeight &gt;= 0) { switch (routerPath) { case &quot;/testDetectionMobile/myTestData/myTestDataTable&quot;: // 试验检测列表 if(!self.myTestDataAntiShake) return; // 这里做下防抖，上次数据请求回来后才能再次触发 self.$store.dispatch(&quot;mobilescroll/setMyTestDataAntiShake&quot;, false); let myTestDataRefresh = self.$store.getters.myTestDataRefresh; // 页面会监听myTestDataRefresh的变化，发生变化时发起请求 self.$store.dispatch(&quot;mobilescroll/setMyTestDataRefresh&quot;, myTestDataRefresh + 1); break; case &quot;/dataUpdate/myUploadDataMobile&quot;: // 试验结果 if(!self.myUploadDataAntiShake) return; self.$store.dispatch(&quot;mobilescroll/setMyUploadDataAntiShake&quot;, false); let myUploadDataRefresh = self.$store.getters.myUploadDataRefresh; self.$store.dispatch(&quot;mobilescroll/setMyUploadDataRefresh&quot;, myUploadDataRefresh + 1); break; } } }) } ","link":"https://hviker.github.io/post/shi-yong-vuex-jian-ting-layout-de-gun-dong-shi-xian-zi-zu-jian-zhi-ding-ye-mian-de-lan-jia-zai/"},{"title":"解决vue-element-admin三级菜单显示","content":"二级component修改：component: { render(c) { return c('router-view') } }, { path: '/testDetectionMobile', component: Layout, redirect: '/testDetectionDashboard/index', // 用于面包屑跳转 // alwaysShow: true, // will always show the root menu name: 'testDetectionMobile', meta: { title: 'testDetection', icon: 'reportFirst' }, children: [ { path: 'sampleId', component: () =&gt; import('@/views/testDetectionMobile/sampleId/sampleId_index'), name: 'sampleIdMobile', meta: { title: 'sampleId', icon: 'report', affix: true } }, { path: 'myTestData/myTestDataTable', component: () =&gt; import('@/views/testDetectionMobile/myTestData/myTestData_index'), name: 'myTestDataTableMobile', meta: { title: 'myTestData', icon: 'report', affix: true }, }, { path: 'myTestData/dataSource', component: () =&gt; import('@/views/testDetectionMobile/myTestData/dataSource_index'), name: 'dataSourceMobile', meta: { title: 'dataSource', icon: 'report', affix: true }, hidden: true }, { path: 'myTestData/myTestDataModify', component: () =&gt; import('@/views/testDetectionMobile/myTestData/myTestDataModify_index'), name: 'myTestDataModify', meta: { title: 'myTestDataModify', icon: 'report', affix: true }, hidden: true }, { path: 'steelNky', component: () =&gt; import('@/views/testDetection/steelNky/steelNky_index'), name: 'steelNkyMobile', meta: { title: 'steelNky', icon: 'report', affix: true } }, { path: '/dataUpdate', component: { render(c) { return c('router-view') } }, redirect: '/dataUpdate/offlineDataUpload', // 用于面包屑跳转 // alwaysShow: true, // will always show the root menu name: 'dataUpdate', meta: { title: 'dataUpdate', icon: 'report', roles: ['DataUpload', 'SystemAdmin'] }, children: [ { path: 'offlineDataUpload', component: () =&gt; import('@/views/dataUpdate/offlineDataUpload/offlineDataUpload_index'), name: 'offlineDataUpload', meta: { title: 'offlineDataUpload', icon: 'rightarrow', affix: true, roles: ['DataUpload', 'SystemAdmin'] } }, { path: 'myUploadDataMobile', component: () =&gt; import('@/views/dataUpdate/myUploadData/myUploadDataMobile_index'), name: 'myUploadDataMobile', meta: { title: 'myUploadData', icon: 'rightarrow', affix: true, roles: ['DataUpload', 'SystemAdmin'] } } ] }, ] }, ","link":"https://hviker.github.io/post/jie-jue-vue-element-admin-san-ji-cai-dan-xian-shi/"},{"title":"检测移动端软键盘回车进行查询","content":"兼容安卓和ios,type需要改为search,需要form嵌套，这样可以保证ios的回车显示搜索。 &lt;form @submit.prevent=&quot;formSubmit&quot; action=&quot;javascript:return true&quot;&gt; &lt;input class=&quot;mbSearchInput submitInput&quot; placeholder=&quot;请输入任务ID号或任务名称&quot; @keydown=&quot;testDataSearchKeyDown&quot; type=&quot;search&quot; v-model=&quot;TaskName&quot; /&gt; &lt;/form&gt; formSubmit() { return false; }, testDataSearchKeyDown(e){ console.log(e.keyCode) if(e.keyCode == '13') { this.testDataSearchClick(); } }, ","link":"https://hviker.github.io/post/jian-ce-yi-dong-duan-ruan-jian-pan-hui-che-jin-xing-cha-xun/"},{"title":"检测屏幕宽度","content":"const { body } = document； let bodyWidth = body.getBoundingClientRect(); 获取当前屏幕临界点 const { body } = document const WIDTH = 992 // refer to Bootstrap's responsive design function getIsMobile() { const rect = body.getBoundingClientRect() return rect.width - 1 &lt; WIDTH } ","link":"https://hviker.github.io/post/jian-ce-ping-mu-kuan-du/"},{"title":"JS封装组件模板(借助JQuery)","content":"(function (factory) { if(typeof module === 'object' &amp;&amp; typeof module.exports === 'object') { factory(require('jquery'), window, document); } else { factory(jQuery, window, document); } })(function ($, window, document) { var OrganizePart = function(ele, opts) { this.$ele = $(ele); this.opts = opts; this.defaultConfig = {} }; OrganizePart.prototype = { init: function() { var _this = this; _this.$options = $.extend({}, _this.defaultConfig, _this.opts); } }; $.fn.OrganizePart = function(opts) { return new OrganizePart(this, opts).init(); } }) 使用 $(function() { $(&quot;#pageContainer&quot;).OrganizePart({ // &quot;data&quot;: dataSource, }) }) ","link":"https://hviker.github.io/post/js-feng-zhuang-zu-jian-mo-ban-jie-zhu-jquery/"},{"title":"vue视频播放-vue-video-player","content":"1、描述 Vue版本: Vue2.0 Vue-cli版本：Vue-cli4.0 2、使用 下载 npm install vue-video-player -S 引入 ​ 全局引入 main.js引入 import VideoPlayer from 'vue-video-player' import 'vue-video-player/src/custom-theme.css' import 'video.js/dist/video-js.css' ​ 页面引入 在单页面引入 import { VideoPlayer } from 'vue-video-player' import 'vue-video-player/src/custom-theme.css' import 'video.js/dist/video-js.css' 组件使用（播放一般视频格式只需要修改type和src） &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;div class=&quot;demo&quot;&gt; &lt;video-player class=&quot;video-player vjs-custom-skin&quot; ref=&quot;videoPlayer&quot; :playsinline=&quot;true&quot; :options=&quot;playerOptions&quot;&gt; &lt;/video-player&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'Home', components: { }, data() { return { playerOptions: { playbackRates: [0.5, 1.0, 1.5, 2.0], // 可选的播放速度 autoplay: false, // 如果为true,浏览器准备好时开始回放。 muted: false, // 默认情况下将会消除任何音频。 loop: false, // 是否视频一结束就重新开始。 preload: 'auto', // 建议浏览器在&lt;video&gt;加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持） language: 'zh-CN', aspectRatio: '16:9', // 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如&quot;16:9&quot;或&quot;4:3&quot;） fluid: true, // 当true时，Video.js player将拥有流体大小。换句话说，它将按比例缩放以适应其容器。 sources: [{ type: &quot;video/mp4&quot;, // 类型, src: &quot;&quot;, // 视频地址 // src: 'https://cdn.letv-cdn.com/2018/12/05/JOCeEEUuoteFrjCg/playlist.m3u8' // url地址 // src: 'http://192.168.2.59:8088/vod/tky/org/20201228/091707_829/091707_829.mp4.m3u8' // src: '/vod/tky/org/20201228/091707_829/091707_829.mp4.m3u8' }], poster: '', // 封面地址 notSupportedMessage: '此视频暂无法播放，请稍后再试', // 允许覆盖Video.js无法播放媒体源时显示的默认信息。 controlBar: { timeDivider: true, // 当前时间和持续时间的分隔符 durationDisplay: true, // 显示持续时间 remainingTimeDisplay: false, // 是否显示剩余时间功能 fullscreenToggle: true // 是否显示全屏按钮 } } } } } &lt;/script&gt; &lt;style lang=&quot;scss&quot; scope&gt; .demo { width: 500px; height: 400px; } &lt;/style&gt; 3、播放m3u8视频流 安装videojs-contrib-hls npm install videojs-contrib-hls -S 使用 import引入后type改为 application/x-mpegURL &lt;template&gt; &lt;div class=&quot;home&quot;&gt; &lt;div class=&quot;demo&quot;&gt; &lt;video-player class=&quot;video-player vjs-custom-skin&quot; ref=&quot;videoPlayer&quot; :playsinline=&quot;true&quot; :options=&quot;playerOptions&quot;&gt; &lt;/video-player&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import 'videojs-contrib-hls' export default { name: 'Home', components: { HelloWorld }, data() { return { playerOptions: { playbackRates: [0.5, 1.0, 1.5, 2.0], // 可选的播放速度 autoplay: false, // 如果为true,浏览器准备好时开始回放。 muted: false, // 默认情况下将会消除任何音频。 loop: false, // 是否视频一结束就重新开始。 preload: 'auto', // 建议浏览器在&lt;video&gt;加载元素后是否应该开始下载视频数据。auto浏览器选择最佳行为,立即开始加载视频（如果浏览器支持） language: 'zh-CN', aspectRatio: '16:9', // 将播放器置于流畅模式，并在计算播放器的动态大小时使用该值。值应该代表一个比例 - 用冒号分隔的两个数字（例如&quot;16:9&quot;或&quot;4:3&quot;） fluid: true, // 当true时，Video.js player将拥有流体大小。换句话说，它将按比例缩放以适应其容器。 sources: [{ type: &quot;application/x-mpegURL&quot;, // 类型 // src: 'https://cdn.letv-cdn.com/2018/12/05/JOCeEEUuoteFrjCg/playlist.m3u8' // url地址 // src: 'http://192.168.2.59:8088/vod/tky/org/20201228/091707_829/091707_829.mp4.m3u8' src: '/vod/tky/org/20201228/091707_829/091707_829.mp4.m3u8' }], poster: '', // 封面地址 notSupportedMessage: '此视频暂无法播放，请稍后再试', // 允许覆盖Video.js无法播放媒体源时显示的默认信息。 controlBar: { timeDivider: true, // 当前时间和持续时间的分隔符 durationDisplay: true, // 显示持续时间 remainingTimeDisplay: false, // 是否显示剩余时间功能 fullscreenToggle: true // 是否显示全屏按钮 } } } } } &lt;/script&gt; &lt;style lang=&quot;scss&quot; scope&gt; .demo { width: 500px; height: 400px; } &lt;/style&gt; 开发环境出现跨域的情况，需要在vue.config.js做处理 proxy: { '/vod': { target: 'http://192.168.2.59:8088/', ws: false, changeOrigin: true, pathRewrite: { ['^' + '/vod']: '/vod' } } } ","link":"https://hviker.github.io/post/vue-shi-pin-bo-fang-vue-video-player/"},{"title":"echarts部分用法","content":"1、下载图片 (1) 使用组件下载 toolbox: { feature: { saveAsImage: {} } }, (2) 外部按钮下载 echarts的canvas版本，会将图表绘制成canvas。这时候可以调用外部方法下载指定区域的canvas图片。 js // 下载echarts图片 export function downloadEchartsImg(id) { let mycanvas = $(&quot;#&quot; + id).find(&quot;canvas&quot;)[0]; let image = mycanvas.toDataURL(&quot;image/png&quot;); let $a = document.createElement(&quot;a&quot;); $a.setAttribute(&quot;href&quot;, image); $a.setAttribute(&quot;download&quot;, &quot;&quot;); $a.click(); } 2、标题文字垂直显示 下载插件 echarts-better 相关代码 title: { text: echartsObj.nameStr, textStyle: { fontSize: 14, fontWeight: &quot;normal&quot;, fontFamily: &quot;SongTi&quot;, }, textAlign: &quot;left&quot;, top: &quot;60%&quot;, rotate: 90, }, 3、设置外部边框 grid: { show: true, borderColor: &quot;#000&quot;, borderWidth: 2, width: &quot;80%&quot;, left: &quot;7%&quot;, }, 4、内部网格线显示、隐藏 xAxis: { splitLine: { show: true | false, }, } 5、轴文本、轴刻度标在图内测、外侧显示 xAxis: { axisLabel: { inside: false, }, axisTick: { inside: true, } } 6、dataZoom dataZoom: [ { type: &quot;slider&quot;, xAxisIndex: 0, filterMode: &quot;empty&quot;, }, { type: &quot;slider&quot;, yAxisIndex: 0, filterMode: &quot;empty&quot;, }, { type: &quot;inside&quot;, xAxisIndex: 0, filterMode: &quot;empty&quot;, }, { type: &quot;inside&quot;, yAxisIndex: 0, filterMode: &quot;empty&quot;, }, ], 7、联动 可保证axisPointer、dataZoom等联动 var dom1 = echarts.init(document.getElementById(&quot;container3&quot;)); var options1 = this.getChartsOptions(); dom1.setOption(options1, true); var dom2 = echarts.init(document.getElementById(&quot;charts1&quot;)); var options2 = this.getChartsOptions(); dom2.setOption(options2, true); var dom3 = echarts.init(document.getElementById(&quot;charts2&quot;)); var options3 = this.getChartsOptions(); dom3.setOption(options3, true); // 联动 echarts.connect([dom1, dom2, dom3]) ###8、多图在单个canvas绘制时的联动情况 var arr = new Array(waveData.length + 2).fill(1).map(function (item, index) { return index; }); dataZoom: [ { type: 'inside', disabled: true, start: 0, end: 100 }, { show: false, xAxisIndex: arr, type: 'slider', top: 0, start: 0, end: 100 } ], axisPointer: { link: { xAxisIndex: arr }, show: true, type: 'line', axis: 'x', snap: true, label: { show: false } } ","link":"https://hviker.github.io/post/echarts-bu-fen-yong-fa/"},{"title":"培训-布局(H5、CSS)","content":"1、标签初始化 (1) 很多标签自带margin、padding。在使用前设置为0。不建议设置* (2) a 下划线去除 (3) li 去除左侧点 (4) i 去除斜体 (4) 添加清除浮动伪类 clearfix html,body,div,ul,li,h1,h2,h3,h4,h5,table,p,span,img,a,label,i { margin:0; padding:0; } a { text-decoration: none; } li { list-style: none; } i { font-style:normal } clearfix:after{ visibility: hidden; display: block; font-size: 0; content: &quot; &quot;; clear: both; height: 0; } 2、行、块元素 行元素: a，span, i, label, img, input... 块元素: div、table、h1-h6、p、ul、li... 表现形式: (1) 行元素不独占一行，不能设置宽高 (2) 块元素独占一行，能设置宽高 (3) 行内块元素不独占一行，但是可以设置宽高 行、块转换:display 变行: display:inline; 变块: display:block; 变行内块: display:inline-block; 3、居中 行标签: ​ 水平：text-align:center; ​ 垂直：line-height: 父元素高度； 块元素： ​ 水平：margin: 0px auto; ​ 垂直：(1) 定位position。已知块的宽和高，使用绝对定位 ​ (2) display:flex。 父元素添加display:flex; 子元素添加margin:auto。 4、定位 绝对定位：position:absolute。 绝对定位元素的未知相对于最近的已定位的父元素。如果元素没有已经定位的父元素，那么它的相对位置相对于 常用案例：块元素居中 { position:absolute; width:300px; height:300px; left:50%; top:50%; margin-left:-150px; margin-top: -150px; } 相对定位：position:relative。 正常文档流。相对于正常位置。 固定定位：position:fixed。 相对于浏览器窗口。浏览器中存在滚动条且发生滚动时，它不会移动。 常用案例：头部定位导航条、左下角留言板。 5、浮动 意义：脱离正常的文档流,摆脱了块级元素和行内元素的限制。 使用：float -&gt;left;/right; 影响：高度塌陷 当有浮动的子元素存在高度时，如果父元素没有设置浮动，此时子元素不会撑起父元素，父元素的高度消失。如果不清楚浮动，往后的dom元素也会存在高度上的影响。在这种情况下需要清除浮动。 清除：(1) 伪类(推荐) clearfix:after{ visibility: hidden; display: block; font-size: 0; content: &quot; &quot;; clear: both; height: 0; } (2) overflow:hidden; (3) 兼容IE6 zoom:1 6、浏览器页面前端自适应方案 (1) 常见概念： px：像素，屏幕上显示数据的最基本的点。width:100px； 屏幕分辨率: 1920*1080 -》宽度上1920个像素点，高度上1080个像素点。 rem：相对于根元素font-size的长度单位。 font-size:0.9rem; em：相对于父元素font-size的长度单位。font-size:0.9em; 几乎不用。 vw:视窗宽度，移动端。1wm = 视窗宽度的1%; vh：视窗高度，移动端。 1vh = 视窗高度的1%； (2) 方案 纯css - 百分比方案+媒体查询方案+rem(常用) 大布局用百分比，小调整用媒体查询,字体控制用rem。 对于较大的定位区域，比如整个页面、左侧菜单区域、右侧内容区域。 calc()在声明css属性时执行一些计算，用于计算不确定值。一般用calc() 去解决像素溢出问题。 html: &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;header&quot;&gt;头部&lt;/div&gt; &lt;div class=&quot;mainbody clearfix&quot;&gt; &lt;div class=&quot;sider&quot;&gt;左侧菜单区域&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;右侧内容区域&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; css: .container { width:100%; height:100% } .header { width:100%; height：60px; } .mainbody { width:100%; height:calc(100% - 60px) } .clearfix:after{ visibility: hidden; display: block; font-size: 0; content: &quot; &quot;; clear: both; height: 0; } .sider { float:left; width:200px; height:100%; } .content { float:right; width:calc(100% - 200px); height:100%; } 局部调整用媒体查询@media @media screen and (min-width:1600px) and (max-width:1920px){ } @media screen and (min-width:1367px) and (max-width:1599px){ } @media screen and (min-width:1091px) and (max-width:1366px){ } @media screen and (min-width:768px) and (max-width:1090px){ } 字体控制用rem 当页面调整时只需根据当前显示区域大小修改html的font-size。 借助js - rem方案(不推荐) js 动态修改html文字大小，在页面缩放时重新调整rem的大小。 对于页面的放大缩小实际是改变了可是区域的大小，也可以用@media去调整。 动态获取浏览器缩放比例的方法 function detectZoom() { var ratio = 0, screen = window.screen, ua = navigator.userAgent.toLowerCase(); if (window.devicePixelRatio !== undefined) { ratio = window.devicePixelRatio; } else if (~ua.indexOf('msie')) { if (screen.deviceXDPI &amp;&amp; screen.logicalXDPI) { ratio = screen.deviceXDPI / screen.logicalXDPI; } } else if (window.outerWidth !== undefined &amp;&amp; window.innerWidth !== undefined) { ratio = window.outerWidth / window.innerWidth; } if (ratio) { ratio = Math.round(ratio * 100); } return ratio; } 备注：设置宽度/高度百分比一定要保证父元素的宽度/高度有确定值(可以是百分比，可以是px等)。否则设置的百分比无效。 7、css优先级 (1) css具有继承性 应用在标签上的css会影响其子标签，但是子标签的直接样式优先级高于父标签样式。 (2) 样式优先级：内联样式 &gt; ID 选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素选择器 属性选择器 input[type = &quot;text&quot;] { width:200px; height:30px; } 伪类选择器 input:first-child{ width:200px; height:30px; } 伪元素选择器 :before :after (3) css可覆盖，同级别、同路径下样式，后者覆盖前者。 主要用于样式覆盖。 (4) css样式嵌套层级越深，优先级越高。 .A .B .C &gt; .A .C 可用于换肤，菜单样式切换。 8、其他常用css (1) 单行文本溢出添加省略号 { overflow: hidden; text-overflow:ellipsis; white-space: nowrap; } (2) 多行文本溢出添加省略号 chrome实现方法：不兼容IE及其他浏览器 { display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; } IE及其他浏览器实现方法： 使用插件clamps .js 插件下载地址：https://github.com/josephschmitt/Clamp.js 使用： // 引入 &lt;script src=&quot;js/Clamp.js-master/clamp.js&quot;&gt;&lt;/script&gt; // 样式 &lt;style&gt; .divarea { width: 300px; height: 84px; } p { width: 100%; } &lt;/style&gt; // html &lt;div class=&quot;divarea&quot;&gt; &lt;p&gt;这两个选择元素的API,ualCrew小组耗时两年翻译，保持与D3 V3最后一版（3.5.17）一致.D3 V4最新版API请参考d3.v4-API翻译&lt;/p&gt; &lt;/div&gt; // js &lt;script&gt; $(document).ready(function () { $clamp($(&quot;.divarea p&quot;)[0], { clamp: '3' }) }) &lt;/script&gt; (3) 三角形绘制 { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red; } ","link":"https://hviker.github.io/post/pei-xun-bu-ju-h5css/"},{"title":"echarts属性设置(完整版)","content":"全图默认背景 ** // backgroundColor: ‘rgba(0,0,0,0)’, ** 默认色板 color: ['#ff7f50','#87cefa','#da70d6','#32cd32','#6495ed', '#ff69b4','#ba55d3','#cd5c5c','#ffa500','#40e0d0', '#1e90ff','#ff6347','#7b68ee','#00fa9a','#ffd700', '#6699FF','#ff6666','#3cb371','#b8860b','#30e0e0'], 图表标题 title: { x: 'left', // 水平安放位置，默认为左对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ {number}（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ {number}（y坐标，单位px） //textAlign: null // 水平对齐方式，默认根据x设置自动调整 backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 标题边框颜色 borderWidth: 0, // 标题边框线宽，单位px，默认为0（无边框） padding: 5, // 标题内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 主副标题纵向间隔，单位px，默认为10， textStyle: { fontSize: 18, fontWeight: 'bolder', color: '#333' // 主标题文字颜色 }, subtextStyle: { color: '#aaa' // 副标题文字颜色 } }, 图例 legend: { orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' x: 'center', // 水平安放位置，默认为全图居中，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ {number}（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ {number}（y坐标，单位px） backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 图例边框颜色 borderWidth: 0, // 图例边框线宽，单位px，默认为0（无边框） padding: 5, // 图例内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 图例图形宽度 itemHeight: 14, // 图例图形高度 textStyle: { color: '#333' // 图例文字颜色 } }, 值域 dataRange: { orient: 'vertical', // 布局方式，默认为垂直布局，可选为： // 'horizontal' ¦ 'vertical' x: 'left', // 水平安放位置，默认为全图左对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ {number}（x坐标，单位px） y: 'bottom', // 垂直安放位置，默认为全图底部，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ {number}（y坐标，单位px） backgroundColor: 'rgba(0,0,0,0)', borderColor: '#ccc', // 值域边框颜色 borderWidth: 0, // 值域边框线宽，单位px，默认为0（无边框） padding: 5, // 值域内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemWidth: 20, // 值域图形宽度，线性渐变水平布局宽度为该值 * 10 itemHeight: 14, // 值域图形高度，线性渐变垂直布局高度为该值 * 10 splitNumber: 5, // 分割段数，默认为5，为0时为线性渐变 color:['#1e90ff','#f0ffff'],//颜色 //text:['高','低'], // 文本，默认为数值文本 textStyle: { color: '#333' // 值域文字颜色 } }, toolbox: { orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' x: 'right', // 水平安放位置，默认为全图右对齐，可选为： // 'center' ¦ 'left' ¦ 'right' // ¦ {number}（x坐标，单位px） y: 'top', // 垂直安放位置，默认为全图顶端，可选为： // 'top' ¦ 'bottom' ¦ 'center' // ¦ {number}（y坐标，单位px） color : ['#1e90ff','#22bb22','#4b0082','#d2691e'], backgroundColor: 'rgba(0,0,0,0)', // 工具箱背景颜色 borderColor: '#ccc', // 工具箱边框颜色 borderWidth: 0, // 工具箱边框线宽，单位px，默认为0（无边框） padding: 5, // 工具箱内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css itemGap: 10, // 各个item之间的间隔，单位px，默认为10， // 横向布局时为水平间隔，纵向布局时为纵向间隔 itemSize: 16, // 工具箱图形宽度 featureImageIcon : {}, // 自定义图片icon featureTitle : { mark : '辅助线开关', markUndo : '删除辅助线', markClear : '清空辅助线', dataZoom : '区域缩放', dataZoomReset : '区域缩放后退', dataView : '数据视图', lineChart : '折线图切换', barChart : '柱形图切换', restore : '还原', saveAsImage : '保存为图片' } }, 提示框 tooltip: { trigger: 'item', // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis' showDelay: 20, // 显示延迟，添加显示延迟可以避免频繁切换，单位ms hideDelay: 100, // 隐藏延迟，单位ms transitionDuration : 0.4, // 动画变换时间，单位s backgroundColor: 'rgba(0,0,0,0.7)', // 提示背景颜色，默认为透明度为0.7的黑色 borderColor: '#333', // 提示边框颜色 borderRadius: 4, // 提示边框圆角，单位px，默认为4 borderWidth: 0, // 提示边框线宽，单位px，默认为0（无边框） padding: 5, // 提示内边距，单位px，默认各方向内边距为5， // 接受数组分别设定上右下左边距，同css axisPointer : { // 坐标轴指示器，坐标轴触发有效 type : 'line', // 默认为直线，可选为：'line' | 'shadow' lineStyle : { // 直线指示器样式设置 color: '#48b', width: 2, type: 'solid' }, shadowStyle : { // 阴影指示器样式设置 width: 'auto', // 阴影大小 color: 'rgba(150,150,150,0.3)' // 阴影颜色 } }, textStyle: { color: '#fff' } }, ** 区域缩放控制器** dataZoom: { orient: 'horizontal', // 布局方式，默认为水平布局，可选为： // 'horizontal' ¦ 'vertical' // x: {number}, // 水平安放位置，默认为根据grid参数适配，可选为： // {number}（x坐标，单位px） // y: {number}, // 垂直安放位置，默认为根据grid参数适配，可选为： // {number}（y坐标，单位px） // width: {number}, // 指定宽度，横向布局时默认为根据grid参数适配 // height: {number}, // 指定高度，纵向布局时默认为根据grid参数适配 backgroundColor: 'rgba(0,0,0,0)', // 背景颜色 dataBackgroundColor: '#eee', // 数据背景颜色 fillerColor: 'rgba(144,197,237,0.2)', // 填充颜色 handleColor: 'rgba(70,130,180,0.8)' // 手柄颜色 }, ** 网格** grid: { x: 80, y: 60, x2: 80, y2: 60, // width: {totalWidth} - x - x2, // height: {totalHeight} - y - y2, backgroundColor: 'rgba(0,0,0,0)', borderWidth: 1, borderColor: '#ccc' }, 类目轴 categoryAxis: { position: 'bottom', // 位置 nameLocation: 'end', // 坐标轴名字位置，支持'start' | 'end' boundaryGap: true, // 类目起始和结束两端空白策略 axisLine: { // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle控制线条样式 color: '#48b', width: 2, type: 'solid' } }, axisTick: { // 坐标轴小标记 show: true, // 属性show控制显示与否，默认不显示 interval: 'auto', // onGap: null, inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: { // 属性lineStyle控制线条样式 color: '#333', width: 1 } }, axisLabel: { // 坐标轴文本标签，详见axis.axisLabel show: true, interval: 'auto', rotate: 0, margin: 8, // formatter: null, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, splitLine: { // 分隔线 show: true, // 默认显示，属性show控制显示与否 // onGap: null, lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式 color: ['#ccc'], width: 1, type: 'solid' } }, splitArea: { // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 // onGap: null, areaStyle: { // 属性areaStyle（详见areaStyle）控制区域样式 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] } } }, ** 数值型坐标轴默认参数** valueAxis: { position: 'left', // 位置 nameLocation: 'end', // 坐标轴名字位置，支持'start' | 'end' nameTextStyle: {}, // 坐标轴文字样式，默认取全局样式 boundaryGap: [0, 0], // 数值起始和结束两端空白策略 splitNumber: 5, // 分割段数，默认为5 axisLine: { // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle控制线条样式 color: '#48b', width: 2, type: 'solid' } }, axisTick: { // 坐标轴小标记 show: false, // 属性show控制显示与否，默认不显示 inside : false, // 控制小标记是否在grid里 length :5, // 属性length控制线长 lineStyle: { // 属性lineStyle控制线条样式 color: '#333', width: 1 } }, axisLabel: { // 坐标轴文本标签，详见axis.axisLabel show: true, rotate: 0, margin: 8, // formatter: null, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, splitLine: { // 分隔线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle（详见lineStyle）控制线条样式 color: ['#ccc'], width: 1, type: 'solid' } }, splitArea: { // 分隔区域 show: false, // 默认不显示，属性show控制显示与否 areaStyle: { // 属性areaStyle（详见areaStyle）控制区域样式 color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] } } }, polar : { center : ['50%', '50%'], // 默认全局居中 radius : '75%', startAngle : 90, splitNumber : 5, name : { show: true, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, axisLine: { // 坐标轴线 show: true, // 默认显示，属性show控制显示与否 lineStyle: { // 属性lineStyle控制线条样式 color: '#ccc', width: 1, type: 'solid' } }, axisLabel: { // 坐标轴文本标签，详见axis.axisLabel show: false, textStyle: { // 其余属性默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, splitArea : { show : true, areaStyle : { color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)'] } }, splitLine : { show : true, lineStyle : { width : 1, color : '#ccc' } } }, ** 柱形图默认参数** bar: { barMinHeight: 0, // 最小高度改为0 // barWidth: null, // 默认自适应 barGap: '30%', // 柱间距离，默认为柱形宽度的30%，可设固定值 barCategoryGap : '20%', // 类目间柱形距离，默认为类目间距的20%，可设固定值 itemStyle: { normal: { // color: '各异', barBorderColor: '#fff', // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } }, emphasis: { // color: '各异', barBorderColor: 'rgba(0,0,0,0)', // 柱条边线 barBorderRadius: 0, // 柱条边线圆角，单位px，默认为0 barBorderWidth: 1, // 柱条边线线宽，单位px，默认为1 label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } } }, 折线图默认参数 line: { itemStyle: { normal: { // color: 各异, label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, lineStyle: { width: 2, type: 'solid', shadowColor : 'rgba(0,0,0,0)', //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 } }, emphasis: { // color: 各异, label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } }, //smooth : false, //symbol: null, // 拐点图形类型 symbolSize: 2, // 拐点图形大小 //symbolRotate : null, // 拐点图形旋转控制 showAllSymbol: false // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略） }, K线图默认参数 k: { // barWidth : null // 默认自适应 // barMaxWidth : null // 默认自适应 itemStyle: { normal: { color: '#fff', // 阳线填充颜色 color0: '#00aa11', // 阴线填充颜色 lineStyle: { width: 1, color: '#ff3200', // 阳线边框颜色 color0: '#00aa11' // 阴线边框颜色 } }, emphasis: { // color: 各异, // color0: 各异 } } }, 散点图默认参数 scatter: { //symbol: null, // 图形类型 symbolSize: 4, // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 图形旋转控制 large: false, // 大规模散点图 largeThreshold: 2000, // 大规模阀值，large为true且数据量&gt;largeThreshold才启用大规模模式 itemStyle: { normal: { // color: 各异, label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } }, emphasis: { // color: '各异' label: { show: false // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为 // 'inside'|'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } } }, 雷达图默认参数 radar : { itemStyle: { normal: { // color: 各异, label: { show: false }, lineStyle: { width: 2, type: 'solid' } }, emphasis: { // color: 各异, label: { show: false } } }, //symbol: null, // 拐点图形类型 symbolSize: 2 // 可计算特性参数，空数据拖拽提示图形大小 //symbolRotate : null, // 图形旋转控制 }, 饼图默认参数 pie: { center : ['50%', '50%'], // 默认全局居中 radius : [0, '75%'], clockWise : false, // 默认逆时针 startAngle: 90, minAngle: 0, // 最小角度改为0 selectedOffset: 10, // 选中是扇区偏移量 itemStyle: { normal: { // color: 各异, borderColor: '#fff', borderWidth: 1, label: { show: true, position: 'outer' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, labelLine: { show: true, length: 20, lineStyle: { // color: 各异, width: 1, type: 'solid' } } }, emphasis: { // color: 各异, borderColor: 'rgba(0,0,0,0)', borderWidth: 1, label: { show: false // position: 'outer' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, labelLine: { show: false, length: 20, lineStyle: { // color: 各异, width: 1, type: 'solid' } } } } }, map: { mapType: 'china', // 各省的mapType暂时都用中文 mapLocation: { x : 'center', y : 'center' // width // 自适应 // height // 自适应 }, showLegendSymbol : true, // 显示图例颜色标识（系列标识的小圆点），存在legend时生效 itemStyle: { normal: { // color: 各异, borderColor: '#fff', borderWidth: 1, areaStyle: { color: '#ccc' //rgba(135,206,250,0.8) }, label: { show: false, textStyle: { color: 'rgba(139,69,19,1)' } } }, emphasis: { // 也是选中样式 // color: 各异, borderColor: 'rgba(0,0,0,0)', borderWidth: 1, areaStyle: { color: 'rgba(255,215,0,0.8)' }, label: { show: false, textStyle: { color: 'rgba(139,69,19,1)' } } } } }, force : { // 数据map到圆的半径的最小值和最大值 minRadius : 10, maxRadius : 20, density : 1.0, attractiveness : 1.0, // 初始化的随机大小位置 initSize : 300, // 向心力因子，越大向心力越大 centripetal : 1, // 冷却因子 coolDown : 0.99, // 分类里如果有样式会覆盖节点默认样式 itemStyle: { normal: { // color: 各异, label: { show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, nodeStyle : { brushType : 'both', color : '#f08c2e', strokeColor : '#5182ab' }, linkStyle : { strokeColor : '#5182ab' } }, emphasis: { // color: 各异, label: { show: false // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, nodeStyle : {}, linkStyle : {} } } }, chord : { radius : ['65%', '75%'], center : ['50%', '50%'], padding : 2, sort : 'none', // can be 'none', 'ascending', 'descending' sortSub : 'none', // can be 'none', 'ascending', 'descending' startAngle : 90, clockWise : false, showScale : false, showScaleText : false, itemStyle : { normal : { label : { show : true // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, lineStyle : { width : 0, color : '#000' }, chordStyle : { lineStyle : { width : 1, color : '#666' } } }, emphasis : { lineStyle : { width : 0, color : '#000' }, chordStyle : { lineStyle : { width : 2, color : '#333' } } } } }, island: { r: 15, calculateStep: 0.1 // 滚轮可计算步长 0.1 = 10% }, markPoint : { symbol: 'pin', // 标注类型 symbolSize: 10, // 标注大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 //symbolRotate : null, // 标注旋转控制 itemStyle: { normal: { // color: 各异， // borderColor: 各异, // 标注边线颜色，优先于color borderWidth: 2, // 标注边线线宽，单位px，默认为1 label: { show: true, position: 'inside' // 可选为'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } }, emphasis: { // color: 各异 label: { show: true // position: 'inside' // 'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE } } } }, markLine : { // 标线起始和结束的symbol介绍类型，如果都一样，可以直接传string symbol: ['circle', 'arrow'], // 标线起始和结束的symbol大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2 symbolSize: [2, 4], // 标线起始和结束的symbol旋转控制 //symbolRotate : null, itemStyle: { normal: { // color: 各异, // 标线主色，线色，symbol主色 // borderColor: 随color, // 标线symbol边框颜色，优先于color borderWidth: 2, // 标线symbol边框线宽，单位px，默认为2 label: { show: false, // 可选为 'start'|'end'|'left'|'right'|'top'|'bottom' position: 'inside', textStyle: { // 默认使用全局文本样式，详见TEXTSTYLE color: '#333' } }, lineStyle: { // color: 随borderColor, // 主色，线色，优先级高于borderColor和color // width: 随borderWidth, // 优先于borderWidth type: 'solid', shadowColor : 'rgba(0,0,0,0)', //默认透明 shadowBlur: 5, shadowOffsetX: 3, shadowOffsetY: 3 } }, emphasis: { // color: 各异 label: { show: false // position: 'inside' // 'left'|'right'|'top'|'bottom' // textStyle: null // 默认使用全局文本样式，详见TEXTSTYLE }, lineStyle : {} } } }, textStyle: { decoration: 'none', fontFamily: 'Arial, Verdana, sans-serif', fontFamily2: '微软雅黑', // IE8- 字体模糊并且不支持不同字体混排，额外指定一份 fontSize: 12, fontStyle: 'normal', fontWeight: 'normal' }, // 默认标志图形类型列表 symbolList : [ 'circle', 'rectangle', 'triangle', 'diamond', 'emptyCircle', 'emptyRectangle', 'emptyTriangle', 'emptyDiamond' ], loadingText : 'Loading...', // 可计算特性配置，孤岛，提示颜色 calculable: false, // 默认关闭可计算特性 calculableColor: 'rgba(255,165,0,0.6)', // 拖拽提示边框颜色 calculableHolderColor: '#ccc', // 可计算占位提示颜色 nameConnector: ' &amp; ', valueConnector: ' : ', animation: true, animationThreshold: 2500, // 动画元素阀值，产生的图形原素超过2500不出动画 addDataAnimation: true, // 动态数据接口是否开启动画效果 animationDuration: 2000, animationEasing: 'ExponentialOut' //BounceOut ","link":"https://hviker.github.io/post/echarts-shu-xing-she-zhi-wan-zheng-ban/"},{"title":"echarts二维数组绘制空点折线","content":"###1、需求描述 需要绘制多条折线，但是多条折线在某个或者某几个X点不存在Y值。 ###2、代码 initChart() { let chart = echarts.init(document.getElementById(&quot;echarts&quot;)) let option = { title: { text: &quot;Step Line&quot; }, tooltip: { trigger: &quot;axis&quot; }, legend: { data: [&quot;Step Start&quot;, &quot;Step Middle&quot;, &quot;Step End&quot;] }, grid: { left: &quot;3%&quot;, right: &quot;4%&quot;, bottom: &quot;3%&quot;, containLabel: true }, toolbox: { feature: { saveAsImage: {} } }, xAxis: { type: &quot;category&quot;, data: [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;] }, yAxis: { type: &quot;value&quot; }, series: [ { name: &quot;Step Start&quot;, type: &quot;line&quot;, step: &quot;start&quot;, // data: [120, 132, 101, 134, 90, 230, 210] data: [[&quot;Mon&quot;, 120], [&quot;Tue&quot;, 132], [&quot;Wed&quot;, 101], [&quot;Thu&quot;, 134], [&quot;Fri&quot;, 90], [&quot;Sat&quot;, 230], [&quot;Sun&quot;, 210]] }, { name: &quot;Step Middle&quot;, type: &quot;line&quot;, step: &quot;middle&quot;, data: [ [&quot;Wed&quot;, 134], [&quot;Fri&quot;, 90], [&quot;Sat&quot;, 230], [&quot;Sun&quot;, 210]] }, { name: &quot;Step End&quot;, type: &quot;line&quot;, step: &quot;end&quot;, data: [[&quot;Mon&quot;, 120], [&quot;Tue&quot;, 132], [&quot;Wed&quot;, 101], [&quot;Thu&quot;, 134], [&quot;Fri&quot;, 90], [&quot;Sun&quot;, 20]] } ] }; chart.setOption(option) } ","link":"https://hviker.github.io/post/echarts-er-wei-shu-zu-hui-zhi-kong-dian-zhe-xian/"},{"title":"echarts第二次绘制显示空白的解决方案","content":"1、描述 这是一个动态绘制echarts的弹窗子页面。 父页面有很多功能属性，在点击每个功能属性时进行弹窗，然后根据配置动态绘制各功能属性的echarts类型及数据展示。 第一次打开弹窗echarts正常显示，但是关闭后重新打开就显示空白。 echarts绘制的页面dom代码如下 &lt;div class=&quot;contentBody fl&quot;&gt; &lt;div class=&quot;echartsBody&quot; id=&quot;echartsBody&quot;&gt;&lt;/div&gt; &lt;/div&gt; 2、解决方案 首先，可以确定的是每次打开该弹窗代码能走通，从echarts数据传递到获取echarts绘制指定dom再到echarts.setOption(option, true);都没问题。 尝试过网上很多方法，有把setOption第二个参数设置成true的，有把div中_echarts_instance_属性删除的，但是都没有用。这边的做法是动态删除dom然后创建dom,dom渲染完成后再进行其他操作。 $(&quot;.contentBody&quot;) .find(&quot;.echartsBody&quot;) .remove() .end() .append( &quot;&lt;div class='echartsBody' id='echartsBody' style='height:440px'&gt;&lt;/div&gt;&quot; ); this.$nextTick(() =&gt; { ... }） ","link":"https://hviker.github.io/post/echarts-di-er-ci-hui-zhi-xian-shi-kong-bai-de-jie-jue-fang-an/"},{"title":"v-model动态绑定实例","content":"1、需求 页面样式 前后端传递的数据格式 2、描述 页面需要在该区域显示当前所有的化学成分，同时前后端传递的数据格式要求是object。 很无脑费力的一种方法是有N种化学元素，页面绘制N个元素、N*2个input框，然年后data中对应变量的Composition属性中定义N个max、N个min。有这种做法的人可以考虑把脑子扔掉了。且不说绘制及绑定有多麻烦，后期拓展也是问题。 第二种，循环遍历化学元素表，动态生成页面。在v-mode绑定属性值时进行动态拼接。例如下面的addMarkInfoForm.Composition[item.type + 'min']。这就提供给我们一个新思路，v-model的值是可以动态绑定的。 &lt;ul class=&quot;compositionList clearfix&quot;&gt; &lt;li v-for=&quot;item in tempChemicalElementList&quot; :key=&quot;item.key&quot; class=&quot;addmaterialInput&quot;&gt; &lt;span&gt;{{ item.value }}:&lt;/span&gt; &lt;el-input type=&quot;number&quot; v-model=&quot;addMarkInfoForm.Composition[item.type + 'min']&quot; placeholder=&quot;min&quot; /&gt;~ &lt;el-input type=&quot;number&quot; v-model=&quot;addMarkInfoForm.Composition[item.type + 'max']&quot; placeholder=&quot;max&quot; /&gt; &lt;/li&gt; &lt;/ul&gt; 同样，在可编辑动态表格(动态表头，可编辑)中，也可以使用v-model绑定动态列的prop &lt;el-table :data=&quot;tableData&quot; fit style=&quot;width: 100%;&quot;&gt; &lt;el-table-column label=&quot;序号&quot; align=&quot;center&quot; width=&quot;60&quot;&gt; &lt;template slot-scope=&quot;{ $index }&quot;&gt; {{ $index + 1 }} &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column v-for=&quot;item in tableLabel&quot; :key=&quot;item.prop&quot; :label=&quot;item.label&quot; align=&quot;center&quot; &gt; &lt;template slot-scope=&quot;{ row }&quot;&gt; &lt;el-input v-model=&quot;row[item.prop]&quot; placeholder=&quot;请输入&quot; clearable&gt;&lt;/el-input&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;检测结果&quot; width=&quot;90&quot; align=&quot;center&quot;&gt; &lt;template slot-scope=&quot;{ row, $index}&quot;&gt; &lt;el-button size=&quot;mini&quot; type=&quot;danger&quot; @click=&quot;handleDelete(row,$index)&quot; icon=&quot;el-icon-delete&quot; title=&quot;删除&quot; &gt; &lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; ","link":"https://hviker.github.io/post/v-model-dong-tai-bang-ding-shi-li/"},{"title":"vue文件上传","content":"1、业务需求 可以控制文件上传数量、格式，支持图片、pdf的预览、下载、删除，支持其他文件格式的下载删除。 2、效果截图 3、组件代码 &lt;!-- --&gt; &lt;template&gt; &lt;div class=&quot;mainContainer&quot;&gt; &lt;el-form @submit.native.prevent&gt; &lt;el-upload class=&quot;upload-demo&quot; :action=&quot;apiPath&quot; :accept=&quot;acceptType&quot; :limit=&quot;fileLimit&quot; :file-list=&quot;fileList&quot; :http-request=&quot;handleUploadFile&quot; &gt; &lt;img src=&quot;@/assets/mainPage/uploadFile.png&quot; alt=&quot;uploadFile&quot; v-if=&quot;isChangeFiles&quot; /&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot; v-if=&quot;isChangeFiles&quot;&gt; 支持 {{ acceptType }} 格式，最多{{ fileLimit }}个 &lt;/div&gt; &lt;/el-upload&gt; &lt;ul class=&quot;uploadView clearfix&quot;&gt; &lt;li v-for=&quot;item in fileList&quot; :key=&quot;item.id&quot;&gt; &lt;div class=&quot;fileView&quot; :title=&quot;item.name&quot;&gt; &lt;img :src=&quot;getFileIconByName(item.name)&quot; /&gt; {{ item.name }} &lt;/div&gt; &lt;div class=&quot;uploadBtn&quot;&gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;handleRemove(item.id)&quot; v-if=&quot;isChangeFiles&quot; &gt;删除&lt;/a &gt; &lt;a href=&quot;javascript:void(0)&quot; v-if=&quot;isHasViewFunc(item.name)&quot; @click=&quot;handleView(item.url)&quot; &gt;查看&lt;/a &gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;handleDownload(item.name, item.url)&quot; &gt;下载&lt;/a &gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- &lt;el-upload class=&quot;upload-demo&quot; :action=&quot;apiPath&quot; :on-preview=&quot;handlePreview&quot; :before-remove=&quot;beforeRemove&quot; :headers=&quot;headers&quot; :on-remove=&quot;handleRemove&quot; :accept=&quot;acceptType&quot; :before-upload=&quot;beforeUpload&quot; :limit=&quot;fileLimit&quot; :on-exceed=&quot;handleExceed&quot; :file-list=&quot;fileList&quot; :on-success=&quot;handleFileAdd&quot;&gt; &lt;img src=&quot;@/assets/mainPage/uploadFile.png&quot; alt=&quot;uploadFile&quot; /&gt; &lt;div slot=&quot;tip&quot; class=&quot;el-upload__tip&quot;&gt;支持 {{ acceptType }} 格式，最多{{ fileLimit }}个&lt;/div&gt; &lt;/el-upload&gt; --&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import axios from &quot;axios&quot;; import { downloadIamge, downFile } from &quot;@/utils&quot;; export default { components: {}, props: { isChangeFiles: { type: Boolean, default: true, }, fileLimit: { type: Number, }, bizType: { type: Number, }, offlineflag: { type: String, }, fileList: { type: Array, default: [], }, fileBelongId: { type: Number, }, acceptType: { type: String, default: &quot;.xlsx,.xls,.png,.jpeg,.jpg,.gif,.ppt,pptx,.doc,.docx,.zip,.rar,.txt,.bmp,.tif,.pdf,.avi,.mp4,.mov&quot;, // 默认文件类型 }, }, data() { return { // apiPath: &quot;/api/Attachment/UploadFile?bizType=&quot; + this.bizType, apiPath: &quot;&quot;, // headers: { &quot;AuthorizationToken&quot;: localStorage.getItem(&quot;token&quot;) }, httpRequestUrl: &quot;/api/Attachment/UploadFile?bizType=&quot; + this.bizType, }; }, computed: {}, watch: {}, methods: { // 上传文件 handleUploadFile(params) { let files = params.file; // 文件上传前处理 this.beforeUploadFunc(files); this.uploadFlieFunc(files); }, // 文件上传方法 uploadFlieFunc(files) { let self = this, formData = new FormData(); formData.append(&quot;file&quot;, files); try { axios .post(self.httpRequestUrl, formData, { headers: { AuthorizationToken: localStorage.getItem(&quot;token&quot;), &quot;Content-Type&quot;: &quot;multipart/form-data&quot;, }, }) .then((res) =&gt; { if (res.data &amp;&amp; res.data.returnData) { let response = res.data.returnData; let obj = { name: files.name, url: response.AttachmentPath, id: response.AttachmentID, }; if (!self.fileBelongId) { // 当文件存储位置不是数组对象时 self.$emit(&quot;AddAttachment&quot;, response.AttachmentID, obj); } else { // 当文件存储位置为数组对象时 self.$emit( &quot;AddAttachment&quot;, response.AttachmentID, obj, self.fileBelongId ); } } else { self.$message.error(&quot;文件保存失败&quot;); } }); } catch (e) { self.$message.error(&quot;文件保存失败&quot;); } }, // 文件上传成功时 // handleFileAdd(response, file, fileList) { // let self = this; // let obj = { name: file.name, url: response.returnData.AttachmentPath, id: response.returnData.AttachmentID } // if(!this.fileBelongId) { // // 当文件存储位置不是数组对象时 // self.$emit('AddAttachment', response.returnData.AttachmentID, obj); // } else { // // 当文件存储位置为数组对象时 // self.$emit(&quot;AddAttachment&quot;, response.returnData.AttachmentID, obj, this.fileBelongId); // } // }, // 文件删除 handleRemove(id) { this.$confirm(&quot;文件删除后无法恢复，确定要删除文件?&quot;, &quot;提示&quot;, { confirmButtonText: &quot;确定&quot;, cancelButtonText: &quot;取消&quot;, type: &quot;warning&quot;, }).then(() =&gt; { let file = { id: id }; if (!this.fileBelongId) { this.$emit(&quot;removeFile&quot;, file); } else { this.$emit(&quot;removeFile&quot;, file, this.fileBelongId); } }); }, // 文件上传前处理 beforeUploadFunc(files) { // 判断是否超过最大上传数量 if (this.fileList.length + 1 &gt; this.fileLimit) { this.$message.warning(&quot;已超过最大上传数量限制&quot;); return; } let fileName = files.name; // 获取文件类型 let typeArr = fileName.split(&quot;.&quot;); let type = typeArr[typeArr.length - 1]; if (this.acceptType != &quot;任意数据&quot;) { let standFileTypeArr = this.acceptType.split(&quot;,&quot;); // 判断是否符合上传文件类型 let arr = standFileTypeArr.filter((item) =&gt; item.substr(1) == type); if (arr.length == 0) { this.$message.error(`仅支持上传${this.acceptType}格式!`); return false; } } // let size = files.size; // if(size / 1024 / 1024 &gt; 10) { // this.$message.error('单个文件大小上限10M'); // return false; // } // 如果是图片，这里要对图片进行压缩 // if(type == &quot;png&quot; || type == &quot;jpeg&quot; || type == &quot;jpg&quot; ) { // this.compressPic(files) // } if (this.offlineflag == &quot;1&quot;) { this.$confirm(&quot;离线上传过程中不能关闭当前页面&quot;, &quot;提示&quot;, { confirmButtonText: &quot;确定&quot;, cancelButtonText: &quot;取消&quot;, type: &quot;warning&quot;, }).then(() =&gt; { let newpage = this.$router.resolve({ name: &quot;offlineDataUpload&quot;, }); window.open(newpage.href, &quot;_blank&quot;); }); } }, // 压缩图片 compressPic(file) {}, // 根据文件名称显示图标 getFileIconByName(fileName) { let iconType = fileName.split(&quot;.&quot;)[1]; let iconPic; switch (iconType) { case &quot;xlsx&quot;: case &quot;xls&quot;: iconPic = require(&quot;@/assets/mainPage/ico-xlsx.png&quot;); break; case &quot;png&quot;: case &quot;jpeg&quot;: case &quot;jpg&quot;: case &quot;gif&quot;: case &quot;tif&quot;: iconPic = require(&quot;@/assets/mainPage/ico-png.png&quot;); break; case &quot;ppt&quot;: case &quot;pptx&quot;: iconPic = require(&quot;@/assets/mainPage/ico-ppt.png&quot;); break; case &quot;doc&quot;: case &quot;docx&quot;: iconPic = require(&quot;@/assets/mainPage/ico-docx.png&quot;); break; case &quot;rar&quot;: case &quot;zip&quot;: iconPic = require(&quot;@/assets/mainPage/ico-zip.png&quot;); break; case &quot;txt&quot;: case &quot;bmp&quot;: iconPic = require(&quot;@/assets/mainPage/ico-txt.png&quot;); break; } return iconPic; }, // 是否显示查看按钮，仅当文件是图片或者ppt时可以查看 isHasViewFunc(fileName) { let flag = false; let iconType = fileName.split(&quot;.&quot;)[1]; if ( iconType == &quot;png&quot; || iconType == &quot;jpeg&quot; || iconType == &quot;jpg&quot; || iconType == &quot;gif&quot; || iconType == &quot;ppt&quot; || iconType == &quot;pptx&quot; ) { flag = true; } return flag; }, // 查看图片 handleView(url) { let baseUrl = process.env.VUE_APP_DOWNLOAD_IP + url; window.open(baseUrl, &quot;_blank&quot;); }, // 文件下载 handleDownload(name, url) { let iconType = name.split(&quot;.&quot;)[1]; let baseUrl = process.env.VUE_APP_DOWNLOAD_IP + url; if (iconType == &quot;png&quot; || iconType == &quot;jpeg&quot; || iconType == &quot;jpg&quot;) { downloadIamge(baseUrl, name); } else { downFile(baseUrl, name); } }, }, created() {}, mounted() {}, }; &lt;/script&gt; &lt;style lang='scss'&gt; .el-upload-list { display: none; } .uploadView { width: 100%; height: auto; li { width: 100%; float: left; padding: 0px 50px 0px 0px; div { float: left; } .fileView { width: calc(100% - 150px); height: 30px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .uploadBtn { padding-left: 15px; float: right; a { color: #5b6cea; text-decoration: underline; padding-left: 10px; } } } } .upload-demo { margin-bottom: 20px; } &lt;/style&gt; // 图片下载，只能在非跨域情况下使用 export function downloadIamge(imgsrc, name) {//下载图片地址和图片名 let image = new Image(); // 解决跨域 Canvas 污染问题 image.setAttribute(&quot;crossOrigin&quot;, &quot;anonymous&quot;); image.onload = function () { let canvas = document.createElement(&quot;canvas&quot;); canvas.width = image.width; canvas.height = image.height; let context = canvas.getContext(&quot;2d&quot;); context.drawImage(image, 0, 0, image.width, image.height); let url = canvas.toDataURL(&quot;image/png&quot;); //得到图片的base64编码数据 let a = document.createElement(&quot;a&quot;); // 生成一个a元素 let event = new MouseEvent(&quot;click&quot;); // 创建一个单击事件 a.download = name || &quot;photo&quot;; // 设置图片名称 a.href = url; // 将生成的URL设置为a.href属性 a.dispatchEvent(event); // 触发a的单击事件 }; image.src = imgsrc; } // 普通文件下载 export function downFile(imgsrc, name) { var a = document.createElement(&quot;a&quot;); a.download = name; a.href = imgsrc; a.target=&quot;_blank&quot;; document.body.appendChild(a); a.click(); document.body.removeChild(a); } 4、组件使用 &lt;upload-multiple :bizType=&quot;bizType&quot; :fileLimit=&quot;fileLimit&quot; ref=&quot;addProjectUpload&quot; :fileList=&quot;addProjectForm.FileList&quot; :isChangeFiles=&quot;isChangeFiles&quot; @AddAttachment=&quot;AddAttachment&quot; @removeFile=&quot;removeFile&quot; &gt;&lt;/upload-multiple&gt; import { deleteFile } from &quot;@/api/commonDoc&quot; import UploadMultiple from '@/components/UploadFileMultiple' // 多附件上传 export default { components: { UploadMultiple }, data() { return { bizType: 0, //区分文件上传模块 fileLimit： 20， // 文件上传最大上限 addProjectForm: { FileList: [] ,// 展示数组 FileAttachmentList: [], // 参数上传数组 }， isChangeFiles: true , // 是否需要新增、修改文件，控制内部按钮显示。true是 false否 } }, methods: { // 保存文件 AddAttachment(attachmentId, obj) { this.addProjectForm.FileAttachmentList.push({ AttachmentID: attachmentId }); // 这里根据后台要求拼装数据格式 this.addProjectForm.FileList.push(obj); this.addProjectForm = JSON.parse(JSON.stringify(this.addProjectForm)); // 做一次深拷贝，防止对象数据监听不到变化 }, // 文件删除 removeFile(file) { let id = file.id; let obj = { id: id }; deleteFile(obj).then(res =&gt; { if (res.returnData) { let index1 = 0; this.addProjectForm.FileAttachmentList.some(res =&gt; { if (res.AttachmentID == id) { this.addProjectForm.FileAttachmentList.splice(index1, 1) return true; } index1++; }) let index2 = 0 this.addProjectForm.FileList.some(res =&gt; { if (res.id == id) { this.addProjectForm.FileList.splice(index2, 1); return true; } index2++; }) this.$message({ type: &quot;success&quot;, message: &quot;删除成功&quot; }) return; } else { this.$message({ type: &quot;error&quot;, message: &quot;删除失败&quot; }) return; } }) } } } // 文件删除方法 export function deleteFile(id) { return request({ url: &quot;/Attachment/DeleteFile&quot;, method: 'get', params: id }) } 5、备注 图标: ","link":"https://hviker.github.io/post/element-ui-zu-jian-zheng-li/"},{"title":"vue仿tab实现","content":"1、应用场景 单页面存在多个tab，其中多个tab中都存在大量的数据请求。普通的tab在首页面展示时会对所有tab的数据进行请求，浪费资源，引起页面卡顿。使用该tab可以有效解决单页面数据请求与数据渲染问题，利用 在tab切换时只需要根据id动态修改currentTabComponent的值,也可以往组件中传值。 2、效果截图 3、代码实现 &lt;!-- 首页 --&gt; &lt;template&gt; &lt;div class=&quot;mainContainer&quot;&gt; &lt;div class=&quot;tabArea&quot;&gt; &lt;div class=&quot;overFlowTabArea&quot;&gt; &lt;el-button v-for=&quot;item in tabType&quot; :key=&quot;item.id&quot; @click=&quot;handleTab(item.id)&quot; :class=&quot;{ isActive: item.id == activeTab }&quot; &gt;{{ item.name }}&lt;/el-button &gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mainTabInfo&quot;&gt; &lt;component :is=&quot;currentTabComponent&quot; :tabArr=&quot;tabArr&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import AllDynamicRoute from &quot;@/views/steelResearchCompute/cloudCompute/dynamicRoute/AllDynamicRoute_index&quot;; // 全部菜单 import FirstPrinciples from &quot;@/views/steelResearchCompute/cloudCompute/dynamicRoute/FirstPrinciples_index&quot;; // xxx import CALPHAD from &quot;@/views/steelResearchCompute/cloudCompute/dynamicRoute/CALPHAD_index&quot;; //xxx import Spread from &quot;@/views/steelResearchCompute/cloudCompute/dynamicRoute/Spread_index&quot;; // xxx import Multiphase from &quot;@/views/steelResearchCompute/cloudCompute/dynamicRoute/Multiphase_index&quot;; // xxx export default { components: { AllDynamicRoute, FirstPrinciples, CALPHAD, Spread, Precipitation, Multiphase, Limited, Fluid, Coupling, Other, }, data() { return { computeMenuData: [], // 云计算菜单数据 tabType: [ // 仿Tab 按钮资源 ], activeTab: &quot;FirstPrinciples&quot;, // 激活状态下的tab currentTabComponent: FirstPrinciples, // 激活状态下tab对应的数据信息 tabArr: [ // 当前tab显示数据 ], allDynamicRouteArr: [ // 所有的三级菜单 ], }; }, computed: {}, watch: {}, methods: { // 点击按钮切换菜单 handleTab(id) { this.activeTab = id; switch (id) { case &quot;AllDynamicRoute&quot;: this.currentTabComponent = AllDynamicRoute; break; case &quot;FirstPrinciples&quot;: this.currentTabComponent = FirstPrinciples; break; case &quot;CALPHAD&quot;: this.currentTabComponent = CALPHAD; break; case &quot;Multiphase&quot;: this.currentTabComponent = Multiphase; break; case &quot;Spread&quot;: this.currentTabComponent = Spread; break; case &quot;MyComputeTask&quot;: this.$router.push(&quot;/steelResearchCompute/myComputeTask&quot;); return; break; } this.getTabArr(id); }, // 获取当前tab的二级菜单 getTabArr(id) { if (id == &quot;AllDynamicRoute&quot;) { this.tabArr = JSON.parse(JSON.stringify(this.allDynamicRouteArr)); } else { let arr = []; this.computeMenuData.some((item) =&gt; { if (item.category == id) { let categoryList = item.categoryList; // tab对应的二级菜单 categoryList.forEach((item1) =&gt; { // InstructionMode : 1 指令模式，2 图形模式 let routerPath = item1.InstructionMode == &quot;2&quot; ? &quot;/steelResearchCompute/cloudCompute&quot; : &quot;/steelResearchCompute/instructionModeCompute&quot;; arr.push({ id: item1.ID, name: item1.ChineseName, secondName: item1.ChineseName, picLocal: process.env.VUE_APP_DOWNLOAD_IP + item1.SoftAlgorithmCoverIcon, routerPath: routerPath, }); }); return true; } }); this.tabArr = arr; } }, // 初始化 init() { // 钢研云计算所有动态的二级菜单 let computeMenuData = this.$store.getters.computeMenuData; this.computeMenuData = computeMenuData; this.tabType = [{ id: &quot;AllDynamicRoute&quot;, name: &quot;全部&quot; }]; if (computeMenuData.length &gt; 0) { computeMenuData.forEach((item) =&gt; { this.tabType.push({ id: item.category, name: item.categoryText }); // 获取所有的三级菜单 item.categoryList.forEach((item1) =&gt; { let routerPath = item1.InstructionMode == &quot;2&quot; ? &quot;/steelResearchCompute/cloudCompute&quot; : &quot;/steelResearchCompute/instructionModeCompute&quot;; this.allDynamicRouteArr.push({ id: item1.ID, name: item1.ChineseName, secondName: item1.ChineseName, picLocal: process.env.VUE_APP_DOWNLOAD_IP + item1.SoftAlgorithmCoverIcon, routerPath: routerPath, }); }); }); // 添加我的计算任务tab this.tabType.push({ id: &quot;MyComputeTask&quot;, name: &quot;我的计算任务&quot; }) this.handleTab(&quot;AllDynamicRoute&quot;); } }, }, created() { this.init(); }, mounted() {}, }; &lt;/script&gt; &lt;style lang='scss'&gt; // 仿Tab 按钮样式 .mainContainer { padding: 0px; .overFlowTabArea { width: auto; height: 100%; } .tabArea .overFlowTabArea &gt; .el-button--medium { padding: 10px; border-radius: 2px; margin-left: 2px; } } &lt;/style&gt; ","link":"https://hviker.github.io/post/vue-fang-tab-shi-xian/"},{"title":"vue二级树(只能选择一级节点下的一项或者多项)","content":"1、业务要求 树结构有两级，由大类和小类组成。 当大类中不存在大类时，只能选择大类；当大类中存在小类时，只能选择大类中的小类。 当切换大类或者非选中大类中的小类时，清空原有选择数据。 2、效果展示 3、组件代码 &lt;!-- 树形结构 --&gt; &lt;template&gt; &lt;el-dialog :visible.sync=&quot;testTypeTreeViewFlag&quot; width=&quot;55%&quot; :append-to-body=&quot;true&quot; class=&quot;mainContainer&quot; &gt; &lt;div class=&quot;projectTitle&quot;&gt;请选择检测项目&lt;/div&gt; &lt;el-input placeholder=&quot;输入关键字进行过滤&quot; v-model=&quot;filterText&quot; clearable&gt;&lt;/el-input&gt; &lt;el-tree :data=&quot;treeData&quot; :props=&quot;treeProp&quot; show-checkbox node-key=&quot;id&quot; ref=&quot;testTypetree&quot; highlight-current class=&quot;testTypeTree&quot; :filter-node-method=&quot;filterNode&quot; :check-on-click-node=true :accordion=true @check=&quot;getCheckData&quot; &gt;&lt;/el-tree&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;confirmTestTypeSelect&quot;&gt;确认选择&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;closeTestTypeTreeView&quot;&gt;关闭&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;TestTypeTree&quot;, components: {}, props: { testTypeTreeViewFlag: { type: Boolean, required: true, }, treeData: { type: Array, default: [], }, }, data() { return { itemIndex: 0, // 数组中的第几项 filterText: &quot;&quot;, // 关键字过滤 checkedNodeArr: [], // 选中的检测项目数组 treeProp: { // 树形结构解析树形 children: &quot;children&quot;, label: &quot;label&quot;, }, accordion: true, // 是否一级一级展开 }; }, computed: {}, watch: { // 实时监听过滤关键字 filterText(val) { this.$refs.testTypetree.filter(val); }, }, methods: { // 关闭检测信息弹窗 closeTestTypeTreeView() { this.$emit(&quot;closeTestTypeTreeView&quot;); }, // 关键字过滤 filterNode(value, data) { if (!value) return true; return data.label.indexOf(value) !== -1; }, // 确认选择 confirmTestTypeSelect() { if (this.checkedNodeArr.length === 0) { this.$message({ type: &quot;warning&quot;, message: &quot;请选择检测项目&quot;, }); return; } // 当只存在二级菜单时，this.checkedNodeArr中缺少所对应的一级菜单 // 由于显示数据需要拼接，当数据中只存在二级菜单需要查找一级菜单一并返回 // 判断是否存在一级菜单，不存在则flag为false，存在则flag为true let flag = false; this.checkedNodeArr.some((item) =&gt; { if (item.parentId == &quot;#&quot;) { flag = true; return true; } }); if (!flag) { // 当不存在时，获取对应的一级菜单数据,组合后一并发给主页面 let arr = []; let firstItemId = this.checkedNodeArr[0].parentId; this.treeData.some((item) =&gt; { if (item.id == firstItemId) { arr.push(item); return true; } }); arr = [...arr, ...this.checkedNodeArr]; this.$emit(&quot;confirmTestTypeSelect&quot;, arr, this.itemIndex, flag); } else { this.$emit( &quot;confirmTestTypeSelect&quot;, this.checkedNodeArr, this.itemIndex, flag ); } }, // getCheckData(data, node) { // console.log(this.$refs.testTypetree.store) // 选中节点自动展开 // 判断点击的是一级节点还是二级节点 let firstItemId = data.parentId == &quot;#&quot; ? data.id : data.parentId; // 判断当前是选中还是取消选中 let checkedNodes = node.checkedNodes; let arr = []; checkedNodes.forEach((item) =&gt; { if (item.id == firstItemId || item.parentId == firstItemId) { arr.push(item); } }); this.checkedNodeArr = arr; if (arr.length &gt; 0) { this.$refs.testTypetree.setCheckedNodes(arr); } }, // 获取treeData 数据 getTreeData(index, selectTreeId) { this.itemIndex = index; if (selectTreeId) { this.$refs.testTypetree.setCheckedKeys(selectTreeId); } }, }, created() {}, mounted() {}, }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; .projectTitle { width: 100%; height: 40px; line-height: 40px; background-color: #7ee697; font-size: 1rem; padding-left: 20px; padding-right: 20px; font-weight: bolder; margin-bottom: 25px; color: #000000; } .testTypeTree { max-height: 500px; overflow: auto; margin-top: 15px; } &lt;/style&gt; 4、组件使用 &lt;!-- 检测信息树形弹窗 --&gt; &lt;test-type-tree :testTypeTreeViewFlag=&quot;testTypeTreeViewFlag&quot; :treeData=&quot;treeData&quot; @closeTestTypeTreeView=&quot;closeTestTypeTreeView&quot; @confirmTestTypeSelect=&quot;confirmTestTypeSelect&quot; ref=&quot;testTypeTree&quot; &gt;&lt;/test-type-tree&gt; import TestTypeTree from &quot;@/components/TestTypTree&quot;; // 检测信息树形弹窗 export default { components: { TestTypeTree }, data() { return { testTypeTreeViewFlag: false, treeData: [], // 树形数据 departmentUserList: [], // 部门人员树结构 } }, methods: { closeTestTypeTreeView() { this.testTypeTreeViewFlag = false; }, confirmTestTypeSelect() { this.testTypeTreeViewFlag = false; let arrFrist = [], // 一级菜单数组 arrSecond = [], // 二级菜单数组 arrSecondId = [], // 二级菜单id selectTreeId = []; // 选中数据，用于数据回显 arr.forEach((item) =&gt; { if (item.parentId == &quot;#&quot;) { if (flag) { selectTreeId.push(item.id); } arrFrist.push(item); } else { arrSecond.push(item); selectTreeId.push(item.id); let obj = { ExamineID: item.id }; arrSecondId.push(obj); } }); let str = arrFrist[0].label; if (arrSecond.length &gt; 0) { str += &quot;(&quot;; arrSecond.forEach((item, index) =&gt; { str += item.label; if (index != arrSecond.length - 1) { str += &quot;,&quot;; } }); str += &quot;)&quot;; } this.sampleMainruleForm.DetectionTaskItemsList[itemIndex].selectFirstMenuName = arrFrist[0].label; this.sampleMainruleForm.DetectionTaskItemsList[itemIndex].selectTreeName = str; this.sampleMainruleForm.DetectionTaskItemsList[itemIndex].selectTreeId = selectTreeId; this.sampleMainruleForm.DetectionTaskItemsList[itemIndex].ExamineTypeID =arrFrist[0].id; this.sampleMainruleForm.DetectionTaskItemsList[itemIndex].Children = arrSecondId; } } } 5、备注 树结构数据： ","link":"https://hviker.github.io/post/vue-er-ji-shu-zhi-neng-xuan-ze-yi-ji-jie-dian-xia-de-yi-xiang-huo-zhe-duo-xiang/"},{"title":"vue二级树结构(二级单选)","content":"1、业务需求 树结构由部门和人员组成，其中部门为树一级节点，人员为树二级节点，要求点选时只能选择一个人。 2、效果展示 3、组件代码 借助于element-ui el-tree &lt;!-- 人员结构树 --&gt; &lt;template&gt; &lt;el-dialog :visible.sync=&quot;personTreeViewFlag&quot; width=&quot;55%&quot; :append-to-body=&quot;true&quot; class=&quot;mainContainer personTree&quot; &gt; &lt;div class=&quot;projectTitle&quot;&gt; {{ titleText }}&lt;/div&gt; &lt;el-input placeholder=&quot;输入关键字进行过滤&quot; v-model=&quot;filterText&quot; clearable=&quot;&quot;&gt;&lt;/el-input&gt; &lt;el-tree :data=&quot;treeData&quot; :props=&quot;treeProp&quot; show-checkbox node-key=&quot;department_userId&quot; ref=&quot;personSelect&quot; highlight-current class=&quot;personSelect&quot; :filter-node-method=&quot;filterNode&quot; :accordion=&quot;isMultiple == '1'&quot; :check-on-click-node=true @check-change=&quot;getCheckData&quot; &gt;&lt;/el-tree&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;confirmPersonSelect&quot;&gt;确认选择&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;cancelPersonSelect&quot;&gt;取消选择&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;closePersonTreeView&quot;&gt;关闭&lt;/el-button&gt; &lt;/span&gt; &lt;/el-dialog&gt; &lt;/template&gt; &lt;script&gt; export default { props: { personTreeViewFlag:{ // 树弹窗显示标识 type: Boolean, required: true }, titleText: { // 标题名称 type: String, default: &quot;人员信息&quot; }, isMultiple: { // 是否为单选 1是0否 type: String, required: true }, treeData: { // 树形结构 type: Array, default: [] }, isRequire: { // 是否必填，1是0否 type: String, // default: false } }, components: {}, data() { return { filterText: &quot;&quot;, // 关键字过滤 treeProp: { // 树形结构解析树形 children: 'children', label: 'label', // id: 'department_userId' }, checkedNodeArr: [], // 选中的人员数组 }; }, computed: {}, watch: { // 实时监听过滤关键字 filterText(val) { this.$refs.personSelect.filter(val); } }, methods: { // 关键字过滤 filterNode(value, data) { if (!value) return true; return data.label.indexOf(value) !== -1; }, // 确认 confirmPersonSelect() { let personSelect = this.$refs.personSelect.getCheckedNodes(); if(this.isRequire == &quot;1&quot; &amp;&amp; personSelect.length === 0) { this.$message({ type: &quot;warning&quot;, message: &quot;请选择人员&quot; }) return; } let arr = []; // 人员数组 personSelect.forEach(item =&gt; { if(item.parentId != &quot;#&quot;) { arr.push(item) } }) this.$emit(&quot;confirmPersonSelect&quot;, arr) }, // 关闭 closePersonTreeView() { this.$emit(&quot;closePersonTreeView&quot;) }, // 选择人员 getCheckData(data, checked) { if(this.isMultiple == &quot;1&quot;) { let personSelect = this.$refs.personSelect.getCheckedNodes(); let idArr = []; if(checked) { // 判断是否是选中部门 if(data.parentId == &quot;#&quot;) { // 判断部门下人员数量 if(data.children.length === 0) { this.$message({ type: &quot;warning&quot;, message: &quot;该部门下不存在人员，请重新选择&quot; }) this.$refs.personSelect.setCheckedNodes([]) }else if(data.children.length &gt; 1) { // this.$message({ // type: &quot;warning&quot;, // message: &quot;该部门下存在多个人员，请选择一个&quot; // }) // return; idArr = [ data.children[0].department_userId ] this.$refs.personSelect.setCheckedNodes(idArr); return; } else { this.$refs.personSelect.setCheckedKeys([]) idArr.push(data.children[0][&quot;department_userId&quot;]); this.$refs.personSelect.setCheckedKeys(idArr) } } else { this.$refs.personSelect.setCheckedKeys([]) idArr.push(data[&quot;department_userId&quot;]); this.$refs.personSelect.setCheckedKeys(idArr) } } } }, // 取消选择 cancelPersonSelect() { this.$refs.personSelect.setCheckedKeys([]) }, // 获取树最新展示 getTreeSelect(selectNode){ let node = selectNode ? selectNode: []; this.$refs.personSelect.setCheckedKeys(node) } }, created() {}, mounted() {}, }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; .projectTitle { width: 100%; height: 40px; line-height: 40px; background-color: #7ee697; font-size: 1rem; padding-left: 20px; padding-right: 20px; font-weight: bolder; margin-bottom: 25px; color: #000000; } .personSelect { max-height: 500px; overflow: auto; margin-top: 15px; } &lt;/style&gt; &lt;style lang=&quot;scss&quot;&gt; .personTree { .el-dialog { margin-top: 3vh !important; } } &lt;/style&gt; 4、组件使用 &lt;!-- 样品关联人树形结构 --&gt; &lt;person-tree :personTreeViewFlag=&quot;sampleRelationTreeViewFlag&quot; ref=&quot;sampleRelationTree&quot; titleText=&quot;请选择样品关联人&quot; isMultiple=&quot;1&quot; :treeData=&quot;departmentUserList&quot; isRequire=&quot;0&quot; @closePersonTreeView=&quot;closeSampleRelationTree&quot; @confirmPersonSelect=&quot;confirmSampleRelationTree&quot; &gt; &lt;/person-tree&gt; import PersonTree from &quot;@/components/PersonTree/personTree_index&quot;; // 部门用户树状结构 export default { components: { PersonTree }, data() { return { sampleRelationTreeViewFlag: false, departmentUserList: [], // 部门人员树结构 } }, methods: { // 确认 confirmSampleRelationTree（） { // 以下代码根据业务要求实现 let arr1 = []; // 人员数组id let str = &quot;&quot;; arr.forEach((item, index) =&gt; { arr1.push(item.department_userId) str += item.label if(index != arr.length - 1) { str += &quot;,&quot; } }) this.sampleMainruleForm.RelatedUserIDs = arr1; this.sampleMainruleForm.RelatedUserID = arr1[0].split(&quot;_&quot;)[1]; this.sampleMainruleForm.RelationUserName = str; this.closeSampleRelationTree(); }， // 关闭样品关联人树形弹窗 closeSampleRelationTree() { this.sampleRelationTreeViewFlag = false; }, } } 5、备注 树结构数据： ","link":"https://hviker.github.io/post/vue-er-ji-shu-jie-gou-er-ji-dan-xuan/"},{"title":"vue多层对象form验证","content":"1、需求 验证数据格式如下，需要验证sampleMainruleForm.DetectionTaskItemsList的selectTreeName数据必填，并且DetectionTaskItemsList为动态添加数组，每个都需要验证 sampleMainruleForm: { ID: &quot;&quot;, // 样品主页面表单数据对象 TaskName: &quot;&quot;, ProjectID: &quot;&quot;, SubmitDate: this.$moment(), RelatedUserIDs: [], RelatedUserID: &quot;&quot;, RelationUserName: &quot;&quot;, Remark: &quot;&quot;, MainType: &quot;&quot;, SampleMaterialID: &quot;&quot;, SampleMaterialName: &quot;&quot;, SteelMaterialID: &quot;&quot;, SteelMaterialName: &quot;&quot;, IsRange: 1, CompositionsList: [ { ElementName: &quot;C&quot;, MinValue: &quot;&quot;, MaxValue: &quot;&quot;, Feature: &quot;&quot; }, { ElementName: &quot;Si&quot;, MinValue: &quot;&quot;, MaxValue: &quot;&quot;, Feature: &quot;&quot; }, { ElementName: &quot;Mn&quot;, MinValue: &quot;&quot;, MaxValue: &quot;&quot;, Feature: &quot;&quot; } ], DetectionTaskItemsList: [], sampleSign: &quot;&quot;, SampleNum: null, DetectionTaskItemsList: [ { id: &quot;1&quot;, selectTreeName: &quot;&quot;, selectTreeId: [], selectFirstMenuName: &quot;&quot;, ExamineTypeID: &quot;&quot;, Children: [], TestStandard: &quot;&quot;, Remark: &quot;&quot;, fileList: [], FileAttachmentList: [], }, ], 2、效果截图 3、实现代码 &lt;!-- 检测信息开始 --&gt; &lt;div class=&quot;detectinfo&quot;&gt; &lt;div class=&quot;sampleTitleArea&quot;&gt; &lt;img src=&quot;@/assets/testDetection/detectinfo.png&quot; /&gt;检测信息 &lt;/div&gt; &lt;div v-for=&quot;(item, index) in sampleMainruleForm.DetectionTaskItemsList&quot; :key=&quot;item.id&quot;&gt; &lt;el-row&gt; &lt;el-col :span=&quot;20&quot;&gt; &lt;el-row&gt; &lt;el-col :span=&quot;24&quot;&gt; &lt;!-- &lt;el-form-item label=&quot;检测项目&quot; :prop=&quot;`DetectionTaskItemsList[${index}].TestType`&quot; :rules=&quot;{ required: true, message: '请选择所属项目', trigger: 'change' }&quot;&gt; &lt;el-select v-model=&quot;item.TestType&quot; placeholder=&quot;检测项目&quot; filterable clearable :popper-append-to-body=&quot;false&quot;&gt; &lt;el-option v-for=&quot;item in detectProjectArr&quot; :key=&quot;item.key&quot; :label=&quot;item.value&quot; :value=&quot;item.key&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt;--&gt; &lt;el-form-item label=&quot;检测项目&quot; :prop=&quot;`DetectionTaskItemsList[${index}].selectTreeName`&quot; :rules=&quot;{ required: true, message: '请选择检测项目'}&quot; &gt; &lt;el-input v-model=&quot;item.selectTreeName&quot; placeholder=&quot;请选择检测项目&quot; :title=&quot;item.selectTreeName&quot; @focus=&quot;testTypeTreeView(item.id)&quot; readonly clearable &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=&quot;24&quot;&gt; &lt;el-form-item label=&quot;检测标准&quot;&gt; &lt;el-input v-model=&quot;item.TestStandard&quot; placeholder=&quot;请输入检测号&quot; clearable&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=&quot;24&quot; class=&quot;testProcess&quot;&gt; &lt;el-form-item label=&quot;试验工艺&quot;&gt; &lt;el-input v-model=&quot;item.Remark&quot; placeholder=&quot;请输入热模拟试验工艺活相分析热处理工艺等&quot; clearable&gt;&lt;/el-input&gt; &lt;upload-file :fileLimit=&quot;1&quot; :fileList=&quot;item.fileList&quot; :id=&quot;item.id&quot; @handleFileRemove=&quot;handleFileRemove&quot; @handleFileAdd=&quot;handleFileAdd&quot; &gt;&lt;/upload-file&gt; &lt;/el-form-item&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;4&quot; class=&quot;addDetect&quot; &gt; &lt;img src=&quot;@/assets/testDetection/deleteDetect1.png&quot; v-if=&quot;sampleMainruleForm.DetectionTaskItemsList.length != 1&quot; @click=&quot;delDetectInfo(item.id)&quot; /&gt; &amp;nbsp;&amp;nbsp; &lt;img src=&quot;@/assets/testDetection/addDetect1.png&quot; v-if=&quot;index == sampleMainruleForm.DetectionTaskItemsList.length - 1&quot; @click=&quot;addDetectInfo&quot; /&gt; &lt;/el-col&gt; &lt;!-- &lt;el-col :span=&quot;4&quot; class=&quot;delDetect&quot; v-if=&quot;index !== 0&quot; &gt; &lt;img src=&quot;@/assets/testDetection/deleteDetect1.png&quot; @click=&quot;delDetectInfo(item.id)&quot; /&gt; &lt;/el-col&gt; --&gt; &lt;/el-row&gt; &lt;div class=&quot;cutLine&quot; v-if=&quot;index !== sampleMainruleForm.DetectionTaskItemsList.length - 1&quot; &gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ","link":"https://hviker.github.io/post/vue-duo-ceng-dui-xiang-form-yan-zheng/"},{"title":"vue 分页","content":"借助于element-ui el-pagination 效果展示 组件代码 &lt;template&gt; &lt;div :class=&quot;{'hidden':hidden}&quot; class=&quot;pagination-container&quot;&gt; &lt;el-pagination :background=&quot;background&quot; :current-page.sync=&quot;currentPage&quot; :page-size.sync=&quot;pageSize&quot; :layout=&quot;layout&quot; :page-sizes=&quot;pageSizes&quot; :total=&quot;total&quot; v-bind=&quot;$attrs&quot; @size-change=&quot;handleSizeChange&quot; @current-change=&quot;handleCurrentChange&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { scrollTo } from '@/utils/scroll-to' export default { name: 'Pagination', props: { total: { // 总条数 required: true, type: Number }, page: { // 当前页 type: Number, default: 1 }, limit: { // 每页条数 type: Number, default: 20 }, pageSizes: { // 每页条数设置 type: Array, default() { return [10, 20, 30] } }, layout: { // 按钮设置 type: String, default: 'total, sizes, prev, pager, next, jumper' }, background: { type: Boolean, default: true }, autoScroll: { type: Boolean, default: true }, hidden: { type: Boolean, default: false } }, computed: { currentPage: { get() { return this.page }, set(val) { this.$emit('update:page', val) } }, pageSize: { get() { return this.limit }, set(val) { this.$emit('update:limit', val) } } }, methods: { handleSizeChange(val) { this.$emit('pagination', { page: this.currentPage, limit: val }); // 分页点击时将滚动条放置到顶部 document.getElementsByClassName('main-container')[0].scrollTop = 0 // if (this.autoScroll) { // scrollTo(0, 800) // } }, handleCurrentChange(val) { this.$emit('pagination', { page: val, limit: this.pageSize }); // 分页点击时将滚动条放置到顶部 document.getElementsByClassName('main-container')[0].scrollTop = 0 // if (this.autoScroll) { // scrollTo(0, 800) // } } } } &lt;/script&gt; &lt;style scoped&gt; .pagination-container { background: #fff; padding: 32px 16px; text-align: right; } .pagination-container.hidden { display: none; } &lt;/style&gt; scroll-to.js Math.easeInOutQuad = function(t, b, c, d) { t /= d / 2 if (t &lt; 1) { return c / 2 * t * t + b } t-- return -c / 2 * (t * (t - 2) - 1) + b } // requestAnimationFrame for Smart Animating http://goo.gl/sx5sts var requestAnimFrame = (function() { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) { window.setTimeout(callback, 1000 / 60) } })() /** * Because it's so fucking difficult to detect the scrolling element, just move them all * @param {number} amount */ function move(amount) { document.documentElement.scrollTop = amount document.body.parentNode.scrollTop = amount document.body.scrollTop = amount } function position() { return document.documentElement.scrollTop || document.body.parentNode.scrollTop || document.body.scrollTop } /** * @param {number} to * @param {number} duration * @param {Function} callback */ export function scrollTo(to, duration, callback) { const start = position() const change = to - start const increment = 20 let currentTime = 0 duration = (typeof (duration) === 'undefined') ? 500 : duration var animateScroll = function() { // increment the time currentTime += increment // find the value with the quadratic in-out easing function var val = Math.easeInOutQuad(currentTime, start, change, duration) // move the document.body move(val) // do the animation unless its over if (currentTime &lt; duration) { requestAnimFrame(animateScroll) } else { if (callback &amp;&amp; typeof (callback) === 'function') { // the animation is done so lets callback callback() } } } animateScroll() } 组件使用 &lt;pagination v-show=&quot;total &gt; 0&quot; :total=&quot;total&quot; :page.sync=&quot;listQuery.page&quot; :limit.sync=&quot;listQuery.limit&quot; @pagination=&quot;getList&quot; /&gt; import Pagination from &quot;@/components/Pagination&quot;; // 分页组件 export default { components: { Pagination }, data() { return { total: 0, // 数据总条数 listQuery: { page: 1, // 当前页 limit: 20, // 每页条数 }, }; }, methods: { getList(obj) { this.listQuery.page = obj.page; this.listQuery.limit = obj.limit; // 调用页面的查询方法 this.testDataSearch(); }, } } ","link":"https://hviker.github.io/post/vue-fen-ye/"},{"title":"vue打印实现","content":"// 打印类属性、方法定义 /* eslint-disable */ const Print = function (dom, options) { if (!(this instanceof Print)) return new Print(dom, options); this.options = this.extend({ 'noPrint': '.no-print' }, options); if ((typeof dom) === &quot;string&quot;) { this.dom = document.querySelector(dom); } else { this.isDOM(dom) this.dom = this.isDOM(dom) ? dom : dom.$el; } this.init(); }; Print.prototype = { init: function () { var content = this.getStyle() + this.getHtml(); this.writeIframe(content); }, extend: function (obj, obj2) { for (var k in obj2) { obj[k] = obj2[k]; } return obj; }, getStyle: function () { var str = &quot;&quot;, styles = document.querySelectorAll('style,link'); for (var i = 0; i &lt; styles.length; i++) { str += styles[i].outerHTML; } str += &quot;&lt;style&gt;&quot; + (this.options.noPrint ? this.options.noPrint : '.no-print') + &quot;{display:none;}&lt;/style&gt;&quot;; return str; }, getHtml: function () { var inputs = document.querySelectorAll('input'); var textareas = document.querySelectorAll('textarea'); var selects = document.querySelectorAll('select'); for (var k = 0; k &lt; inputs.length; k++) { if (inputs[k].type == &quot;checkbox&quot; || inputs[k].type == &quot;radio&quot;) { if (inputs[k].checked == true) { inputs[k].setAttribute('checked', &quot;checked&quot;) } else { inputs[k].removeAttribute('checked') } } else if (inputs[k].type == &quot;text&quot;) { inputs[k].setAttribute('value', inputs[k].value) } else { inputs[k].setAttribute('value', inputs[k].value) } } for (var k2 = 0; k2 &lt; textareas.length; k2++) { if (textareas[k2].type == 'textarea') { textareas[k2].innerHTML = textareas[k2].value } } for (var k3 = 0; k3 &lt; selects.length; k3++) { if (selects[k3].type == 'select-one') { var child = selects[k3].children; for (var i in child) { if (child[i].tagName == 'OPTION') { if (child[i].selected == true) { child[i].setAttribute('selected', &quot;selected&quot;) } else { child[i].removeAttribute('selected') } } } } } // 包裹要打印的元素 // fix: https://github.com/xyl66/vuePlugs_printjs/issues/36 return this.wrapperRefDom(this.dom).outerHTML; }, // 向父级元素循环，包裹当前需要打印的元素 // 防止根级别开头的 css 选择器不生效 wrapperRefDom: function (refDom) { let prevDom = null let currDom = refDom while (currDom &amp;&amp; currDom.tagName.toLowerCase() !== 'body') { if (prevDom) { let element = currDom.cloneNode(false) element.appendChild(prevDom) prevDom = element } else { prevDom = currDom.cloneNode(true) } currDom = currDom.parentElement } return currDom.tagName.toLowerCase() === 'body' ? currDom : prevDom }, writeIframe: function (content) { var w, doc, iframe = document.createElement('iframe'), f = document.body.appendChild(iframe); iframe.id = &quot;myIframe&quot;; //iframe.style = &quot;position:absolute;width:0;height:0;top:-10px;left:-10px;&quot;; iframe.setAttribute('style', 'position:absolute;width:0;height:0;top:-10px;left:-10px;'); w = f.contentWindow || f.contentDocument; doc = f.contentDocument || f.contentWindow.document; doc.open(); doc.write(content); doc.close(); var _this = this iframe.onload = function(){ _this.toPrint(w); setTimeout(function () { document.body.removeChild(iframe) }, 100) } }, toPrint: function (frameWindow) { try { setTimeout(function () { frameWindow.focus(); try { if (!frameWindow.document.execCommand('print', false, null)) { frameWindow.print(); } } catch (e) { frameWindow.print(); } frameWindow.close(); }, 10); } catch (err) { console.log('err', err); } }, isDOM: (typeof HTMLElement === 'object') ? function (obj) { return obj instanceof HTMLElement; } : function (obj) { return obj &amp;&amp; typeof obj === 'object' &amp;&amp; obj.nodeType === 1 &amp;&amp; typeof obj.nodeName === 'string'; } }; const MyPlugin = {} MyPlugin.install = function (Vue, options) { // 4. 添加实例方法 Vue.prototype.$print = Print } export default MyPlugin 2、main.js中进行引入 import Print from &quot;@/utils/print.js&quot; // 打印 Vue.use(Print) 3、使用 &lt;div class=&quot;printContainer clearfix&quot; ref=&quot;samplePdf&quot;&gt; &lt;div class=&quot;prinfLeft fl&quot;&gt; &lt;img :src=&quot;qrcode&quot; alt=&quot;codePic&quot; /&gt; &lt;p&gt;扫码查询样品信息&lt;/p&gt; &lt;/div&gt; &lt;ul class=&quot;printRight fr&quot;&gt; &lt;li&gt;&lt;label&gt;样品&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ID:&lt;/label&gt;&lt;span&gt;{{ TaskNum }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;任务名称:&lt;/label&gt;&lt;span&gt;{{ TaskName }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;检测项目:&lt;/label&gt;&lt;span&gt;{{ DetectionTaskItems }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;委托人:&lt;/label&gt;&lt;span&gt;{{ SamplePerson }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;所属部门:&lt;/label&gt;&lt;span&gt;{{ CreatedDepartmentName }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;样品所有人:&lt;/label&gt;&lt;span&gt;{{ RelationUserName }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;平行样品:&lt;/label&gt;&lt;span&gt;{{ SampleNum }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;样品原号:&lt;/label&gt;&lt;span&gt;{{ repsampleSign }}&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;送样日期:&lt;/label&gt;&lt;span&gt;{{ createTime }}&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;span slot=&quot;footer&quot; class=&quot;dialog-footer no-print&quot;&gt; &lt;el-button type=&quot;info&quot; @click=&quot;closeSamplePdf&quot;&gt;返回&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;samplePrint&quot;&gt;保存PDF&lt;/el-button&gt; &lt;el-button type=&quot;info&quot; @click=&quot;samplePrint&quot;&gt;打印&lt;/el-button&gt; &lt;/span&gt; methods: { // 打印 samplePrint() { this.$print(this.$refs.samplePdf) }, } 4、备注 对于不想打印的内容添加 .no-print 类 ","link":"https://hviker.github.io/post/vue-da-yin-shi-xian/"},{"title":"Axios请求图片流","content":"// 设置请求头为application/x-www-form-urlencoded， 设置返回数据格式为arraybuffer axios.post(process.env.VUE_APP_BASE_IP + '/tky/tky/vuelogin/captcha.html', {headers: {'Content-Type': 'application/x-www-form-urlencoded'}}, {responseType:&quot;arraybuffer&quot;}).then(res =&gt; { // 这里将得到的图片流转换成blob类型 const blob = new Blob([res.data], { type: 'application/png;charset=utf-8', }); const url = window.URL.createObjectURL(blob); this.verifyPic = url; }) ","link":"https://hviker.github.io/post/axios-qing-qiu-tu-pian-liu/"},{"title":"VUE中引入较大SVG成品图方法","content":"1、项目需求 项目中写好车站及图元的绘制方法，按照要求动态生成车站成品图。车站成品图涉及图元较多，如果每次打开页面动态绘制会占用较长时间，影响加载效率和用户体验。 2、解决方案 决定采用动态引入成品SVG图的方法。首先，使用绘制方法，生成车站svg代码，然后将浏览器中的svg代码复制粘贴出来，作为静态svg文件引入。 3、具体实现步骤 (1) vue中引入svg-sprite-loader，在vue.config.js中配置svg读取路径。 chainWebpack(config) { config.module .rule('icons') .test(/\\.svg$/) .include.add([resolve('src/icons'), resolve('src/assets/jgsvg')]) .end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options({ symbolId: 'icon-[name]' }) .end() } (2) 将成品车站图从浏览器控制台中复制出来，在网站中进行格式化，并查看格式化后的svg图形是否可以正常展示。 这里推荐两个网站: 在线代码格式化 svg在线制作编辑预览工具 将车站成品图代码放到src/assets/jgsvg目录下。 具体格式化后代码见下图。 (3) 引入方法，使用import引入svg文件 html: &lt;div class=&quot;editContainer_SVG&quot;&gt;&lt;/div&gt; js： import zhanchang from &quot;@/assets/jgsvg/chang.svg&quot; // 引入站场图 importStation() { // 引入svg let zhanchangSvg = zhanchang.content.replace(new RegExp(&quot;symbol&quot;, &quot;gm&quot;), &quot;svg&quot;); let str = &quot;width='100%' height='100%' &quot;; // 添加svg属性 let svgText = insertStr(zhanchangSvg, 5, str); $(&quot;.editContainer_SVG&quot;).append(svgText); this.$nextTick(() =&gt; { // 添加属性 let self = this; // 这里必须指定已存在的元素 .editContainer_SVG const pageSvg = d3.select(&quot;.editContainer_SVG #icon-TSRSzhanchang&quot;); this.pageSvg = pageSvg; let g =d3.select(&quot;.editContainer_SVG #icon-TSRSzhanchang &gt;g&quot;); this.pageG = g; // 设置滚动及缩放限制 this.svgZoom = d3.zoom() .scaleExtent(this.svgScaleExtent) // 添加放大限制 .on(&quot;zoom&quot;, zoomed); this.pageSvg.call(this.svgZoom) .on(&quot;wheel&quot;, function () { d3.event.preventDefault(); // 放大倍数达到上下限时svg图形不随鼠标滚动上下移动 }) .on(&quot;dblclick.zoom&quot;, null) // 获取全体包，刷新全体包状态 let allPakcData = this.$store.getters.packData; this.renderDom(allPakcData); // zoom 滚动及缩放方法 function zoomed() { let transforms = d3.event.transform; self.svgZoomTransform = transforms; // // // $(&quot;.rectTipView&quot;).empty(); self.rectTipFlag = false; self.pageG.attr(&quot;transform&quot;, transforms); } }) } /** * 在指定位置插入字符串 * @param {*} soure * @param {*} start * @param {*} newStr */ export function insertStr(soure, start, newStr) { return soure.slice(0, start) + newStr + soure.slice(start) } .editContainer_SVG所在的div为svg的容器。 使用import引入svg静态文件后，会改变svg原有的代码， (1) 由symbol 标签包裹，需要替换symbol为svg; (2) width，height属性消失，需要动态拼接width、height属性 (3) id会有所调整，编程icon_文件名，这里的需要对接下来代码中的指定元素进行修改。 (4) d3.select(&quot;.editContainer_SVG #icon-TSRSzhanchang&quot;) 这里一定要加原dom中已存在的元素 .editContainer_SVG，否则接下来设置的svg拖动、缩放无效。 ","link":"https://hviker.github.io/post/vue-zhong-yin-ru-jiao-da-svg-cheng-pin-tu-fang-fa/"},{"title":"js  数组对象根据某几个key更新合并方法","content":"// 闭塞分区与区段对应关系,格式 {key: &quot;车站ID_Section_区段id&quot;} // let sectionRelationObj = getSectionRelationObj(datas.sectionInfo); // store.dispatch(&quot;initConfigStore/sectionRelationObj&quot;, sectionRelationObj); // 线路号与区段对应关系，格式 {key: &quot;车站ID_Section_区段id&quot;} // let lineReationObj = getLineRelationObj(datas.sectionInfo); // store.dispatch(&quot;initConfigStore/lineReationObj&quot;, lineReationObj) function getSectionRelationObj(arr) { let obj = {}; let sectionRelationObj = {}; arr.reduce((item, next) =&gt; { if(obj[next.blockSectionID]) { item.some(arrItem =&gt; { let key = Object.keys(arrItem)[0] if(key == next.blockSectionID) { sectionRelationObj[key].push(next.tccDeviceId + &quot;Section&quot; + next.id); return true; } }) } else { obj[next.blockSectionID] = true; let nextObj = {}; nextObj[next.blockSectionID] = []; nextObj[next.blockSectionID].push(next.tccDeviceId + &quot;Section&quot; + next.id); sectionRelationObj = Object.assign(sectionRelationObj, nextObj) item.push(nextObj) } return item; }, []) return sectionRelationObj; } function getLineRelationObj(arr) { let obj = {}; let lineRelationObj = {}; arr.reduce((item, next) =&gt; { if(obj[next.lineID]) { item.some(arrItem =&gt; { let key = Object.keys(arrItem)[0] if(key == next.lineID) { lineRelationObj[key].push(next.tccDeviceId + &quot;Section&quot; + next.id); return true; } }) } else { obj[next.lineID] = true; let nextObj = {}; nextObj[next.lineID] = []; nextObj[next.lineID].push(next.tccDeviceId + &quot;Section&quot; + next.id); lineRelationObj = Object.assign(lineRelationObj, nextObj) item.push(nextObj) } return item; }, []) return lineRelationObj; } ","link":"https://hviker.github.io/post/js-shu-zu-dui-xiang-gen-ju-mou-ji-ge-key-geng-xin-he-bing-fang-fa/"},{"title":"Vue  防止按钮在短时间内被多次点击的方法","content":"1、创建intervalclick.js import Vue from 'vue' (function(){ let openDelay=false; Vue.directive('intervalclick', function(el,binding){ el.onclick=function(e){ if(openDelay)return; openDelay=!openDelay; if (!binding.value) { alert(&quot;未传入Value数据！&quot;); return; } let func = binding.value['func']; let time=binding.value['time']; if(typeof time !=='number'){ alert(&quot;传入等待时间错误&quot;); return; } let args=[]; for (const key in binding.value) { if (binding.value.hasOwnProperty(key)) { if(key==='func'||key==='time')continue; args.push(binding.value[key]) } } setTimeout(() =&gt; { openDelay=!openDelay; }, time); func(...args); } }) })() 2、main.js中引入 import clickState from '@/utils/intervalclick' 3、使用 v-intervalclick=&quot;{func:nextControl, time:1000}&quot; 其中，第一个参数nextControl为方法，time为时间间隔 ","link":"https://hviker.github.io/post/vue-fang-zhi-an-niu-zai-duan-shi-jian-nei-bei-duo-ci-dian-ji-de-fang-fa/"},{"title":"cnpm install 报错  cnpm 报错 Install fail! SyntaxError: Unexpected end of JSON input","content":"1、清空缓存 cnpm cache clean --force 如果是npm清除缓存，则使用 npm cache clean --force 2、重新安装cnpm，并设置淘宝镜像 npm install -g cnpm --registry=https://registry.npm.taobao.org 3、安装 cnpm install ","link":"https://hviker.github.io/post/cnpm-install-bao-cuo-cnpm-bao-cuo-install-fail-syntaxerror-unexpected-end-of-json-input/"},{"title":"CentOS7 启动防火墙 报错 Failed to start iptables.service: Unit not found.解决方案","content":"service iptables restart/start/stop Redirecting to /bin/systemctl restart iptables.service Failed to restart iptables.service: Unit not found. 原因是因为CentOS7 里面是用 firewalld (相关介绍介绍请点击)来管理防火墙的。 命令语法：firewall-cmd [--zone=zone] 动作 [--permanent] 注：如果不指定--zone选项，则为当前所在的默认区域，--permanent选项为是否将改动写入到区域配置文件中 firewall的状态： --state ##查看防火墙的状态 --reload ##重新加载防火墙，中断用户的连接，将临时配置清掉，加载配置文件中的永久配置 --complete-reload ##重新加载防火墙，不中断用户的连接（防火墙出严重故障时使用） --panic-on ##紧急模式，强制关闭所有网络连接,--panic-off是关闭紧急模式 例: 添加80端口为允许： firewall-cmd --zone=public --add-port=80/tcp --permanent （--permanent 没有此参数重启后失效） 添加范围例外端口 如 5000-10000： firewall-cmd --zone=public --add-port=5000-10000/tcp --permanent 添加完成后立刻生效： 重新载入 firewall-cmd --reload 查看 firewall-cmd --zone=public --query-port=80/tcp 删除 firewall-cmd --zone=public --remove-port=80/tcp --permanent ","link":"https://hviker.github.io/post/centos7-qi-dong-fang-huo-qiang-bao-cuo-failed-to-start-iptablesservice-unit-not-foundjie-jue-fang-an/"},{"title":"区分js 编码和解码","content":"1、encodeURI()是Javascript中真正用来对URL编码的函数。编码整个url地址，但对特殊含义的符号&quot;; / ? : @ &amp; = + $ , #&quot;，也不进行编码。对应的解码函数是：decodeURI()。 2、encodeURIComponent()能编码&quot;; / ? : @ &amp; = + $ , #&quot;这些特殊字符。对应的解码函数是decodeURIComponent()。 3、encodeURIComponent()能编码&quot;; / ? : @ &amp; = + $ , #&quot;这些特殊字符。对应的解码函数是decodeURIComponent()。 ","link":"https://hviker.github.io/post/qu-fen-js-bian-ma-he-jie-ma/"},{"title":"D3相关 -- 区分选择集和xx对象","content":"1、示例 var rect = svg.append(&quot;rect&quot;) .attr(&quot;fill&quot;,&quot;yellow&quot;) .attr(&quot;x&quot;,100) .attr(&quot;y&quot;,100) .attr(&quot;width&quot;,100) .attr(&quot;height&quot;,30) //打印rect console.log(rect) //rect是选择集 //启动过渡效果 var rectTran = rect.transition() //打印rectTran console.log(rectTran) //rectTran是一个过渡对象 2、选择某一类型的选择集 // 在根元素document.documentElement上返回一个新的对象，等价于d3.select d3.selectAll('circle') 3、选择某一类型的过渡对象 d3.selectAll('circle').transition() 4、d3.transition([selection],[name]) //创建一个过渡对象。但是由于每个选择集中都有transition()方法，可用d3.select(&quot;rect&quot;).transition()的方式来创建过渡，因此一般不直接用d3.transition()。 d3.transition().selection().selectAll('circle').transition().duration(5000).attr('fill', 'red') 等价于 d3.selectAll('circle').transition().duration(5000).attr('fill', 'red') 1 ","link":"https://hviker.github.io/post/d3-xiang-guan-qu-fen-xuan-ze-ji-he-xx-dui-xiang/"},{"title":"D3相关-transition （动画）","content":"一、动画相关 1、选中元素添加动画 d3.selectAll('circle').transition().duration(500).style('fill', 'red'); // 动画持续500ms d3.selectAll('circle').transition().delay(500).style('fill', 'red'); // 延迟500ms后执行动画 2、中止动画 该方法取消指定node上未执行的过渡部分(如果存在未执行的过渡部分) d3.select('.circle').interrupt(); 3、筛选 筛选不存在circle1类的circle图元，添加动画 d3.selectAll('circle').filter(filterFunc).transition().style('fill', 'red'); function filterFunc() { return d3.select(this).attr('class') != 'circle1' } 4、循环动画 实现黄灯每隔500ms的闪烁效果 d3.selectAll('circle').transition().on('start', function repeat() { d3.active(this).duration(500).style('fill', 'green') .transition().duration(500),style('fill', 'transparent') .on('start', repeat) }) 二、属性操作 1、attr、style 2、xxxTween xxxTween：自定义插值器，相当于是把延迟的过程放到了方法里。有attrTween, styleTween // 在5s之内把r从原大小变成500px d3.selectAll('.circle').transition().duration(5000).attrTween(&quot;r&quot;, function() { return d3.interpolateNumber(this.getAttribute(&quot;r&quot;), 500) }) 这里需要根据value值使用对应的获取值方法 如果 value 为数值, 使用 interpolateNumber. 如果 value 为 color 或可以被强制转为颜色的字符串, 使用 interpolateRgb. 使用 interpolateString. 3、tween // 在5s之内把fill 从原颜色变成blue d3.selectAll('.circle').transition().duration(5000).tween(&quot;fill&quot;, function() { var node = this, i = d3.interpolateRgb(node.getAttribute(&quot;fill&quot;), &quot;blue&quot;); // i是一个方法，从原颜色到blue渐变。 // t 的大小为[0,1] return function(t) { node.setAttribute(&quot;fill&quot;, i(t)) } }) ","link":"https://hviker.github.io/post/d3-xiang-guan-transition-dong-hua/"},{"title":"D3相关- drag（拖动）","content":"1、添加拖动方法 d3.selectAll('circle').call(d3.drag().on('start',function() { d3.select(this).attr('fill', 'red'); // 修改颜色 }) .on('drag', function() { // 获取并设定移动位置 let {x, y} = d3.event; d3.select(this).attr('cx', x).attr('cy', y); }) .on('end',function() { d3.select(this).attr('fill', 'green') }) 2、解除某些图元的drag绑定 d3.selectAll('circle1').call(d3.drag().on('.drag', null)) 该方法用于将circle中带有circle1类的图元取消drag拖动绑定 3、详解 (1) d3.drag():创建一个拖拽行为并返回自身，需要用selection.call()进行调用 即:d3.selectAll('circle').call(d3.drag()) (2) d3.drag().on():添加事件回调 start - 拖拽开始 drag - 拖拽中 end - 拖拽结束 (3) 在回调过程中返回当前拖拽对象信息，即d3.event target - 相关联的drag behavior. type - 字符串 “start”, “drag” 或 “end”; 参考 drag.on. subject - 通过 drag.subject定义的subject. x - subject 的 x-坐标; 参考 drag.container. y - subject 的 y-坐标; 参考 drag.container. dx - 与上一次拖拽相比 x-坐标 的变化. dy - 与上一次拖拽相比 y-坐标 的变化. identifier - 字符串 “mouse”, 或者表示 touch identifier的数字. active - 当前活动的拖拽手势的数量(在start和end, 不包含这个). sourceEvent - 底层原始事件比如 mousemove 或 touchmove. (4) 关于容器的设定 d3.drag().container(Func)，用于指定容器，暂不清楚如何使用 (5) 关于过滤器的设定 d3.drag().filter(Func),用于指定过滤器，暂不清楚如何使用 ","link":"https://hviker.github.io/post/d3-xiang-guan-dragtuo-dong/"},{"title":"GIT 忽略本地已存在文件修改","content":"1、将文件修改忽略 git update-index --assume-unchanged FILENAME 2、取消文件忽略 git update-index --no-assume-unchanged FILENAME 3、如果文件未上传到库中，并为提交到本地版本库中记录，最好使用： .gitignore 4、.gitignore文件忽略规则： 空格不匹配任意文件，可作为分隔符，可用反斜杠转义 # 开头的文件标识注释，可以使用反斜杠进行转义 ! 开头的模式标识否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用 ! 也不会再次被包含。可以使用反斜杠进行转义 / 结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件 / 开始的模式匹配项目跟目录 如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录 ** 匹配多级目录，可在开始，中间，结束 ? 通用匹配单个字符 [] 通用匹配单个字符列表 常用匹配示例： bin/: 忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件 /bin: 忽略根目录下的bin文件 /*.c: 忽略 cat.c，不忽略 build/cat.c debug/*.obj: 忽略 debug/io.obj，不忽略 debug/common/io.obj 和 tools/debug/io.obj **/foo: 忽略/foo, a/foo, a/b/foo等 a/**/b: 忽略a/b, a/x/b, a/x/y/b等 !/bin/run.sh: 不忽略 bin 目录下的 run.sh 文件 *.log: 忽略所有 .log 文件 config.php: 忽略当前路径的 config.php 文件 ","link":"https://hviker.github.io/post/git-hu-lue-ben-di-yi-cun-zai-wen-jian-xiu-gai/"},{"title":"Linux常用命令","content":"1、cd 定位到文件夹 2、ls 查看当前文件下存在的内容 3、cd .. 返回至上一级目录 4、cd / 返回至最上级目录 5、pwd 查看当前路径 6、cat 查看当前文件内容 7、rm -rf 删除文件夹及下所有文件、文件夹 8、rm -f 删除文件 9、执行sh 文件 sh /root/datelog.sh 10、查看ftp是否安装 rpm -qa|grep vsftpd 11、查看ftp是否启动 service vsftpd status 12、启动ftp服务 service vsftpd start 下载ftp客户端:http://mirror.centos.org/centos-7/7.7.1908/os/x86_64/Packages/ 安装 rpm Uvh xxx 压缩文件 到指定目录 tar zcvf /root/gitbackups/gitlab20200423.tar.gz /root/gitlab/* z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名 /root/gitbackups/gitlab20200423.tar.gz 压缩到指定目录并命名 /root/gitlab/* 压缩内容 把/root/test目录中所有文件打包并使用gzip压缩为test.tar.gz文件 tar -zcvf /root/gitbackups/test.tar.gz /root/test 把/root/gitbackups/test.tar.gz目录中的所有文件解压，解压位置为/root/gitbackups tar -zxvf /root/gitbackups/test.tar.gz -C /root/gitbackups ","link":"https://hviker.github.io/post/linux-chang-yong-ming-ling/"},{"title":"CSS实现单行、多行文本溢出显示省略号","content":"### 1、单行文本溢出显示省略号 实现方法： overflow: hidden; text-overflow:ellipsis; white-space: nowrap; ### 2、多行文本溢出显示省略号 chrome实现方法： 不兼容IE及其他浏览器 display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 3; overflow: hidden; IE及其他浏览器实现方法： 使用插件clamps .js 插件下载地址：https://github.com/josephschmitt/Clamp.js 使用： // 引入 &lt;script src=&quot;js/Clamp.js-master/clamp.js&quot;&gt;&lt;/script&gt; // 样式 &lt;style&gt; .divarea { width: 300px; height: 84px; } p { width: 100%; } &lt;/style&gt; // html &lt;div class=&quot;divarea&quot;&gt; &lt;p&gt;这两个选择元素的API,ualCrew小组耗时两年翻译，保持与D3 V3最后一版（3.5.17）一致.D3 V4最新版API请参考d3.v4-API翻译&lt;/p&gt; &lt;/div&gt; // js &lt;script&gt; $(document).ready(function () { $clamp($(&quot;.divarea p&quot;)[0], { clamp: '2' }) }) &lt;/script&gt; ","link":"https://hviker.github.io/post/css-shi-xian-dan-xing-duo-xing-wen-ben-yi-chu-xian-shi-sheng-lue-hao/"},{"title":"纯CSS绘制各种三角形","content":"纯 CSS 实现绘制各种三角形（各种角度） 一、前言 三角形实现原理：宽度width为0；height为0；（1）有一条横竖边（上下左右）的设置为border-方向：长度 solid red，这个画的就是底部的直线。其他边使用border-方向：长度 solid transparent。（2）有两个横竖边（上下左右）的设置，若斜边是在三角形的右边，这时候设置top或bottom的直线，和右边的斜线。若斜边是在三角形的左边，这时候设置top或bottom的直线，和左边的斜线。 二、实现 2.1 Triangle Up #triangle-up { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-bottom: 100px solid red; } 2.2 Triangle Down #triangle-down { width: 0; height: 0; border-left: 50px solid transparent; border-right: 50px solid transparent; border-top: 100px solid red; } 2.3 Triangle Left #triangle-left { width: 0; height: 0; border-top: 50px solid transparent; border-right: 100px solid red; border-bottom: 50px solid transparent; } 2.4 Triangle Right #triangle-right { width: 0; height: 0; border-top: 50px solid transparent; border-left: 100px solid red; border-bottom: 50px solid transparent; } 2.5 Triangle Top Left #triangle-topleft { width: 0; height: 0; border-top: 100px solid red; border-right: 100px solid transparent; } 2.6 Triangle Top Right #triangle-topright { width: 0; height: 0; border-top: 100px solid red; border-left: 100px solid transparent; } 2.7 Triangle Bottom Left #triangle-bottomleft { width: 0; height: 0; border-bottom: 100px solid red; border-right: 100px solid transparent; } 2.8 Triangle Bottom Right #triangle-bottomright { width: 0; height: 0; border-bottom: 100px solid red; border-left: 100px solid transparent; } ","link":"https://hviker.github.io/post/chun-css-hui-zhi-ge-chong-san-jiao-xing/"},{"title":"IE下多个tab页(嵌套iframe)打开导致内存一直上涨","content":"(1) 使用iframe时 ，确保公用一个iframe (2) ie下添加代码 let mainframe = document.getElementById(&quot;mainFrame&quot;); this.src = &quot;about:blank&quot;; //src地址清空 mainframe.contentWindow.document.write(''); // 清空iframe内容 mainframe.contentWindow.close(); CollectGarbage(); ","link":"https://hviker.github.io/post/ie-xia-duo-ge-tab-ye-qian-tao-iframeda-kai-dao-zhi-nei-cun-yi-zhi-shang-zhang/"},{"title":"vue+ws在刷新页面时使用beforeDestroy无法触发的解决方法","content":"vue的钩子函数beforeDestroy()、destroy() 只是在页面切换的时候触发，并不能监听F5或者网页关闭时的事件。 js种beforeunload事件可以在当前页面刷新或者关闭时调用。 使用： methods:{ // beforeunload对用的方法 beforeunloadFn(e) { if(this.socket) { this.socket.close(); clearInterval(this.heartBeatInterval); this.heartBeatInterval = null; } } }, mounted() { // 初始化socket this.init(); // 给beforeunload添加事件，并监听beforeunload window.addEventListener('beforeunload', e =&gt; this.beforeunloadFn(e)) }, beforeDestroy () { // 当页面切换时关闭监听 window.removeEventListener('beforeunload', e =&gt; this.beforeunloadFn(e)) } ","link":"https://hviker.github.io/post/vuews-zai-shua-xin-ye-mian-shi-shi-yong-beforedestroy-wu-fa-hong-fa-de-jie-jue-fang-fa/"},{"title":"Sass","content":"Sass(css)预处理器的特性 1、变量 使用变量来存储需要再css中复用的信息，使用$去声明一个变量 &lt;style lang='scss' scoped&gt; $bg_color:red; .container{ width: 20px; height: 20px; background-color: $bg_color; } &lt;/style&gt; 2、嵌套 以嵌套的方式使用css，父级元素包子级元素 3、引入 @import '位置/文件名' ： 引入.scss文件，将多个.scss文件合并成一个 可以引入代码片段，也可以引入某个变量 (1) 引入代码片段 ( b中引入a) 可以看出a是可以使用中b的变量。当引入.css时不允许存在变量 ​ a.scss .inter{ width: 10px; height: 10px; background-color:$inter_color1; } ​ b.scss $bg_color:red; $inter_color:green; $inter_color1:blue; .container{ width: 20px; height: 20px; background-color: $bg_color; } .inter1{ width: 10px; height: 10px; background-color:$inter_color; } @import 'a'; (2) 引入变量 此时显示颜色为blue ​ a.scss $inter_color:blue; ​ b.scss $bg_color:red; $inter_color:green; .container{ width: 20px; height: 20px; background-color: $bg_color; } @import 'a'; .inter{ width: 10px; height: 10px; background-color:$inter_color; } 备注：与css3中的引入不同，@import url('a')需要加载；而sass的@import则不需要加载 我们可以将公共变量放在一个.scss中，使样式代码更加清晰 4、混合(Mixin) 用于分组需要在页面中复用的css声明，通过向Mixin传递变量参数让代码更加灵活 声明：@mixin 名字(变量) 调用：@include 名字(数值) 页面： &lt;div class=&quot;divView&quot;&gt;123&lt;/div&gt; 声明 @mixin divStyle($divWidth, $divHeight, $divColor) { width: $divWidth; height: $divHeight; background-color: $divColor } 调用 .divView { @include divStyle(80px, 50px, blue) } 思考：可以用于多浏览器适配，例如 @mixin border-radius($radius) { border-radius: $radius; -ms-border-radius: $radius; -moz-border-radius: $radius; -webkit-border-radius: $radius; } .box { @include border-radius(10px); } 5、继承 使用@extend在选择器之间复用css属性，避免产生冗余代码 公用代码片段使用 % 声明，使用 @extend 继承 // 该代码没有被继承，不会输出到最终的css中 %box-other { border: 1px solid #000; } // 该代码被继承，会输出到最终的css中 %box-common { border: 1px solid green } .box1 { @extend %box-common ; width:50px; height: 50px; } .box2 { @extend %box-common ; width: 100px; height: 200px; } 6、操作符 sass提供了标准的算术运算符，例如 +、-、*、/、%,可以让开发人员更容易将像素转换成百分比 $width:600px; .box1 { width: $width / 1000px * 100%; height: 200px; background-color: $inter_color; } 转换代码 ==》 .box1 { width: 60%; height: 200px; background-color: green; } 7、引用父级 &amp; “&amp;” 会使用父级选择器替换全部出现的位置 伪类选择器使用场景： .container { width: $width; height: $height; background-color: $bg_color; &amp;:hover { background-color: $inter_color } } 当子类元素class的开头是父元素时也可以使用 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;container_divView&quot;&gt;123&lt;/div&gt; &lt;/div&gt; .container { width: $width; height: $height; background-color: $bg_color; &amp;_divView { font-size:20px } } 8、嵌套属性 css许多属性都有相同的命名空间，比如font-family,font-size,font-weight等， scss中只需要编写命名空间一次，后续嵌套的子属性都将位于该命名空间之下 /*===== SCSS =====*/ .demo { // 命令空间后带有冒号: font: { family: fantasy; size: 30em; weight: bold; } } /*===== CSS =====*/ .demo { font-family: fantasy; font-size: 30em; font-weight: bold; } ","link":"https://hviker.github.io/post/sass/"},{"title":"Web Worker","content":"1、介绍 Web Worker,运行在后台的javascript，不占浏览器自身的线程，独立于其他脚本。 通常来讲javascript是单线程的，js处理逻辑与页面渲染走线程，代码会自上而下执行，可以理解为同步。在html中执行js脚本时，在js脚本加载完成之前，页面的状态是不响应的。我们可以将一些复杂逻辑交给web worker在后台执行，相当于是将部分逻辑异步处理，在这段逻辑处理之间页面依然可以响应用户的操作。 web worker有两种类型，一种是专用线程 dedicated web worker，一种是共享线程 shared web worker;专用线程会随着页面的关闭而关闭，只能在创建它的页面访问。而共享线程可以被多个页面访问，一般用于同浏览器下多页面的通信（必须保证同源策略） 2、专用线程在vue的使用 每一个worker对象都是使用构造函数创建的对象。主程序通过worker对象的postMessage(obj)发送数据,可以发送对象；通过worker对象的onmessage(data)接收数据；而子线程worker.js需要设置onmessage(obj) 来接收主程序发送的数据，处理完成之后使用postMessage(data)将处理好的数据发送给主程序。子线程中也有错误信息的监听方法onerror() 以vue-cli 3.x为例子 (1) 需要下载worker-loader,并且在vue.config.js中配置worker.js文件能被读取 chainWebpack(config) { // set worker config.module .rule(&quot;worker.js&quot;) // 读取worker.js结尾的js .test(/\\.worker\\.js$/) // 正则匹配 .use('worker-loader') // 使用worker-loader .loader('worker-loader') .options({ inline: true, name: 'workerName.[hash].js' }) } (2) 创建子线程 webworker.worker.js，设置onmessage、onerror方法 onmessage = function(evt){ //工作线程接收到主线程的消息,处理逻辑 let arr = evt.data let name = ''; arr.forEach(element =&gt; { name = element.name }); //向主线程发送消息 postMessage(name); }; //错误信息 onerror = function (event) { console.log(event.message); } (3) 在主程序中引入子线程，并且创建实例，使用worker对象发送与接收数据 import WorkerSetss from '@/static/webworker.worker.js' this.worker = new WorkerSetss(); //向工作线程发送消息 let arr = []; let obj = {}; obj.name = &quot;小明&quot; obj.id = &quot;1&quot; arr.push(obj) this.worker.postMessage(arr); this.worker.onmessage = function(event) { console.log(event) } 备注： (1) 只能用于单个页面，不能出现跨页面的情况。 (2) 有浏览器的兼容问题。 ","link":"https://hviker.github.io/post/web-worker/"},{"title":"实现同浏览器不同页面下的数据通信","content":"1、项目场景 同浏览器下的两个窗口分别开着项目的两个页面A、B，点击A窗口页面的某个按钮，实现B窗口下页面数据的刷新。 2、实现方案 2.1 使用BroadcastChannel实现 BroadcastChannel ，广播频道，允许统一来源下不同文档(在不同的窗口、选项卡、iframe)之间进行通信。内容发布后，创建该频道的所有文档都能接收到数据。 使用： (1) 创建BroadcastChannel实体，并通过name添加频道唯一标识 (2) 发布消息,使用postMessage(obj)方法 (3) 当结束之后关闭连接，使用close()方法，允许垃圾回收 let channel = new BroadcastChannel('test_channel'); // 创建BroadcastChannel实体，name为test_channel let data = &quot;使用BroadcastChannel实现&quot; channel.postMessage(data) // 发送消息 channel.close(); //关闭连接 (4) 其他页面接收时需要创建相同标识的BroadcastChannel实体，使用onmessage方法 let channel = new BroadcastChannel('test_channel'); channel.onmessage = (event) =&gt;{ console.log(event) this.test = event.data this.handleClick() // 注意，虽然能动态改变另一个浏览器的数据，但是不能触发另一个浏览器的方法 } 备注: (1) 每一种通道可以发布一种或者多种数据，一个页面可以存在多个通道。 (2) 当通道不需要时，需要手动关闭，使用close()，允许垃圾回收 (3) 跨浏览器时有问题。比如chrome中打开一个窗口，IE打开一个窗口，尝试后不能该改变数据 (4) 可以动态修改另一个浏览器的数据并渲染。如果另一个浏览器窗口使用onmessage接收到数据后调用自己的方法，这个方法不会立即触发。只有鼠标点到另一个浏览器后才会触发。 (5) 可以传对象，接收也是对象。接收到对象数组不需要转换。 (6) 需要满足同源策略。 (7) 使用简单，只要初始化实例后，传入相同的频道值，就会被接入到相同得广播频道中。 (8) BroadcastChannel存在浏览器的兼容问题，只支持版本较新的Chrome和Firefox,不支持IE和Safari具体兼容见下图。 BroadcastChannel详细api地址：https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel 2.2 localstorage localstorage 浏览器多个标签公用的存储空间，可以实现多页签之间的通信。(sessionstorage是会话级别的存储空间，用于单页面) 使用： (1) A页面设置locastorage,B页面使用addEventListener去监听localstorage A页面设置： let data = &quot;使用localstorage存储2&quot; window.sessionStorage.setItem(&quot;msg&quot;,data) B页面设置： window.addEventListener(&quot;storage&quot;, (evt) =&gt;{ if(evt.key == 'msg') { console.log(evt.newValue) this.storage_session = evt.newValue } }) 备注： (1) localstorage如果不手动清除是不会消失的，需要手动清除。 (2) 如果B页面打开，B页面会监听到所有“storage”变化的数据，evt中有对应storage的key ，可以进行针对性的判断。当localstorage的某值比较上一次没有变化时，即使set也不会触发。当自身页面通过set设置localstorage的值的时候，并不能监听。 (3) localstorage默认存储的是字符串，对于json数据需要使用stringfiy()、parse()方法；对于[[]]需要通过代码进行数据转换。如果数据量较大会出现页面卡死的情况。 2.3 cookie + setInterval cookie,当一个页面设置cookie后，能被另一个页面访问。代码实现上需要监听cookie的数据变化，然后再设置响应 setInterval(() =&gt;{ // 获取cookie }, 1000) 备注： (1) cookie存储空间有限，存储内容少 (2) 定时需要考虑时间上的设置，时间过大影响时效性，时间过小影响浏览器使用。不推荐使用。 2.4 SharedWorker web worker中的共享线程。相比于专线线程，可以用于同浏览器下多页面的通信。使用上对VUE页面 下一篇 Sass ","link":"https://hviker.github.io/post/shi-xian-tong-liu-lan-qi-bu-tong-ye-mian-xia-de-shu-ju-tong-xin/"},{"title":"SpringBoot下实现原生Websocket","content":"1、pom.xml中引入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; 2、开启对Websocket的支持 @Configuration public class WebSocketConfigs { @Bean public ServerEndpointExporter serverEndpointExporter() { return new ServerEndpointExporter(); } } 3、封装server package com.jxdinfo.gdjf.train.websocketOrigin; import com.jxdinfo.gdjf.train.proto.HeartBeatClass; import org.springframework.stereotype.Component; import javax.websocket.*; import javax.websocket.server.PathParam; import javax.websocket.server.ServerEndpoint; import java.io.IOException; import java.util.concurrent.CopyOnWriteArraySet; @ServerEndpoint(&quot;/websocket&quot;) @Component public class WebSocketServer { //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。 private static int onlineCount = 0; //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。 private static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketServer&gt;(); //与某个客户端的连接会话，需要通过它来给客户端发送数据 private Session session; //接收sid private String sid=&quot;&quot;; /** * 连接建立成功调用的方法 */ @OnOpen public void onOpen(Session session) { this.session = session; webSocketSet.add(this); //加入set中 addOnlineCount(); //在线数加1 this.sid=sid; try { sendMessage(&quot;连接成功&quot;); } catch (IOException e) { System.out.print(e); } } /** * 连接关闭调用的方法 */ @OnClose public void onClose() { webSocketSet.remove(this); //从set中删除 subOnlineCount(); //在线数减1 System.out.print(&quot;有一连接关闭！当前在线人数为&quot; + getOnlineCount()); } /** * 收到客户端消息后调用的方法 * @param message * @param session */ @OnMessage public void onMessage(String message, Session session) { System.out.print(&quot;收到来自窗口&quot; + sid + &quot;的信息:&quot;); //群发消息 for (WebSocketServer item : webSocketSet) { try { item.sendMessage(message); } catch (IOException e) { e.printStackTrace(); } } } /** * 错误处理 */ @OnError public void onError(Session session, Throwable error) { System.out.print(&quot;发生错误&quot;); error.printStackTrace(); } /** * 实现服务器主动推送 */ public void sendMessage(String message) throws IOException { this.session.getBasicRemote().sendText(message); } /** * 消息群发自定义 * @param message * @param * @throws IOException */ public static void sendInfo(String message) throws IOException { System.out.print(&quot;推送消息到窗口&quot;+ &quot;推送内容:&quot;+message); } public static synchronized int getOnlineCount() { return onlineCount; } public static synchronized void addOnlineCount() { WebSocketServer.onlineCount++; } public static synchronized void subOnlineCount() { WebSocketServer.onlineCount--; } public static CopyOnWriteArraySet&lt;WebSocketServer&gt; getWebSocketSet() { return webSocketSet; } } ","link":"https://hviker.github.io/post/springboot-xia-shi-xian-yuan-sheng-websocket/"},{"title":"VUE+Websocket+Protobuf","content":"1、项目场景 监控某工程状态变化，将后台推送信息解析并实时展示，推送数据量较大。 2、使用技术 vue+websocket+protobuf 3、技术介绍 Websocket 通信协议,基于tcp。与http协议不同，http是短连接，浏览器给服务端发送请求时开始，服务端接收处理响应后关闭，而且http协议只能由浏览器端发起，服务端无法直接推送。而ws是一个长连接，在vue的单个页面中，从页面创建(或者调用ws初始化方法)时开始，在当前页面关闭时结束。如果想要在整个项目中通用一个ws,可以将ws的触发放在app.vue上。ws可以实现浏览器端和服务端的双向通信，消息可以是文本也可以是二进制流数据(blob)，不存在跨域问题。使用ws就可以实现后台主动向前端推送数据，保证数据的实时渲染。 protobuf protobuf是一种与语言无关、平台无关、可扩展的序列化数据结构，可以用于数据通信、数据存储。序列化是指将数据结构或者对象转换成能够被存储和传输的格式，同时保证序列化的结果在另一种环境中能够被重建回原来的数据或者对象。相比于XML、JSON，protobuf更加高效，适用于数据量较大的场景。 4、前端websocket实现 这里提供两种ws实现方式：原生ws、借助stompJS实现ws，两者差距在于后台ws的使用。如果后台使用的是Spring底层及的Websocket API,就使用原生的ws,如果后台启用了SockJS通信，就使用借助stompJS实现ws。需要注意的是，原生的ws在由浏览器端向后台发送数据时，后台支持接收的数据类型有String,ArrayBuffer、Blob、ArrayBufferView，但是借助stompJS的实现方式只支持发送String。 原生ws实现 &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &quot;&quot;, components: {}, props: [], data() { return { path: &quot;ws://127.0.0.1:8085/binaryHandler&quot;, // socket连接地址 socket: &quot;&quot;, // socket对象 }; }, watch: {}, computed: {}, methods: { init() { // 判断浏览器是否支持socket if (typeof WebSocket === &quot;undefined&quot;) { this.$message({ message: &quot;您的浏览器不支持socket&quot;, type: &quot;warn&quot; }); } else { // 实例化socket this.socket = new WebSocket(this.path); // 监听socket连接 this.socket.onopen = this.open; // 监听socket错误信息 this.socket.onerror = this.error; // 监听socket推送消息 this.socket.onmessage = this.getMessage; } }, open() { console.log(&quot;socket连接成功&quot;); }, error() { console.log(&quot;连接错误&quot;); }, getMessage(msg) { console.log(msg) }, send() { this.socket.send(&quot;数据发送&quot;); }, close() { console.log(&quot;socket已关闭&quot;); } }, created() {}, mounted() { this.init(); }, destroyed() { this.socket.close = this.close; } }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; &lt;/style&gt; 基于stompJS实现 &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import SockJS from &quot;sockjs-client&quot;; import Stomp from &quot;stompjs&quot;; import heartBeat from &quot;@/proto/HeartBeat_pb&quot;; export default { name: &quot;SocketLink&quot;, components: {}, props: [], data() { return { socketDir: &quot;http://127.0.0.1:8085/gs-guide-websocket&quot;, // socket连接地址 stompClient: null, // STOMP子协议的客户端对象 sendUrl: &quot;/app/hello&quot;, // 发送数据通道 receiveUrl: &quot;/topic/greetings&quot; // 接收数据通道 }; }, watch: {}, computed: {}, methods: { // socket创建连接 initWebSocket() { // 建立连接对象 let socket = new SockJS(this.socketDir); this.stompClient = Stomp.over(socket); // 获取STOMP子协议的客户端对象 this.connection(); }, connection() { // 定义客户端的认证信息,按需求配置 let headers = {}; // 向服务器发起websocket连接 this.stompClient.connect( headers, () =&gt; { this.stompClient.subscribe( this.receiveUrl, msg =&gt; { // todo 对数据处理 let data = msg; }, headers ); }, err =&gt; { // 连接发生错误时的处理函数 console.log(err); } ); }, // 断开连接 disconnect() { if (this.stompClient) { this.stompClient.disconnect(); } }, // 发送数据 sendMessage() { let msg = &quot;aaa&quot;; // 这里只支持发送string类型 this.stompClient.send(this.sendUrl, {}, msg); } }, created() {}, mounted() { this.initWebSocket(); } }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; &lt;/style&gt; 5、前端protobuf数据处理 这里提供两种protobuf数据处理方式，借助google-protobuf、借助protobufJS。借助于StompJS的ws的实现后台不能接收arraybuffer数据类型，这里仅配合后台原生ws的实现。 借助google-protobuf (1) 使用npm下载 google-protobuf。 npm install google-protobuf -S (2) 由于是在vue中使用，建议将后台提供的proto转化成js。后台提供的proto文件类似于以下格式： syntax = &quot;proto3&quot;; option java_package = &quot;com.train.proto&quot;; option java_outer_classname = &quot;HeartBeatClass&quot;; message HeartBeat { int32 heart =1; int32 time =2; int32 ids =3; int64 requestInfo =4; } 在命令行执行下面代码，转化成js文件 protoc.exe --js_out=import_style=commonjs,binary:. xxx.proto (3) google-protobuf提供了序列化和反序列化的方法，可以实现对二进制数据的处理 &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import heartBeat from &quot;@/proto/HeartBeat_pb&quot;; export default { name: &quot;&quot;, components: {}, props: [], data() { return { path: &quot;ws://127.0.0.1:8085/binaryHandler&quot;, // socket连接地址 socket: &quot;&quot;, // socket对象 }; }, watch: {}, computed: {}, methods: { init() { // 判断浏览器是否支持socket if (typeof WebSocket === &quot;undefined&quot;) { this.$message({ message: &quot;您的浏览器不支持socket&quot;, type: &quot;warn&quot; }); } else { // 实例化socket this.socket = new WebSocket(this.path); // 监听socket连接 // 监听socket错误信息 this.socket.onerror = this.error; // 监听socket推送消息 this.socket.onmessage = this.getMessage; } }, open() { console.log(&quot;socket连接成功&quot;); }, error() { console.log(&quot;连接错误&quot;); }, getMessage(msg) { // websocket server 返回的是blob let result = msg.data; if (result instanceof Blob) { // 对blob数据进行处理 let reader = new FileReader(); reader.readAsArrayBuffer(result); reader.onload = ()=&gt;{ const buf = new Uint8Array(reader.result); // 反序列化 let decodeMsg = heartBeat.HeartBeat.deserializeBinary(buf); // 获取数据，使用getXXX(); let requestInfo = decodeMsg.getRequestinfo() } } }, send() { if(this.socket === &quot;&quot;) return; // 创建heart对象 const heart = new heartBeat.HeartBeat(); // 赋值,使用setXXX heart.setHeart(100); heart.setTime(150); heart.setIds(200); heart.setRequestinfo(250); // 序列化 const hearts = heart.serializeBinary(); this.socket.send(buf); }, close() { console.log(&quot;socket已关闭&quot;); } }, created() {}, mounted() { this.init() }, destroyed() { this.socket.close = this.close; } }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; &lt;/style&gt; 关于google-protobuf的详细介绍见官网:https://www.npmjs.com/package/google-protobuf 借助于protobufJS (1) 使用npm下载 protobufJS。 npm install protobufjs -S； (2) 同样推荐将proto文件转化成js文件 在项目跟目录下执行，A：生成js文件存放位置 B:需要生成js的proto文件 npx pbjs -t json-module -w commonjs -o A B 例如： npx pbjs -t json-module -w commonjs -o src/proto/HeartBeat.js src/proto/HeartBeat.proto (3) protobufJS提供方法较多，lookup、encode、decode等 &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import heartBeatOth from &quot;@/proto/HeartBeat&quot; export default { name: &quot;&quot;, components: {}, props: [], data() { return { path: &quot;ws://127.0.0.1:8085/binaryHandler&quot;, // socket连接地址 socket: &quot;&quot;, // socket实例 heartOther: &quot;&quot;, // heartBeatOth对象 }; }, watch: {}, computed: {}, methods: { init() { // 判断浏览器是否支持socket if (typeof WebSocket === &quot;undefined&quot;) { this.$message({ message: &quot;您的浏览器不支持socket&quot;, type: &quot;warn&quot; }); } else { // 实例化socket this.socket = new WebSocket(this.path); // 监听socket连接 this.socket.onopen = this.open; // 获取消息类型 this.heartOther = heartBeatOth.lookup(&quot;HeartBeat&quot;); // 监听socket错误信息 this.socket.onerror = this.error; // 监听socket推送消息 this.socket.onmessage = this.getMessage; } }, open() { console.log(&quot;socket连接成功&quot;); }, error() { console.log(&quot;连接错误&quot;); }, getMessage(msg) { // websocket server返回的是blob let result = msg.data; if (result instanceof Blob) { // 对blob进行处理 let reader = new FileReader(); reader.readAsArrayBuffer(result); reader.onload = ()=&gt;{ const buf = new Uint8Array(reader.result); let decodeMsg = this.heartOther.decode(buf); let { requestInfo } = decodeMsg; } } }, send() { if(this.socket === &quot;&quot;) return; // 传递内容 let cont = { heart: 100, time: 150, ids: 200, requestInfo: 250 } // 验证内容是否有效 let errMsg = this.heartOther.verify(cont); if(errMsg) throw Error(errMsg); // 创建消息实体 let message = this.heartOther.create(cont); // 将消息实体编码成Uint8Array let buf = this.heartOther.encode(message).finish(); this.socket.send(buf); }, close() { console.log(&quot;socket已关闭&quot;); } }, created() {}, mounted() { this.init(); }, destroyed() { this.socket.close = this.close; } }; &lt;/script&gt; &lt;style lang='scss' scoped&gt; &lt;/style&gt; 关于google-protobuf的详细介绍见官网:https://www.npmjs.com/package/protobufjs 补充 (1) 使用axios对接收protobuf数据的处理。需要修改content-type, responseType import Vue from 'vue' import axios from 'axios' const protoSer = axios.create({ timeout: 60000, headers: { 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/x-protobuf;charset=UTF-8' }, responseType: 'arraybuffer' }) Vue.prototype.$protoSer = protoSer export default protoSer (2) 使用google-protobuf、protobufJS在数据反序列化、序列化、获取数据上的打印结果 google-protobuf反序列化 protobufJS反序列化 google-protobuf序列化 protobufJS序列化 google-protobuf获取数据 protobufJS获取数据 ","link":"https://hviker.github.io/post/vuewebsocketprotobuf/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://hviker.github.io/post/hello-gridea/"}]}